import "./chunk-EWTE5DHJ.js";

// node_modules/@hebcal/core/dist/esm/pkgVersion.js
var version = "5.10.1";

// node_modules/@hebcal/hdate/dist/esm/greg.js
var lengths = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var monthLengths = [lengths, lengths.slice()];
monthLengths[1][2] = 29;
function mod(x2, y2) {
  return x2 - y2 * Math.floor(x2 / y2);
}
function quotient(x2, y2) {
  return Math.floor(x2 / y2);
}
function yearFromFixed(abs) {
  const l0 = abs - 1;
  const n400 = quotient(l0, 146097);
  const d1 = mod(l0, 146097);
  const n100 = quotient(d1, 36524);
  const d2 = mod(d1, 36524);
  const n4 = quotient(d2, 1461);
  const d3 = mod(d2, 1461);
  const n1 = quotient(d3, 365);
  const year = 400 * n400 + 100 * n100 + 4 * n4 + n1;
  return n100 !== 4 && n1 !== 4 ? year + 1 : year;
}
function isGregLeapYear(year) {
  return !(year % 4) && (!!(year % 100) || !(year % 400));
}
function daysInGregMonth(month, year) {
  return monthLengths[+isGregLeapYear(year)][month];
}
function isDate(obj) {
  return typeof obj === "object" && Date.prototype.isPrototypeOf(obj);
}
function toFixed(year, month, day) {
  const py = year - 1;
  return 365 * py + quotient(py, 4) - quotient(py, 100) + quotient(py, 400) + quotient(367 * month - 362, 12) + (month <= 2 ? 0 : isGregLeapYear(year) ? -1 : -2) + day;
}
function greg2abs(date) {
  if (!isDate(date)) {
    throw new TypeError(`not a Date: ${date}`);
  } else if (isNaN(date.getTime())) {
    throw new RangeError("Invalid Date");
  }
  const abs = toFixed(date.getFullYear(), date.getMonth() + 1, date.getDate());
  return abs;
}
function abs2greg(abs) {
  if (typeof abs !== "number" || isNaN(abs)) {
    throw new TypeError(`not a Number: ${abs}`);
  }
  abs = Math.trunc(abs);
  const year = yearFromFixed(abs);
  const priorDays = abs - toFixed(year, 1, 1);
  const correction = abs < toFixed(year, 3, 1) ? 0 : isGregLeapYear(year) ? 1 : 2;
  const month = quotient(12 * (priorDays + correction) + 373, 367);
  const day = abs - toFixed(year, month, 1) + 1;
  const dt2 = new Date(year, month - 1, day);
  if (year < 100 && year >= 0) {
    dt2.setFullYear(year);
  }
  return dt2;
}

// node_modules/@hebcal/hdate/dist/esm/gregNamespace.js
var greg;
/* @__PURE__ */ (function(greg2) {
})(greg || (greg = {}));
greg.abs2greg = abs2greg;
greg.daysInMonth = daysInGregMonth;
greg.greg2abs = greg2abs;
greg.isDate = isDate;
greg.isLeapYear = isGregLeapYear;

// node_modules/@hebcal/hdate/dist/esm/hebrewStripNikkud.js
function hebrewStripNikkud(str) {
  const a2 = str.normalize();
  return a2.replace(/[\u0590-\u05bd]/g, "").replace(/[\u05bf-\u05c7]/g, "");
}

// node_modules/@hebcal/hdate/dist/esm/hdateBase.js
var NISAN = 1;
var IYYAR = 2;
var SIVAN = 3;
var TAMUZ = 4;
var AV = 5;
var ELUL = 6;
var TISHREI = 7;
var CHESHVAN = 8;
var KISLEV = 9;
var TEVET = 10;
var SHVAT = 11;
var ADAR_I = 12;
var ADAR_II = 13;
var months = {
  /** Nissan / ניסן */
  NISAN,
  /** Iyyar / אייר */
  IYYAR,
  /** Sivan / סיון */
  SIVAN,
  /** Tamuz (sometimes Tammuz) / תמוז */
  TAMUZ,
  /** Av / אב */
  AV,
  /** Elul / אלול */
  ELUL,
  /** Tishrei / תִּשְׁרֵי */
  TISHREI,
  /** Cheshvan / חשון */
  CHESHVAN,
  /** Kislev / כסלו */
  KISLEV,
  /** Tevet / טבת */
  TEVET,
  /** Sh'vat / שבט */
  SHVAT,
  /** Adar or Adar Rishon / אדר */
  ADAR_I,
  /** Adar Sheini (only on leap years) / אדר ב׳ */
  ADAR_II
};
var NISAN_STR = "Nisan";
var monthNames0 = [
  "",
  NISAN_STR,
  "Iyyar",
  "Sivan",
  "Tamuz",
  "Av",
  "Elul",
  "Tishrei",
  "Cheshvan",
  "Kislev",
  "Tevet",
  "Sh'vat"
];
var monthNames = [
  [...monthNames0, "Adar", NISAN_STR],
  [...monthNames0, "Adar I", "Adar II", NISAN_STR]
];
var edCache = /* @__PURE__ */ new Map();
var EPOCH = -1373428;
var AVG_HEBYEAR_DAYS = 365.24682220597794;
function assertNumber(n2, name) {
  if (typeof n2 !== "number" || isNaN(n2)) {
    throw new TypeError(`param '${name}' not a number: ${n2}`);
  }
}
function hebrew2abs(year, month, day) {
  assertNumber(year, "year");
  assertNumber(month, "month");
  assertNumber(day, "day");
  if (year < 1) {
    throw new RangeError(`hebrew2abs: invalid year ${year}`);
  }
  let tempabs = day;
  if (month < TISHREI) {
    for (let m2 = TISHREI; m2 <= monthsInYear(year); m2++) {
      tempabs += daysInMonth(m2, year);
    }
    for (let m2 = NISAN; m2 < month; m2++) {
      tempabs += daysInMonth(m2, year);
    }
  } else {
    for (let m2 = TISHREI; m2 < month; m2++) {
      tempabs += daysInMonth(m2, year);
    }
  }
  return EPOCH + elapsedDays(year) + tempabs - 1;
}
function newYear(year) {
  return EPOCH + elapsedDays(year);
}
function abs2hebrew(abs) {
  assertNumber(abs, "abs");
  abs = Math.trunc(abs);
  if (abs <= EPOCH) {
    throw new RangeError(`abs2hebrew: ${abs} is before epoch`);
  }
  let year = Math.floor((abs - EPOCH) / AVG_HEBYEAR_DAYS);
  while (newYear(year) <= abs) {
    ++year;
  }
  --year;
  let month = abs < hebrew2abs(year, 1, 1) ? 7 : 1;
  while (abs > hebrew2abs(year, month, daysInMonth(month, year))) {
    ++month;
  }
  const day = 1 + abs - hebrew2abs(year, month, 1);
  return { yy: year, mm: month, dd: day };
}
function isLeapYear(year) {
  return (1 + year * 7) % 19 < 7;
}
function monthsInYear(year) {
  return 12 + +isLeapYear(year);
}
function daysInMonth(month, year) {
  switch (month) {
    case IYYAR:
    case TAMUZ:
    case ELUL:
    case TEVET:
    case ADAR_II:
      return 29;
  }
  if (month === ADAR_I && !isLeapYear(year) || month === CHESHVAN && !longCheshvan(year) || month === KISLEV && shortKislev(year)) {
    return 29;
  } else {
    return 30;
  }
}
function getMonthName(month, year) {
  assertNumber(month, "month");
  assertNumber(year, "year");
  if (month < 1 || month > 14) {
    throw new TypeError(`bad monthNum: ${month}`);
  }
  return monthNames[+isLeapYear(year)][month];
}
function elapsedDays(year) {
  const n2 = edCache.get(year);
  if (typeof n2 === "number") {
    return n2;
  }
  const elapsed = elapsedDays0(year);
  edCache.set(year, elapsed);
  return elapsed;
}
function elapsedDays0(year) {
  const prevYear = year - 1;
  const mElapsed = 235 * Math.floor(prevYear / 19) + // Months in complete 19 year lunar (Metonic) cycles so far
  12 * (prevYear % 19) + // Regular months in this cycle
  Math.floor((prevYear % 19 * 7 + 1) / 19);
  const pElapsed = 204 + 793 * (mElapsed % 1080);
  const hElapsed = 5 + 12 * mElapsed + 793 * Math.floor(mElapsed / 1080) + Math.floor(pElapsed / 1080);
  const parts = pElapsed % 1080 + 1080 * (hElapsed % 24);
  const day = 1 + 29 * mElapsed + Math.floor(hElapsed / 24);
  let altDay = day;
  if (parts >= 19440 || 2 === day % 7 && parts >= 9924 && !isLeapYear(year) || 1 === day % 7 && parts >= 16789 && isLeapYear(prevYear)) {
    altDay++;
  }
  if (altDay % 7 === 0 || altDay % 7 === 3 || altDay % 7 === 5) {
    return altDay + 1;
  } else {
    return altDay;
  }
}
function daysInYear(year) {
  return elapsedDays(year + 1) - elapsedDays(year);
}
function longCheshvan(year) {
  return daysInYear(year) % 10 === 5;
}
function shortKislev(year) {
  return daysInYear(year) % 10 === 3;
}
function monthFromName(monthName) {
  if (typeof monthName === "number") {
    if (isNaN(monthName) || monthName < 1 || monthName > 14) {
      throw new RangeError(`bad monthName: ${monthName}`);
    }
    return monthName;
  }
  let c2 = monthName.trim().toLowerCase();
  c2 = hebrewStripNikkud(c2).replace(/׳$/, "");
  if (c2[0] === "ב") {
    c2 = c2.substring(1);
  }
  switch (c2[0]) {
    case "n":
    case "נ":
      if (c2[1] === "o") {
        break;
      }
      return NISAN;
    case "i":
      return IYYAR;
    case "e":
      return ELUL;
    case "c":
    case "ח":
      return CHESHVAN;
    case "k":
    case "כ":
      return KISLEV;
    case "s":
      switch (c2[1]) {
        case "i":
          return SIVAN;
        case "h":
          return SHVAT;
      }
      break;
    case "t":
      switch (c2[1]) {
        case "a":
          return TAMUZ;
        case "i":
          return TISHREI;
        case "e":
          return TEVET;
      }
      break;
    case "a":
      switch (c2[1]) {
        case "v":
          return AV;
        case "d":
          if (/(1|[^i]i|a|א)$/i.test(c2)) {
            return ADAR_I;
          }
          return ADAR_II;
      }
      break;
    case "ס":
      return SIVAN;
    case "ט":
      return TEVET;
    case "ש":
      return SHVAT;
    case "א":
      switch (c2[1]) {
        case "ב":
          return AV;
        case "ד":
          if (/(1|[^i]i|a|א)$/i.test(c2)) {
            return ADAR_I;
          }
          return ADAR_II;
        case "י":
          return IYYAR;
        case "ל":
          return ELUL;
      }
      break;
    case "ת":
      switch (c2[1]) {
        case "מ":
          return TAMUZ;
        case "ש":
          return TISHREI;
      }
      break;
  }
  throw new RangeError(`bad monthName: ${monthName}`);
}

// node_modules/@hebcal/hdate/dist/esm/anniversary.js
var NISAN2 = months.NISAN;
var CHESHVAN2 = months.CHESHVAN;
var KISLEV2 = months.KISLEV;
var TEVET2 = months.TEVET;
var SHVAT2 = months.SHVAT;
var ADAR_I2 = months.ADAR_I;
var ADAR_II2 = months.ADAR_II;
function isSimpleHebrewDate(obj) {
  return typeof obj === "object" && obj !== null && typeof obj.yy === "number" && typeof obj.mm === "number" && typeof obj.dd === "number";
}
function toSimpleHebrewDate(obj) {
  if (isSimpleHebrewDate(obj)) {
    return obj;
  } else if (isDate(obj)) {
    const abs = greg2abs(obj);
    return abs2hebrew(abs);
  } else {
    return abs2hebrew(obj);
  }
}
function getYahrzeitHD(hyear, date) {
  let hDeath = toSimpleHebrewDate(date);
  if (hyear <= hDeath.yy) {
    return void 0;
  }
  if (hDeath.mm === CHESHVAN2 && hDeath.dd === 30 && !longCheshvan(hDeath.yy + 1)) {
    hDeath = abs2hebrew(hebrew2abs(hyear, KISLEV2, 1) - 1);
  } else if (hDeath.mm === KISLEV2 && hDeath.dd === 30 && shortKislev(hDeath.yy + 1)) {
    hDeath = abs2hebrew(hebrew2abs(hyear, TEVET2, 1) - 1);
  } else if (hDeath.mm === ADAR_II2) {
    hDeath.mm = monthsInYear(hyear);
  } else if (hDeath.mm === ADAR_I2 && hDeath.dd === 30 && !isLeapYear(hyear)) {
    hDeath.dd = 30;
    hDeath.mm = SHVAT2;
  }
  if (hDeath.mm === CHESHVAN2 && hDeath.dd === 30 && !longCheshvan(hyear)) {
    hDeath.mm = KISLEV2;
    hDeath.dd = 1;
  } else if (hDeath.mm === KISLEV2 && hDeath.dd === 30 && shortKislev(hyear)) {
    hDeath.mm = TEVET2;
    hDeath.dd = 1;
  }
  hDeath.yy = hyear;
  return hDeath;
}
function getBirthdayHD(hyear, date) {
  const orig = toSimpleHebrewDate(date);
  const origYear = orig.yy;
  if (hyear === origYear) {
    return orig;
  } else if (hyear < origYear) {
    return void 0;
  }
  const isOrigLeap = isLeapYear(origYear);
  let month = orig.mm;
  let day = orig.dd;
  if (month === ADAR_I2 && !isOrigLeap || month === ADAR_II2 && isOrigLeap) {
    month = monthsInYear(hyear);
  } else if (month === CHESHVAN2 && day === 30 && !longCheshvan(hyear)) {
    month = KISLEV2;
    day = 1;
  } else if (month === KISLEV2 && day === 30 && shortKislev(hyear)) {
    month = TEVET2;
    day = 1;
  } else if (month === ADAR_I2 && day === 30 && isOrigLeap && !isLeapYear(hyear)) {
    month = NISAN2;
    day = 1;
  }
  return { yy: hyear, mm: month, dd: day };
}

// node_modules/@hebcal/hdate/dist/esm/gematriya.js
var GERESH = "׳";
var GERSHAYIM = "״";
var heb2num = {
  א: 1,
  ב: 2,
  ג: 3,
  ד: 4,
  ה: 5,
  ו: 6,
  ז: 7,
  ח: 8,
  ט: 9,
  י: 10,
  כ: 20,
  ל: 30,
  מ: 40,
  נ: 50,
  ס: 60,
  ע: 70,
  פ: 80,
  צ: 90,
  ק: 100,
  ר: 200,
  ש: 300,
  ת: 400
};
var num2heb = {};
for (const [key, val] of Object.entries(heb2num)) {
  num2heb[val] = key;
}
function num2digits(num) {
  const digits = [];
  while (num > 0) {
    if (num === 15 || num === 16) {
      digits.push(9);
      digits.push(num - 9);
      break;
    }
    let incr = 100;
    let i2;
    for (i2 = 400; i2 > num; i2 -= incr) {
      if (i2 === incr) {
        incr = incr / 10;
      }
    }
    digits.push(i2);
    num -= i2;
  }
  return digits;
}
function gematriya(num) {
  const num1 = parseInt(num, 10);
  if (!num1 || num1 < 0) {
    throw new TypeError(`invalid number: ${num}`);
  }
  let str = "";
  const thousands = Math.floor(num1 / 1e3);
  if (thousands > 0 && thousands !== 5) {
    const tdigits = num2digits(thousands);
    for (const tdig of tdigits) {
      str += num2heb[tdig];
    }
    str += GERESH;
  }
  const digits = num2digits(num1 % 1e3);
  if (digits.length === 1) {
    return str + num2heb[digits[0]] + GERESH;
  }
  for (let i2 = 0; i2 < digits.length; i2++) {
    if (i2 + 1 === digits.length) {
      str += GERSHAYIM;
    }
    str += num2heb[digits[i2]];
  }
  return str;
}
function gematriyaStrToNum(str) {
  let num = 0;
  const gereshIdx = str.indexOf(GERESH);
  if (gereshIdx !== -1 && gereshIdx !== str.length - 1) {
    const thousands = str.substring(0, gereshIdx);
    num += gematriyaStrToNum(thousands) * 1e3;
    str = str.substring(gereshIdx);
  }
  for (const ch of str) {
    const n2 = heb2num[ch];
    if (typeof n2 === "number") {
      num += n2;
    }
  }
  return num;
}

// node_modules/@hebcal/hdate/dist/esm/molad.js
function molad(year, month) {
  let m_adj = month - 7;
  if (m_adj < 0) {
    m_adj += monthsInYear(year);
  }
  const mElapsed = 235 * Math.floor((year - 1) / 19) + // Months in complete 19 year lunar (Metonic) cycles so far
  12 * ((year - 1) % 19) + // Regular months in this cycle
  Math.floor((7 * ((year - 1) % 19) + 1) / 19) + // Leap months this cycle
  m_adj;
  const pElapsed = 204 + Math.floor(793 * (mElapsed % 1080));
  const hElapsed = 5 + 12 * mElapsed + 793 * Math.floor(mElapsed / 1080) + Math.floor(pElapsed / 1080) - 6;
  const parts = pElapsed % 1080 + 1080 * (hElapsed % 24);
  const chalakim = parts % 1080;
  const day = 1 + 29 * mElapsed + Math.floor(hElapsed / 24);
  return {
    year,
    month,
    dayOfWeek: day % 7,
    hour: hElapsed % 24,
    minutes: Math.floor(chalakim / 18),
    chalakim: chalakim % 18
  };
}

// node_modules/@hebcal/hdate/dist/esm/pad.js
function pad4(num) {
  if (num < 0) {
    return "-00" + pad4(-num);
  } else if (num < 10) {
    return "000" + num;
  } else if (num < 100) {
    return "00" + num;
  } else if (num < 1e3) {
    return "0" + num;
  }
  return String(num);
}
function pad2(num) {
  if (num >= 0 && num < 10) {
    return "0" + num;
  }
  return String(num);
}

// node_modules/@hebcal/hdate/dist/esm/dateFormat.js
var _formatters = /* @__PURE__ */ new Map();
function getFormatter(tzid) {
  const fmt = _formatters.get(tzid);
  if (fmt)
    return fmt;
  const f2 = new Intl.DateTimeFormat("en-US", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: false,
    timeZone: tzid
  });
  _formatters.set(tzid, f2);
  return f2;
}
var dateFormatRegex = /^(\d+).(\d+).(\d+),?\s+(\d+).(\d+).(\d+)/;
function getPseudoISO(tzid, date) {
  const str = getFormatter(tzid).format(date);
  const m2 = dateFormatRegex.exec(str);
  if (m2 === null) {
    throw new Error(`Unable to parse formatted string: ${str}`);
  }
  let hour = m2[4];
  if (hour === "24") {
    hour = "00";
  }
  m2[3] = pad4(parseInt(m2[3], 10));
  return `${m2[3]}-${m2[1]}-${m2[2]}T${hour}:${m2[5]}:${m2[6]}Z`;
}
function getTimezoneOffset(tzid, date) {
  const utcStr = getPseudoISO("UTC", date);
  const localStr = getPseudoISO(tzid, date);
  const diffMs = new Date(utcStr).getTime() - new Date(localStr).getTime();
  return Math.ceil(diffMs / 1e3 / 60);
}
function isoDateString(dt2) {
  return pad4(dt2.getFullYear()) + "-" + pad2(dt2.getMonth() + 1) + "-" + pad2(dt2.getDate());
}

// node_modules/@hebcal/hdate/dist/esm/ashkenazi.po.js
var poAshkenazi = { "headers": { "plural-forms": "nplurals=2; plural=(n > 1);", "language": "en_CA@ashkenazi" }, "contexts": { "": { "Tevet": ["Teves"] } } };

// node_modules/@hebcal/hdate/dist/esm/he.po.js
var poHe = { "headers": { "plural-forms": "nplurals=2; plural=(n > 1);", "language": "he" }, "contexts": { "": { "Adar": ["אֲדָר"], "Adar I": ["אֲדָר א׳"], "Adar II": ["אֲדָר ב׳"], "Av": ["אָב"], "Cheshvan": ["חֶשְׁוָן"], "Elul": ["אֱלוּל"], "Iyyar": ["אִיָּיר"], "Kislev": ["כִּסְלֵו"], "Nisan": ["נִיסָן"], "Sh'vat": ["שְׁבָט"], "Sivan": ["סִיוָן"], "Tamuz": ["תַּמּוּז"], "Tevet": ["טֵבֵת"], "Tishrei": ["תִּשְׁרֵי"] } } };

// node_modules/@hebcal/hdate/dist/esm/locale.js
var noopLocale = {
  headers: { "plural-forms": "nplurals=2; plural=(n!=1);" },
  contexts: { "": {} }
};
var alias = {
  h: "he",
  a: "ashkenazi",
  s: "en",
  "": "en"
};
var locales = /* @__PURE__ */ new Map();
var activeLocale;
var activeName;
function getEnOrdinal(n2) {
  const s2 = ["th", "st", "nd", "rd"];
  const v2 = n2 % 100;
  return n2 + (s2[(v2 - 20) % 10] || s2[v2] || s2[0]);
}
function checkLocale(locale) {
  if (typeof locale !== "string") {
    throw new TypeError(`Invalid locale name: ${locale}`);
  }
  return locale.toLowerCase();
}
function getExistingLocale(locale) {
  const locale1 = checkLocale(locale);
  const loc = locales.get(locale1);
  if (!loc) {
    throw new RangeError(`Locale '${locale}' not found`);
  }
  return loc;
}
var Locale = class {
  /**
   * Returns translation only if `locale` offers a non-empty translation for `id`.
   * Otherwise, returns `undefined`.
   * @param id Message ID to translate
   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   */
  static lookupTranslation(id, locale) {
    const loc = typeof locale === "string" && locales.get(locale.toLowerCase()) || activeLocale;
    const array = loc[id];
    if ((array === null || array === void 0 ? void 0 : array.length) && array[0].length) {
      return array[0];
    }
    return void 0;
  }
  /**
   * By default, if no translation was found, returns `id`.
   * @param id Message ID to translate
   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   */
  static gettext(id, locale) {
    const text = this.lookupTranslation(id, locale);
    if (typeof text === "undefined") {
      return id;
    }
    return text;
  }
  /**
   * Register locale translations.
   * @param locale Locale name (i.e.: `'he'`, `'fr'`)
   * @param data parsed data from a `.po` file.
   */
  static addLocale(locale, data) {
    locale = checkLocale(locale);
    if (typeof data.contexts !== "object" || typeof data.contexts[""] !== "object") {
      throw new TypeError(`Locale '${locale}' invalid compact format`);
    }
    locales.set(locale, data.contexts[""]);
  }
  /**
   * Adds a translation to `locale`, replacing any previous translation.
   * @param locale Locale name (i.e: `'he'`, `'fr'`).
   * @param id Message ID to translate
   * @param translation Translation text
   */
  static addTranslation(locale, id, translation) {
    const loc = getExistingLocale(locale);
    if (typeof id !== "string" || id.length === 0) {
      throw new TypeError(`Invalid id string: ${id}`);
    }
    const isArray = Array.isArray(translation);
    if (isArray) {
      const t0 = translation[0];
      if (typeof t0 !== "string" || t0.length === 0) {
        throw new TypeError(`Invalid translation array: ${translation}`);
      }
    } else if (typeof translation !== "string") {
      throw new TypeError(`Invalid translation string: ${translation}`);
    }
    loc[id] = isArray ? translation : [translation];
  }
  /**
   * Adds multiple translations to `locale`, replacing any previous translations.
   * @param locale Locale name (i.e: `'he'`, `'fr'`).
   * @param data parsed data from a `.po` file.
   */
  static addTranslations(locale, data) {
    const loc = getExistingLocale(locale);
    if (typeof data.contexts !== "object" || typeof data.contexts[""] !== "object") {
      throw new TypeError(`Locale '${locale}' invalid compact format`);
    }
    const ctx = data.contexts[""];
    Object.assign(loc, ctx);
  }
  /**
   * Activates a locale. Throws an error if the locale has not been previously added.
   * After setting the locale to be used, all strings marked for translations
   * will be represented by the corresponding translation in the specified locale.
   * @param locale Locale name (i.e: `'he'`, `'fr'`)
   * @deprecated
   */
  static useLocale(locale) {
    const locale0 = checkLocale(locale);
    const obj = getExistingLocale(locale0);
    activeName = alias[locale0] || locale0;
    activeLocale = obj;
    return activeLocale;
  }
  /**
   * Returns the name of the active locale (i.e. 'he', 'ashkenazi', 'fr')
   * @deprecated
   */
  static getLocaleName() {
    return activeName;
  }
  /**
   * Returns the names of registered locales
   */
  static getLocaleNames() {
    const keys = Array.from(locales.keys());
    return keys.sort((a2, b2) => a2.localeCompare(b2));
  }
  /**
   * Renders a number in ordinal, such as 1st, 2nd or 3rd
   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   */
  static ordinal(n2, locale) {
    const locale1 = locale === null || locale === void 0 ? void 0 : locale.toLowerCase();
    const locale0 = locale1 || activeName;
    if (!locale0) {
      return getEnOrdinal(n2);
    }
    switch (locale0) {
      case "en":
      case "s":
      case "a":
        return getEnOrdinal(n2);
      case "es":
        return n2 + "º";
      case "h":
      case "he":
      case "he-x-nonikud":
        return String(n2);
    }
    if (locale0.startsWith("ashkenazi")) {
      return getEnOrdinal(n2);
    }
    return n2 + ".";
  }
  /**
   * Removes nekudot from Hebrew string
   */
  static hebrewStripNikkud(str) {
    return hebrewStripNikkud(str);
  }
};
Locale.addLocale("en", noopLocale);
Locale.addLocale("s", noopLocale);
Locale.addLocale("", noopLocale);
Locale.useLocale("en");
Locale.addLocale("ashkenazi", poAshkenazi);
Locale.addLocale("a", poAshkenazi);
Locale.addLocale("he", poHe);
Locale.addLocale("h", poHe);
var heStrs = poHe.contexts[""];
var heNoNikud = {};
for (const [key, val] of Object.entries(heStrs)) {
  heNoNikud[key] = [Locale.hebrewStripNikkud(val[0])];
}
var poHeNoNikud = {
  headers: poHe.headers,
  contexts: { "": heNoNikud }
};
Locale.addLocale("he-x-NoNikud", poHeNoNikud);

// node_modules/@hebcal/hdate/dist/esm/hdate.js
function mod2(x2, y2) {
  return x2 - y2 * Math.floor(x2 / y2);
}
function isSimpleHebrewDate2(obj) {
  return obj.yy !== void 0;
}
var UNITS_DAY = "day";
var UNITS_WEEK = "week";
var UNITS_MONTH = "month";
var UNITS_YEAR = "year";
var HDate = class _HDate {
  /**
   * Create a Hebrew date. There are 3 basic forms for the `HDate()` constructor.
   *
   * 1. No parameters - represents the current Hebrew date at time of instantiation
   * 2. One parameter
   *    * `Date` - represents the Hebrew date corresponding to the Gregorian date using
   *       local time. Hours, minutes, seconds and milliseconds are ignored.
   *    * `HDate` - clones a copy of the given Hebrew date
   *    * `number` - Converts absolute R.D. days to Hebrew date.
   *       R.D. 1 == the imaginary date January 1, 1 (Gregorian)
   * 3. Three parameters: Hebrew day, Hebrew month, Hebrew year. Hebrew day should
   *    be a number between 1-30, Hebrew month can be a number or string, and
   *    Hebrew year is always a number.
   * @example
   * import {HDate, months} from '@hebcal/hdate';
   *
   * const hd1 = new HDate();
   * const hd2 = new HDate(new Date(2008, 10, 13));
   * const hd3 = new HDate(15, 'Cheshvan', 5769);
   * const hd4 = new HDate(15, months.CHESHVAN, 5769);
   * const hd5 = new HDate(733359); // ==> 15 Cheshvan 5769
   * const monthName = 'אייר';
   * const hd6 = new HDate(5, monthName, 5773);
   * @param [day] - Day of month (1-30) if a `number`.
   *   If a `Date` is specified, represents the Hebrew date corresponding to the
   *   Gregorian date using local time.
   *   If an `HDate` is specified, clones a copy of the given Hebrew date.
   * @param [month] - Hebrew month of year (1=NISAN, 7=TISHREI)
   * @param [year] - Hebrew year
   */
  constructor(day, month, year) {
    if (arguments.length === 2 || arguments.length > 3) {
      throw new TypeError("HDate constructor requires 0, 1 or 3 arguments");
    }
    if (arguments.length === 3) {
      this.dd = this.mm = 1;
      const yy = typeof year === "string" ? parseInt(year, 10) : year;
      if (isNaN(yy)) {
        throw new TypeError(`HDate called with bad year: ${year}`);
      }
      this.yy = yy;
      setMonth(this, month);
      const dd = typeof day === "string" ? parseInt(day, 10) : day;
      if (isNaN(dd)) {
        throw new TypeError(`HDate called with bad day: ${day}`);
      }
      setDate(this, dd);
    } else {
      if (typeof day === "undefined" || day === null) {
        day = /* @__PURE__ */ new Date();
      }
      const abs0 = typeof day === "number" && !isNaN(day) ? day : isDate(day) ? greg2abs(day) : isSimpleHebrewDate2(day) ? day : null;
      if (abs0 === null) {
        throw new TypeError(`HDate called with bad arg: ${day}`);
      }
      const isNumber = typeof abs0 === "number";
      const d2 = isNumber ? abs2hebrew(abs0) : abs0;
      this.yy = d2.yy;
      this.mm = d2.mm;
      this.dd = d2.dd;
      if (isNumber) {
        this.rd = abs0;
      }
    }
  }
  /**
   * Returns the Hebrew year of this Hebrew date
   * @returns an integer >= 1
   * @example
   * const hd = new HDate(new Date(2008, 10, 13)); // 15 Cheshvan 5769
   * hd.getFullYear(); // 5769
   */
  getFullYear() {
    return this.yy;
  }
  /**
   * Returns `true` if this Hebrew date occurs during a Hebrew leap year
   * @example
   * const hd = new HDate(new Date(2008, 10, 13)); // 15 Cheshvan 5769
   * hd.isLeapYear(); // false
   */
  isLeapYear() {
    return isLeapYear(this.yy);
  }
  /**
   * Returns the Hebrew month (1=NISAN, 7=TISHREI) of this Hebrew date
   * @returns an integer 1-13
   * @example
   * const hd = new HDate(new Date(2008, 10, 13)); // 15 Cheshvan 5769
   * hd.getMonth(); // 8
   */
  getMonth() {
    return this.mm;
  }
  /**
   * The Tishrei-based month of this Hebrew date. 1 is Tishrei, 7 is Nisan, 13 is Elul in a leap year
   * @returns an integer 1-13
   * @example
   * const hd = new HDate(new Date(2008, 10, 13)); // 15 Cheshvan 5769
   * hd.getTishreiMonth(); // 2
   */
  getTishreiMonth() {
    const nummonths = monthsInYear(this.getFullYear());
    return (this.getMonth() + nummonths - 6) % nummonths || nummonths;
  }
  /**
   * Number of days in the month of this Hebrew date (29 or 30)
   * @returns an integer 29-30
   * @example
   * const hd = new HDate(new Date(2008, 10, 13)); // 15 Cheshvan 5769
   * hd.daysInMonth(); // 29
   */
  daysInMonth() {
    return daysInMonth(this.getMonth(), this.getFullYear());
  }
  /**
   * Gets the day within the month (1-30)
   * @returns an integer 1-30
   * @example
   * const hd = new HDate(new Date(2008, 10, 13)); // 15 Cheshvan 5769
   * hd.getDate(); // 15
   */
  getDate() {
    return this.dd;
  }
  /**
   * Returns the day of the week for this Hebrew date,
   * where 0 represents Sunday, 1 represents Monday, 6 represents Saturday.
   *
   * For the day of the month, see `getDate()`
   * @returns an integer 0-6
   * @example
   * const hd = new HDate(new Date(2008, 10, 13)); // 15 Cheshvan 5769
   * hd.getDate(); // 4
   */
  getDay() {
    return mod2(this.abs(), 7);
  }
  /**
   * Converts this Hebrew date to the corresponding Gregorian date.
   *
   * The returned `Date` object will be in the local (i.e. host system) time zone.
   * Hours, minutes, seconds and milliseconds will all be zero.
   *
   * Note that this function returns the daytime portion of the date.
   * For example, the 15th of Cheshvan 5769 began at sundown on
   * 12 November 2008 and continues through 13 November 2008. This
   * function would return only the date 13 November 2008.
   * @example
   * const hd = new HDate(15, 'Cheshvan', 5769);
   * const date = hd.greg(); // 13 November 2008
   * const year = date.getFullYear(); // 2008
   * const monthNum = date.getMonth() + 1; // 11
   * const day = date.getDate(); // 13
   */
  greg() {
    return abs2greg(this.abs());
  }
  /**
   * Converts from Hebrew date representation to R.D. (Rata Die) fixed days.
   * R.D. 1 is the imaginary date Monday, January 1, 1 (Gregorian).
   * Note also that R.D. = Julian Date − 1,721,424.5
   * @see {@link https://en.wikipedia.org/wiki/Rata_Die | Rata Die}
   * @example
   * const hd = new HDate(15, 'Cheshvan', 5769);
   * hd.abs(); // 733359
   */
  abs() {
    if (typeof this.rd !== "number") {
      this.rd = hebrew2abs(this.yy, this.mm, this.dd);
    }
    return this.rd;
  }
  /**
   * Converts Hebrew date to R.D. (Rata Die) fixed days.
   * R.D. 1 is the imaginary date Monday, January 1, 1 on the Gregorian
   * Calendar.
   * @param year Hebrew year
   * @param month Hebrew month (1=NISAN, 7=TISHREI)
   * @param day Hebrew date (1-30)
   * @example
   * import {HDate, months} from '@hebcal/hdate';
   * HDate.hebrew2abs(5769, months.CHESHVAN, 15); // 733359
   */
  static hebrew2abs(year, month, day) {
    return hebrew2abs(year, month, day);
  }
  /**
   * Returns a transliterated Hebrew month name, e.g. `'Elul'` or `'Cheshvan'`.
   * @example
   * const hd = new HDate(new Date(2008, 10, 13)); // 15 Cheshvan 5769
   * hd.getMonthName(); // 'Cheshvan'
   */
  getMonthName() {
    return getMonthName(this.getMonth(), this.getFullYear());
  }
  /**
   * Renders this Hebrew date as a translated or transliterated string,
   * including ordinal e.g. `'15th of Cheshvan, 5769'`.
   * @example
   * import {HDate, months} from '@hebcal/hdate';
   *
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * console.log(hd.render('en')); // '15th of Cheshvan, 5769'
   * console.log(hd.render('he')); // '15 חֶשְׁוָן, 5769'
   * console.log(hd.render('en', false)); // '15th of Cheshvan'
   * console.log(hd.render('he', false)); // '15 חֶשְׁוָן'
   * @param [locale] Optional locale name (defaults to active locale).
   * @param [showYear=true] Display year (defaults to true).
   * @see {@link Locale}
   */
  render(locale, showYear = true) {
    const locale0 = locale || Locale.getLocaleName();
    const day = this.getDate();
    const monthName0 = Locale.gettext(this.getMonthName(), locale0);
    const monthName = monthName0.replace(/'/g, "’");
    const nth = Locale.ordinal(day, locale0);
    const dayOf = getDayOfTranslation(locale0);
    const dateStr = `${nth}${dayOf} ${monthName}`;
    if (showYear) {
      const fullYear = this.getFullYear();
      return `${dateStr}, ${fullYear}`;
    } else {
      return dateStr;
    }
  }
  /**
   * Renders this Hebrew date in Hebrew gematriya, regardless of locale.
   * @example
   * import {HDate, months} from '@hebcal/hdate';
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * hd.renderGematriya(); // 'ט״ו חֶשְׁוָן תשס״ט'
   * hd.renderGematriya(true); // 'ט״ו חשון תשס״ט'
   */
  renderGematriya(suppressNikud = false) {
    const d2 = this.getDate();
    const locale = suppressNikud ? "he-x-NoNikud" : "he";
    const m2 = Locale.gettext(this.getMonthName(), locale);
    const y2 = this.getFullYear();
    return gematriya(d2) + " " + m2 + " " + gematriya(y2);
  }
  /**
   * Returns an `HDate` corresponding to the specified day of week
   * **before** this Hebrew date
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).before(6).greg() // Sat Feb 15 2014
   * @param dayOfWeek day of week: Sunday=0, Saturday=6
   */
  before(dayOfWeek) {
    return onOrBefore(dayOfWeek, this, -1);
  }
  /**
   * Returns an `HDate` corresponding to the specified day of week
   * **on or before** this Hebrew date
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).onOrBefore(6).greg() // Sat Feb 15 2014
   * new HDate(new Date('Saturday February 22, 2014')).onOrBefore(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Sunday February 23, 2014')).onOrBefore(6).greg() // Sat Feb 22 2014
   * @param dayOfWeek day of week: Sunday=0, Saturday=6
   */
  onOrBefore(dayOfWeek) {
    return onOrBefore(dayOfWeek, this, 0);
  }
  /**
   * Returns an `HDate` corresponding to the specified day of week
   * **nearest** to this Hebrew date
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).nearest(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Tuesday February 18, 2014')).nearest(6).greg() // Sat Feb 15 2014
   * @param dayOfWeek day of week: Sunday=0, Saturday=6
   */
  nearest(dayOfWeek) {
    return onOrBefore(dayOfWeek, this, 3);
  }
  /**
   * Returns an `HDate` corresponding to the specified day of week
   * **on or after** this Hebrew date
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).onOrAfter(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Saturday February 22, 2014')).onOrAfter(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Sunday February 23, 2014')).onOrAfter(6).greg() // Sat Mar 01 2014
   * @param dayOfWeek day of week: Sunday=0, Saturday=6
   */
  onOrAfter(dayOfWeek) {
    return onOrBefore(dayOfWeek, this, 6);
  }
  /**
   * Returns an `HDate` corresponding to the specified day of week
   * **after** this Hebrew date
   * @example
   * new HDate(new Date('Wednesday February 19, 2014')).after(6).greg() // Sat Feb 22 2014
   * new HDate(new Date('Saturday February 22, 2014')).after(6).greg() // Sat Mar 01 2014
   * new HDate(new Date('Sunday February 23, 2014')).after(6).greg() // Sat Mar 01 2014
   * @param dayOfWeek day of week: Sunday=0, Saturday=6
   */
  after(dayOfWeek) {
    return onOrBefore(dayOfWeek, this, 7);
  }
  /**
   * Returns the next Hebrew date
   * @example
   * const hd = new HDate(new Date(2008, 10, 13)); // 15 Cheshvan 5769
   * hd.next(); // '16 Cheshvan 5769'
   */
  next() {
    return new _HDate(this.abs() + 1);
  }
  /**
   * Returns the previous Hebrew date
   * @example
   * const hd = new HDate(new Date(2008, 10, 13)); // 15 Cheshvan 5769
   * hd.prev(); // '14 Cheshvan 5769'
   */
  prev() {
    return new _HDate(this.abs() - 1);
  }
  /**
   * Returns a cloned `HDate` object with a specified amount of time added
   *
   * Units are case insensitive, and support plural and short forms.
   * Note, short forms are case sensitive.
   *
   * | Unit | Shorthand | Description
   * | --- | --- | --- |
   * | `day` | `d` | days |
   * | `week` | `w` | weeks |
   * | `month` | `M` | months |
   * | `year` | `y` | years |
   */
  add(amount, units = "d") {
    amount = typeof amount === "string" ? parseInt(amount, 10) : amount;
    if (!amount) {
      return new _HDate(this);
    }
    units = standardizeUnits(units);
    if (units === UNITS_DAY) {
      return new _HDate(this.abs() + amount);
    } else if (units === UNITS_WEEK) {
      return new _HDate(this.abs() + 7 * amount);
    } else if (units === UNITS_YEAR) {
      return new _HDate(this.getDate(), this.getMonth(), this.getFullYear() + amount);
    } else {
      let hd = new _HDate(this);
      const sign = amount > 0 ? 1 : -1;
      amount = Math.abs(amount);
      for (let i2 = 0; i2 < amount; i2++) {
        hd = new _HDate(hd.abs() + sign * hd.daysInMonth());
      }
      return hd;
    }
  }
  /**
   * Returns a cloned `HDate` object with a specified amount of time subracted
   *
   * Units are case insensitive, and support plural and short forms.
   * Note, short forms are case sensitive.
   *
   * | Unit | Shorthand | Description
   * | --- | --- | --- |
   * | `day` | `d` | days |
   * | `week` | `w` | weeks |
   * | `month` | `M` | months |
   * | `year` | `y` | years |
   * @example
   * import {HDate, months} from '@hebcal/hdate';
   *
   * const hd1 = new HDate(15, months.CHESHVAN, 5769);
   * const hd2 = hd1.add(1, 'weeks'); // 7 Kislev 5769
   * const hd3 = hd1.add(-3, 'M'); // 30 Av 5768
   */
  subtract(amount, units = "d") {
    return this.add(amount * -1, units);
  }
  /**
   * Returns the difference in days between the two given HDates.
   *
   * The result is positive if `this` date is comes chronologically
   * after the `other` date, and negative
   * if the order of the two dates is reversed.
   *
   * The result is zero if the two dates are identical.
   * @example
   * import {HDate, months} from '@hebcal/hdate';
   *
   * const hd1 = new HDate(25, months.KISLEV, 5770);
   * const hd2 = new HDate(15, months.CHESHVAN, 5769);
   * const days = hd1.deltaDays(hd2); // 394
   * @param other Hebrew date to compare
   */
  deltaDays(other) {
    return this.abs() - other.abs();
  }
  /**
   * Compares this Hebrew date to another date, returning `true` if the dates match.
   * @param other Hebrew date to compare
   * @example
   * const hd1 = new HDate(new Date(2008, 10, 13));
   * const hd2 = new HDate(15, 'Cheshvan', 5769);
   * hd1.isSameDate(hd2); // true
   */
  isSameDate(other) {
    return this.yy === other.yy && this.mm === other.mm && this.dd === other.dd;
  }
  /**
   * Returns a string representation of this Hebrew date using English transliterations
   * @example
   * const hd = new HDate(new Date(2008, 10, 13)); // 15 Cheshvan 5769
   * hd.toString(); // '15 Cheshvan 5769'
   */
  toString() {
    const day = this.getDate();
    const fullYear = this.getFullYear();
    const monthName = this.getMonthName();
    return `${day} ${monthName} ${fullYear}`;
  }
  /**
   * Returns true if Hebrew year is a leap year
   * @param year Hebrew year
   * @example
   * HDate.isLeapYear(5783); // false
   * HDate.isLeapYear(5784); // true
   */
  static isLeapYear(year) {
    return isLeapYear(year);
  }
  /**
   * Number of months in this Hebrew year (either 12 or 13 depending on leap year)
   * @param year Hebrew year
   * @example
   * HDate.monthsInYear(5783); // 12
   * HDate.monthsInYear(5784); // 13
   */
  static monthsInYear(year) {
    return monthsInYear(year);
  }
  /**
   * Number of days in Hebrew month in a given year (29 or 30)
   * @param month Hebrew month (e.g. months.TISHREI)
   * @param year Hebrew year
   * @example
   * import {HDate, months} from '@hebcal/hdate';
   * HDate.daysInMonth(months.CHESHVAN, 5769); // 29
   */
  static daysInMonth(month, year) {
    return daysInMonth(month, year);
  }
  /**
   * Returns a transliterated string name of Hebrew month in year,
   * for example 'Elul' or 'Cheshvan'.
   * @param month Hebrew month (e.g. months.TISHREI)
   * @param year Hebrew year
   * @example
   * import {HDate, months} from '@hebcal/hdate';
   * HDate.getMonthName(months.CHESHVAN, 5769); // 'Cheshvan'
   */
  static getMonthName(month, year) {
    return getMonthName(month, year);
  }
  /**
   * Returns the Hebrew month number (NISAN=1, TISHREI=7)
   * @param month A number, or Hebrew month name string
   * @example
   * import {HDate, months} from '@hebcal/hdate';
   * HDate.monthNum(months.CHESHVAN); // 8
   * HDate.monthNum('Cheshvan'); // 8
   * HDate.monthNum('חשון'); // 8
   */
  static monthNum(month) {
    if (typeof month === "number") {
      if (isNaN(month) || month > 14) {
        throw new RangeError(`bad monthNum: ${month}`);
      }
      return month;
    }
    return month.charCodeAt(0) >= 48 && month.charCodeAt(0) <= 57 ? parseInt(month, 10) : monthFromName(month);
  }
  /**
   * Number of days in the Hebrew year.
   * Regular years can have 353, 354, or 355 days.
   * Leap years can have 383, 384, or 385 days.
   * @param year Hebrew year
   * @example
   * HDate.daysInYear(5783); // 355
   * HDate.daysInYear(5784); // 383
   */
  static daysInYear(year) {
    return daysInYear(year);
  }
  /**
   * true if Cheshvan is long in Hebrew year
   * @param year Hebrew year
   * @example
   * HDate.longCheshvan(5783); // true
   * HDate.longCheshvan(5784); // false
   */
  static longCheshvan(year) {
    return longCheshvan(year);
  }
  /**
   * true if Kislev is short in Hebrew year
   * @param year Hebrew year
   * @example
   * HDate.shortKislev(5783); // false
   * HDate.shortKislev(5784); // true
   */
  static shortKislev(year) {
    return shortKislev(year);
  }
  /**
   * Converts Hebrew month string name to numeric
   * @example
   * import {HDate, months} from '@hebcal/hdate';
   * HDate.monthFromName(months.CHESHVAN); // 8
   * HDate.monthFromName('Cheshvan'); // 8
   * HDate.monthFromName('חשון'); // 8
   */
  static monthFromName(monthName) {
    return monthFromName(monthName);
  }
  /**
   * Convenience function for determining the R.D. date
   * near a specified R.D. date, corresponding to the specified day of week.
   *
   * Note: Applying this function to d+6 gives us the `dayOfWeek` on or after an
   * absolute day d. Similarly, applying it to d+3 gives the `dayOfWeek` nearest to
   * absolute date d, applying it to d-1 gives the `dayOfWeek` previous to absolute
   * date d, and applying it to d+7 gives the `dayOfWeek` following absolute date d.
   * @param dayOfWeek day of week: Sunday=0, Saturday=6
   */
  static dayOnOrBefore(dayOfWeek, absdate) {
    return absdate - (absdate - dayOfWeek) % 7;
  }
  /**
   * Tests if the object is an instance of `HDate`
   * @example
   * HDate.isHDate(new HDate()); // true
   * HDate.isHDate(new Date()); // false
   * HDate.isHDate(null); // false
   * HDate.isHDate(12345); // false
   * HDate.isHDate('15 Cheshvan 5769'); // false
   */
  static isHDate(obj) {
    return obj !== null && typeof obj === "object" && typeof obj.yy === "number" && typeof obj.mm === "number" && typeof obj.dd === "number" && typeof obj.greg === "function" && typeof obj.abs === "function";
  }
  /**
   * Construct a new instance of `HDate` from a Gematriya-formatted string
   * @example
   * HDate.fromGematriyaString('כ״ז בְּתַמּוּז תשפ״ג') // 27 Tamuz 5783
   * HDate.fromGematriyaString('כ׳ סיון תש״ד') // 20 Sivan 5704
   * HDate.fromGematriyaString('ה׳ אִיָיר תש״ח') // 5 Iyyar 5708
   */
  static fromGematriyaString(str, currentThousands = 5e3) {
    const parts = str.split(" ").filter((x2) => x2.length !== 0);
    const numParts = parts.length;
    if (numParts !== 3 && numParts !== 4) {
      throw new RangeError(`cannot parse gematriya str: "${str}"`);
    }
    const day = gematriyaStrToNum(parts[0]);
    const monthStr = numParts === 3 ? parts[1] : parts[1] + " " + parts[2];
    const month = monthFromName(monthStr);
    const yearStr = numParts === 3 ? parts[2] : parts[3];
    let year = gematriyaStrToNum(yearStr);
    if (year < 1e3) {
      year += currentThousands;
    }
    return new _HDate(day, month, year);
  }
};
function standardizeUnits(units) {
  switch (units) {
    case "d":
      return UNITS_DAY;
    case "w":
      return UNITS_WEEK;
    case "M":
      return UNITS_MONTH;
    case "y":
      return UNITS_YEAR;
  }
  const str = String(units || "").toLowerCase().replace(/s$/, "");
  switch (str) {
    case UNITS_DAY:
    case UNITS_WEEK:
    case UNITS_MONTH:
    case UNITS_YEAR:
      return str;
  }
  throw new TypeError(`Invalid units '${units}'`);
}
function getDayOfTranslation(locale) {
  switch (locale) {
    case "en":
    case "s":
    case "a":
    case "ashkenazi":
      return " of";
  }
  const ofStr = Locale.lookupTranslation("of", locale);
  if (ofStr) {
    return " " + ofStr;
  }
  if (locale.startsWith("ashkenazi")) {
    return " of";
  }
  return "";
}
function setMonth(hd, month) {
  hd.mm = HDate.monthNum(month);
  fix(hd);
  return hd;
}
function setDate(hd, date) {
  hd.dd = date;
  fix(hd);
  return hd;
}
function fix(hd) {
  fixMonth(hd);
  fixDate(hd);
}
function fixDate(hd) {
  if (hd.dd < 1) {
    if (hd.mm === months.TISHREI) {
      hd.yy -= 1;
    }
    hd.dd += daysInMonth(hd.mm, hd.yy);
    hd.mm -= 1;
    fix(hd);
  }
  if (hd.dd > daysInMonth(hd.mm, hd.yy)) {
    if (hd.mm === months.ELUL) {
      hd.yy += 1;
    }
    hd.dd -= daysInMonth(hd.mm, hd.yy);
    if (hd.mm === monthsInYear(hd.yy)) {
      hd.mm = 1;
    } else {
      hd.mm += 1;
    }
    fix(hd);
  }
  fixMonth(hd);
}
function fixMonth(hd) {
  if (hd.mm === months.ADAR_II && !hd.isLeapYear()) {
    hd.mm -= 1;
    fix(hd);
  } else if (hd.mm < 1) {
    hd.mm += monthsInYear(hd.yy);
    hd.yy -= 1;
    fix(hd);
  } else if (hd.mm > monthsInYear(hd.yy)) {
    hd.mm -= monthsInYear(hd.yy);
    hd.yy += 1;
    fix(hd);
  }
  delete hd.rd;
}
function onOrBefore(day, t2, offset) {
  return new HDate(HDate.dayOnOrBefore(day, t2.abs() + offset));
}

// node_modules/@hebcal/core/dist/esm/ashkenazi.po.js
var poAshkenazi2 = { "headers": { "plural-forms": "nplurals=2; plural=(n > 1);", "language": "en_CA@ashkenazi" }, "contexts": { "": { "Shabbat": ["Shabbos"], "Achrei Mot": ["Achrei Mos"], "Bechukotai": ["Bechukosai"], "Beha'alotcha": ["Beha’aloscha"], "Bereshit": ["Bereshis"], "Chukat": ["Chukas"], "Erev Shavuot": ["Erev Shavuos"], "Erev Sukkot": ["Erev Sukkos"], "Ki Tavo": ["Ki Savo"], "Ki Teitzei": ["Ki Seitzei"], "Ki Tisa": ["Ki Sisa"], "Matot": ["Matos"], "Purim Katan": ["Purim Koton"], "Shabbat Chazon": ["Shabbos Chazon"], "Shabbat HaChodesh": ["Shabbos HaChodesh"], "Shabbat HaGadol": ["Shabbos HaGadol"], "Shabbat Nachamu": ["Shabbos Nachamu"], "Shabbat Parah": ["Shabbos Parah"], "Shabbat Shekalim": ["Shabbos Shekalim"], "Shabbat Shuva": ["Shabbos Shuvah"], "Shabbat Zachor": ["Shabbos Zachor"], "Shavuot": ["Shavuos"], "Shavuot I": ["Shavuos I"], "Shavuot II": ["Shavuos II"], "Shemot": ["Shemos"], "Shmini Atzeret": ["Shmini Atzeres"], "Simchat Torah": ["Simchas Torah"], "Sukkot": ["Sukkos"], "Sukkot I": ["Sukkos I"], "Sukkot II": ["Sukkos II"], "Sukkot II (CH''M)": ["Sukkos II (CH’’M)"], "Sukkot III (CH''M)": ["Sukkos III (CH’’M)"], "Sukkot IV (CH''M)": ["Sukkos IV (CH’’M)"], "Sukkot V (CH''M)": ["Sukkos V (CH’’M)"], "Sukkot VI (CH''M)": ["Sukkos VI (CH’’M)"], "Sukkot VII (Hoshana Raba)": ["Sukkos VII (Hoshana Raba)"], "Ta'anit Bechorot": ["Ta’anis Bechoros"], "Ta'anit Esther": ["Ta’anis Esther"], "Toldot": ["Toldos"], "Vaetchanan": ["Vaeschanan"], "Yitro": ["Yisro"], "Vezot Haberakhah": ["Vezos Haberakhah"], "Parashat": ["Parshas"], "Leil Selichot": ["Leil Selichos"], "Shabbat Mevarchim Chodesh": ["Shabbos Mevorchim Chodesh"], "Shabbat Shirah": ["Shabbos Shirah"], "Asara B'Tevet": ["Asara B’Teves"], "Alot HaShachar": ["Alos HaShachar"], "Kriat Shema, sof zeman": ["Krias Shema, sof zman"], "Tefilah, sof zeman": ["Tefilah, sof zman"], "Kriat Shema, sof zeman (MGA)": ["Krias Shema, sof zman (MGA)"], "Tefilah, sof zeman (MGA)": ["Tefilah, sof zman (MGA)"], "Chatzot HaLailah": ["Chatzos HaLailah"], "Chatzot hayom": ["Chatzos"], "Tzeit HaKochavim": ["Tzeis HaKochavim"], "Birkat Hachamah": ["Birkas Hachamah"], "Shushan Purim Katan": ["Shushan Purim Koton"] } } };

// node_modules/@hebcal/core/dist/esm/he.po.js
var poHe2 = { "headers": { "plural-forms": "nplurals=2; plural=(n > 1);", "language": "he_IL" }, "contexts": { "": { "Shabbat": ["שַׁבָּת"], "Parashat": ["פָּרָשַׁת"], "Achrei Mot": ["אַחֲרֵי מוֹת"], "Balak": ["בָּלָק"], "Bamidbar": ["בְּמִדְבַּר"], "Bechukotai": ["בְּחֻקֹּתַי"], "Beha'alotcha": ["בְּהַעֲלֹתְךָ"], "Behar": ["בְּהַר"], "Bereshit": ["בְּרֵאשִׁית"], "Beshalach": ["בְּשַׁלַּח"], "Bo": ["בֹּא"], "Chayei Sara": ["חַיֵּי שָֹרָה"], "Chukat": ["חֻקַּת"], "Devarim": ["דְּבָרִים"], "Eikev": ["עֵקֶב"], "Emor": ["אֱמוֹר"], "Ha'azinu": ["הַאֲזִינוּ"], "Kedoshim": ["קְדשִׁים"], "Ki Tavo": ["כִּי־תָבוֹא"], "Ki Teitzei": ["כִּי־תֵצֵא"], "Ki Tisa": ["כִּי תִשָּׂא"], "Korach": ["קֹרַח"], "Lech-Lecha": ["לֶךְ־לְךָ"], "Masei": ["מַסְעֵי"], "Matot": ["מַטּוֹת"], "Metzora": ["מְצֹרָע"], "Miketz": ["מִקֵּץ"], "Mishpatim": ["מִשְׁפָּטִים"], "Nasso": ["נָשׂא"], "Nitzavim": ["נִצָּבִים"], "Noach": ["נֹחַ"], "Pekudei": ["פְקוּדֵי"], "Pinchas": ["פִּינְחָס"], "Re'eh": ["רְאֵה"], "Sh'lach": ["שְׁלַח־לְךָ"], "Shemot": ["שְׁמוֹת"], "Shmini": ["שְּׁמִינִי"], "Shoftim": ["שׁוֹפְטִים"], "Tazria": ["תַזְרִיעַ"], "Terumah": ["תְּרוּמָה"], "Tetzaveh": ["תְּצַוֶּה"], "Toldot": ["תּוֹלְדוֹת"], "Tzav": ["צַו"], "Vaera": ["וָאֵרָא"], "Vaetchanan": ["וָאֶתְחַנַּן"], "Vayakhel": ["וַיַּקְהֵל"], "Vayechi": ["וַיְחִי"], "Vayeilech": ["וַיֵּלֶךְ"], "Vayera": ["וַיֵּרָא"], "Vayeshev": ["וַיֵּשֶׁב"], "Vayetzei": ["וַיֵּצֵא"], "Vayigash": ["וַיִּגַּשׁ"], "Vayikra": ["וַיִּקְרָא"], "Vayishlach": ["וַיִּשְׁלַח"], "Vezot Haberakhah": ["וְזֹאת הַבְּרָכָה"], "Yitro": ["יִתְרוֹ"], "Asara B'Tevet": ["עֲשָׂרָה בְּטֵבֵת"], "Candle lighting": ["הַדְלָקַת נֵרוֹת"], "Chanukah": ["חֲנוּכָּה"], "Chanukah: 1 Candle": ["חֲנוּכָּה: א׳ נֵר"], "Chanukah: 2 Candles": ["חֲנוּכָּה: ב׳ נֵרוֹת"], "Chanukah: 3 Candles": ["חֲנוּכָּה: ג׳ נֵרוֹת"], "Chanukah: 4 Candles": ["חֲנוּכָּה: ד׳ נֵרוֹת"], "Chanukah: 5 Candles": ["חֲנוּכָּה: ה׳ נֵרוֹת"], "Chanukah: 6 Candles": ["חֲנוּכָּה: ו׳ נֵרוֹת"], "Chanukah: 7 Candles": ["חֲנוּכָּה: ז׳ נֵרוֹת"], "Chanukah: 8 Candles": ["חֲנוּכָּה: ח׳ נֵרוֹת"], "Chanukah: 8th Day": ["חֲנוּכָּה: יוֹם ח׳"], "Days of the Omer": ["סְפִירַת הָעוֹמֶר"], "Omer": ["עוֹמֶר"], "day of the Omer": ["בָּעוֹמֶר"], "Erev Pesach": ["עֶרֶב פֶּסַח"], "Erev Purim": ["עֶרֶב פּוּרִים"], "Erev Rosh Hashana": ["עֶרֶב רֹאשׁ הַשָּׁנָה"], "Erev Shavuot": ["עֶרֶב שָׁבוּעוֹת"], "Erev Simchat Torah": ["עֶרֶב שִׂמְחַת תּוֹרָה"], "Erev Sukkot": ["עֶרֶב סוּכּוֹת"], "Erev Tish'a B'Av": ["עֶרֶב תִּשְׁעָה בְּאָב"], "Erev Yom Kippur": ["עֶרֶב יוֹם כִּפּוּר"], "Havdalah": ["הַבְדָּלָה"], "Lag BaOmer": ["ל״ג בָּעוֹמֶר"], "Leil Selichot": ["סְלִיחוֹת"], "Pesach": ["פֶּסַח"], "Pesach I": ["פֶּסַח א׳"], "Pesach II": ["פֶּסַח ב׳"], "Pesach II (CH''M)": ["פֶּסַח ב׳ (חוה״מ)"], "Pesach III (CH''M)": ["פֶּסַח ג׳ (חוה״מ)"], "Pesach IV (CH''M)": ["פֶּסַח ד׳ (חוה״מ)"], "Pesach Sheni": ["פֶּסַח שֵׁנִי"], "Pesach V (CH''M)": ["פֶּסַח ה׳ (חוה״מ)"], "Pesach VI (CH''M)": ["פֶּסַח ו׳ (חוה״מ)"], "Pesach VII": ["פֶּסַח ז׳"], "Pesach VIII": ["פֶּסַח ח׳"], "Purim": ["פּוּרִים"], "Purim Katan": ["פּוּרִים קָטָן"], "Rosh Chodesh %s": ["רֹאשׁ חוֹדֶשׁ %s"], "Rosh Chodesh": ["רֹאשׁ חוֹדֶשׁ"], "Rosh Hashana": ["רֹאשׁ הַשָּׁנָה"], "Rosh Hashana I": ["רֹאשׁ הַשָּׁנָה א׳"], "Rosh Hashana II": ["רֹאשׁ הַשָּׁנָה ב׳"], "Shabbat Chazon": ["שַׁבַּת חֲזוֹן"], "Shabbat HaChodesh": ["שַׁבַּת הַחֹדֶשׁ"], "Shabbat HaGadol": ["שַׁבַּת הַגָּדוֹל"], "Shabbat Nachamu": ["שַׁבַּת נַחֲמוּ"], "Shabbat Parah": ["שַׁבַּת פָּרָה"], "Shabbat Shekalim": ["שַׁבַּת שְׁקָלִים"], "Shabbat Shuva": ["שַׁבַּת שׁוּבָה"], "Shabbat Zachor": ["שַׁבַּת זָכוֹר"], "Shavuot": ["שָׁבוּעוֹת"], "Shavuot I": ["שָׁבוּעוֹת א׳"], "Shavuot II": ["שָׁבוּעוֹת ב׳"], "Shmini Atzeret": ["שְׁמִינִי עֲצֶרֶת"], "Shushan Purim": ["שׁוּשָׁן פּוּרִים"], "Sigd": ["חַג הַסִּיגְד"], "Simchat Torah": ["שִׂמְחַת תּוֹרָה"], "Sukkot": ["סוּכּוֹת"], "Sukkot I": ["סוּכּוֹת א׳"], "Sukkot II": ["סוּכּוֹת ב׳"], "Sukkot II (CH''M)": ["סוּכּוֹת ב׳ (חוה״מ)"], "Sukkot III (CH''M)": ["סוּכּוֹת ג׳ (חוה״מ)"], "Sukkot IV (CH''M)": ["סוּכּוֹת ד׳ (חוה״מ)"], "Sukkot V (CH''M)": ["סוּכּוֹת ה׳ (חוה״מ)"], "Sukkot VI (CH''M)": ["סוּכּוֹת ו׳ (חוה״מ)"], "Sukkot VII (Hoshana Raba)": ["סוּכּוֹת ז׳ (הוֹשַׁעְנָא רַבָּה)"], "Ta'anit Bechorot": ["תַּעֲנִית בְּכוֹרוֹת"], "Ta'anit Esther": ["תַּעֲנִית אֶסְתֵּר"], "Tish'a B'Av": ["תִּשְׁעָה בְּאָב"], "Tu B'Av": ["ט״וּ בְּאָב"], "Tu BiShvat": ["ט״וּ בִּשְׁבָט"], "Tu B'Shvat": ["ט״וּ בִּשְׁבָט"], "Tzom Gedaliah": ["צוֹם גְּדַלְיָה"], "Tzom Tammuz": ["צוֹם י״ז בְּתַמּוּז"], "Yom HaAtzma'ut": ["יוֹם הָעַצְמָאוּת"], "Yom HaShoah": ["יוֹם הַשּׁוֹאָה"], "Yom HaZikaron": ["יוֹם הַזִּכָּרוֹן"], "Yom Kippur": ["יוֹם כִּפּוּר"], "Yom Yerushalayim": ["יוֹם יְרוּשָׁלַיִם"], "Yom HaAliyah": ["יוֹם הַעֲלִיָּה"], "Yom HaAliyah School Observance": ["שְׁמִירָת בֵּית הַסֵפֶר לְיוֹם הַעֲלִיָּה"], "Rosh Chodesh Adar": ["רֹאשׁ חוֹדֶשׁ אֲדָר"], "Rosh Chodesh Adar I": ["רֹאשׁ חוֹדֶשׁ אֲדָר א׳"], "Rosh Chodesh Adar II": ["רֹאשׁ חוֹדֶשׁ אֲדָר ב׳"], "Rosh Chodesh Av": ["רֹאשׁ חוֹדֶשׁ אָב"], "Rosh Chodesh Cheshvan": ["רֹאשׁ חוֹדֶשׁ חֶשְׁוָן"], "Rosh Chodesh Elul": ["רֹאשׁ חוֹדֶשׁ אֱלוּל"], "Rosh Chodesh Iyyar": ["רֹאשׁ חוֹדֶשׁ אִיָּיר"], "Rosh Chodesh Kislev": ["רֹאשׁ חוֹדֶשׁ כִּסְלֵו"], "Rosh Chodesh Nisan": ["רֹאשׁ חוֹדֶשׁ נִיסָן"], "Rosh Chodesh Sh'vat": ["רֹאשׁ חוֹדֶשׁ שְׁבָט"], "Rosh Chodesh Sivan": ["רֹאשׁ חוֹדֶשׁ סִיוָן"], "Rosh Chodesh Tamuz": ["רֹאשׁ חוֹדֶשׁ תַּמּוּז"], "Rosh Chodesh Tevet": ["רֹאשׁ חוֹדֶשׁ טֵבֵת"], "min": ["דַּקּוֹת"], "Fast begins": ["תְּחִילַּת הַצוֹם"], "Fast ends": ["סִיּוּם הַצוֹם"], "Rosh Hashana LaBehemot": ["רֹאשׁ הַשָּׁנָה לְמַעְשַׂר בְּהֵמָה"], "Tish'a B'Av (observed)": ["(תִּשְׁעָה בְּאָב (נִדְחָה"], "Shabbat Mevarchim Chodesh": ["שַׁבַּת מְבָרְכִים חוֹדֶשׁ"], "Shabbat Shirah": ["שַׁבַּת שִׁירָה"], "Lovingkindness": ["חֶסֶד"], "Might": ["גְּבוּרָה"], "Beauty": ["תִּפְאֶרֶת"], "Eternity": ["נֶּצַח"], "Splendor": ["הוֹד"], "Foundation": ["יְּסוֹד"], "Majesty": ["מַּלְכוּת"], "day": ["יוֹם"], "Yom Kippur Katan": ["יוֹם כִּפּוּר קָטָן"], "Yizkor": ["יִזְכּוֹר"], "Family Day": ["יוֹם הַמִּשׁפָּחָה"], "Yitzhak Rabin Memorial Day": ["יוֹם הַזִּכָּרוֹן לְיִצְחָק רַבִּין"], "Jabotinsky Day": ["יוֹם זַ׳בּוֹטִינְסְקִי"], "Herzl Day": ["יוֹם הֵרְצְל"], "Ben-Gurion Day": ["יוֹם בן־גוריון"], "Hebrew Language Day": ["יוֹם הַשָׂפָה הַעִברִית"], "Birkat Hachamah": ["בִּרְכַּת הַחַמָּה"], "Shushan Purim Katan": ["שׁוּשָׁן פּוּרִים קָטָן"], "Purim Meshulash": ["פּוּרִים מְשׁוּלָּשׁ"], "Chag HaBanot": ["חַג הַבָּנוֹת"], "Molad": ["מוֹלָד הָלְּבָנָה"], "chalakim": ["חֲלָקִים"] } } };

// node_modules/@hebcal/core/dist/esm/he-x-NoNikud.po.js
var noNikudOverride = { "headers": { "plural-forms": "nplurals=2; plural=(n != 1);", "language": "he-x-NoNikud" }, "contexts": { "": { "Korach": ["קורח"], "Chukat": ["חוקת"] } } };

// node_modules/@hebcal/core/dist/esm/locale.js
Locale.addTranslations("he", poHe2);
Locale.addTranslations("h", poHe2);
Locale.addTranslations("ashkenazi", poAshkenazi2);
Locale.addTranslations("a", poAshkenazi2);
var heStrs2 = poHe2.contexts[""];
var heNoNikud2 = {};
for (const [key, val] of Object.entries(heStrs2)) {
  heNoNikud2[key] = [Locale.hebrewStripNikkud(val[0])];
}
var poHeNoNikud2 = {
  headers: poHe2.headers,
  contexts: { "": heNoNikud2 }
};
Locale.addTranslations("he-x-NoNikud", poHeNoNikud2);
Locale.addTranslations("he-x-NoNikud", noNikudOverride);

// node_modules/@hebcal/core/dist/esm/event.js
var flags = {
  /** Chag, yontiff, yom tov */
  CHAG: 1,
  /** Light candles 18 minutes before sundown */
  LIGHT_CANDLES: 2,
  /** End of holiday (end of Yom Tov)  */
  YOM_TOV_ENDS: 4,
  /** Observed only in the Diaspora (chutz l'aretz)  */
  CHUL_ONLY: 8,
  /** Observed only in Israel */
  IL_ONLY: 16,
  /** Light candles in the evening at Tzeit time (3 small stars) */
  LIGHT_CANDLES_TZEIS: 32,
  /** Candle-lighting for Chanukah */
  CHANUKAH_CANDLES: 64,
  /** Rosh Chodesh, beginning of a new Hebrew month */
  ROSH_CHODESH: 128,
  /** Minor fasts like Tzom Tammuz, Ta'anit Esther, ... */
  MINOR_FAST: 256,
  /** Shabbat Shekalim, Zachor, ... */
  SPECIAL_SHABBAT: 512,
  /** Weekly sedrot on Saturdays */
  PARSHA_HASHAVUA: 1024,
  /** Daily page of Talmud (Bavli) */
  DAF_YOMI: 2048,
  /** Days of the Omer */
  OMER_COUNT: 4096,
  /** Yom HaShoah, Yom HaAtzma'ut, ... */
  MODERN_HOLIDAY: 8192,
  /** Yom Kippur and Tish'a B'Av */
  MAJOR_FAST: 16384,
  /** On the Saturday before Rosh Chodesh */
  SHABBAT_MEVARCHIM: 32768,
  /** Molad */
  MOLAD: 65536,
  /** Yahrzeit or Hebrew Anniversary */
  USER_EVENT: 131072,
  /** Daily Hebrew date ("11th of Sivan, 5780") */
  HEBREW_DATE: 262144,
  /** A holiday that's not major, modern, rosh chodesh, or a fast day */
  MINOR_HOLIDAY: 524288,
  /** Evening before a major or minor holiday */
  EREV: 1048576,
  /** Chol haMoed, intermediate days of Pesach or Sukkot */
  CHOL_HAMOED: 2097152,
  /** Mishna Yomi */
  MISHNA_YOMI: 4194304,
  /** Yom Kippur Katan, minor day of atonement on the day preceeding each Rosh Chodesh */
  YOM_KIPPUR_KATAN: 8388608,
  /** Daily page of Jerusalem Talmud (Yerushalmi) */
  YERUSHALMI_YOMI: 16777216,
  /** Nach Yomi */
  NACH_YOMI: 33554432,
  /** Daily Learning */
  DAILY_LEARNING: 67108864,
  /** Yizkor */
  YIZKOR: 134217728
};
var flagToCategory = [
  [flags.MAJOR_FAST, "holiday", "major", "fast"],
  [flags.CHANUKAH_CANDLES, "holiday", "major"],
  [flags.HEBREW_DATE, "hebdate"],
  [flags.MINOR_FAST, "holiday", "fast"],
  [flags.MINOR_HOLIDAY, "holiday", "minor"],
  [flags.MODERN_HOLIDAY, "holiday", "modern"],
  [flags.MOLAD, "molad"],
  [flags.OMER_COUNT, "omer"],
  [flags.PARSHA_HASHAVUA, "parashat"],
  // backwards-compat
  [flags.ROSH_CHODESH, "roshchodesh"],
  [flags.SHABBAT_MEVARCHIM, "mevarchim"],
  [flags.SPECIAL_SHABBAT, "holiday", "shabbat"],
  [flags.USER_EVENT, "user"],
  [flags.YIZKOR, "yizkor"]
];
var Event = class _Event {
  /**
   * Constructs Event
   * @param date Hebrew date event occurs
   * @param desc Description (not translated)
   * @param [mask=0] optional bitmask of holiday flags (see {@link flags})
   * @param [attrs={}] optional additional attributes (e.g. `eventTimeStr`, `cholHaMoedDay`)
   */
  constructor(date, desc, mask = 0, attrs) {
    if (!HDate.isHDate(date)) {
      throw new TypeError(`Invalid Event date: ${date}`);
    } else if (typeof desc !== "string") {
      throw new TypeError(`Invalid Event description: ${desc}`);
    }
    this.date = date;
    this.desc = desc;
    this.mask = +mask;
    if (typeof attrs === "object" && attrs !== null) {
      Object.assign(this, attrs);
    }
  }
  /**
   * Hebrew date of this event
   */
  getDate() {
    return this.date;
  }
  /**
   * Untranslated title of this event. Note that these description
   * strings are always in English and will remain stable across releases.
   * To get the title of the event in another language, use the
   * `render()` method.
   */
  getDesc() {
    return this.desc;
  }
  /**
   * Bitmask of optional event flags. See {@link flags}
   */
  getFlags() {
    return this.mask;
  }
  /**
   * Returns (translated) description of this event
   * @example
   * const ev = new Event(new HDate(6, 'Sivan', 5749), 'Shavuot', flags.CHAG);
   * ev.render('en'); // 'Shavuot'
   * ev.render('he'); // 'שָׁבוּעוֹת'
   * ev.render('ashkenazi'); // 'Shavuos'
   * @param [locale] Optional locale name (defaults to active locale).
   */
  render(locale) {
    return Locale.gettext(this.desc, locale);
  }
  /**
   * Returns a brief (translated) description of this event.
   * For most events, this is the same as render(). For some events, it procudes
   * a shorter text (e.g. without a time or added description).
   * @param [locale] Optional locale name (defaults to active locale).
   */
  renderBrief(locale) {
    return this.render(locale);
  }
  /**
   * Optional holiday-specific Emoji or `null`.
   */
  getEmoji() {
    return this.emoji || null;
  }
  /**
   * Returns a simplified (untranslated) description for this event. For example,
   * the `HolidayEvent` class supports
   * "Erev Pesach" => "Pesach", and "Sukkot III (CH''M)" => "Sukkot".
   * For many holidays the basename and the event description are the same.
   */
  basename() {
    return this.getDesc();
  }
  /**
   * Returns a URL to hebcal.com or sefaria.org for more detail on the event.
   * Returns `undefined` for events with no detail page.
   */
  url() {
    return void 0;
  }
  /**
   * Is this event observed in Israel?
   * @example
   * const ev1 = new Event(new HDate(7, 'Sivan', 5749), 'Shavuot II', flags.CHAG | flags.CHUL_ONLY);
   * ev1.observedInIsrael(); // false
   * const ev2 = new Event(new HDate(26, 'Kislev', 5749), 'Chanukah: 3 Candles', 0);
   * ev2.observedInIsrael(); // true
   */
  observedInIsrael() {
    return !(this.mask & flags.CHUL_ONLY);
  }
  /**
   * Is this event observed in the Diaspora?
   * @example
   * const ev1 = new Event(new HDate(7, 'Sivan', 5749), 'Shavuot II', flags.CHAG | flags.CHUL_ONLY);
   * ev1.observedInDiaspora(); // true
   * const ev2 = new Event(new HDate(26, 'Kislev', 5749), 'Chanukah: 3 Candles', 0);
   * ev2.observedInDiaspora(); // true
   */
  observedInDiaspora() {
    return !(this.mask & flags.IL_ONLY);
  }
  /**
   * Is this event observed in Israel/Diaspora?
   * @example
   * const ev1 = new Event(new HDate(7, 'Sivan', 5749), 'Shavuot II', flags.CHAG | flags.CHUL_ONLY);
   * ev1.observedIn(false); // true
   * ev1.observedIn(true); // false
   * const ev2 = new Event(new HDate(26, 'Kislev', 5749), 'Chanukah: 3 Candles', 0);
   * ev2.observedIn(false); // true
   * ev2.observedIn(true); // true
   * @param il
   */
  observedIn(il) {
    return il ? this.observedInIsrael() : this.observedInDiaspora();
  }
  /**
   * Makes a clone of this Event object
   * @deprecated
   */
  clone() {
    const ev = new _Event(this.date, this.desc, this.mask);
    Object.assign(ev, this);
    return ev;
  }
  /**
   * Returns a list of event categories
   */
  getCategories() {
    const mask = this.getFlags();
    for (const attrs of flagToCategory) {
      const attr0 = attrs[0];
      if (mask & attr0) {
        return attrs.slice(1);
      }
    }
    return ["unknown"];
  }
};

// node_modules/@hebcal/core/dist/esm/HebrewDateEvent.js
var HebrewDateEvent = class extends Event {
  /**
   * @param date
   */
  constructor(date) {
    super(date, date.toString(), flags.HEBREW_DATE);
  }
  /**
   * @param [locale] Optional locale name (defaults to active locale).
   * @example
   * import {HDate, HebrewDateEvent, months} from '@hebcal/core';
   *
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * const ev = new HebrewDateEvent(hd);
   * console.log(ev.render('en')); // '15th of Cheshvan, 5769'
   * console.log(ev.render('he')); // 'ט״ו חֶשְׁוָן תשס״ט'
   */
  render(locale) {
    const locale1 = locale === null || locale === void 0 ? void 0 : locale.toLowerCase();
    const locale0 = locale1 !== null && locale1 !== void 0 ? locale1 : Locale.getLocaleName();
    const hd = this.getDate();
    switch (locale0) {
      case "h":
      case "he":
        return hd.renderGematriya(false);
      case "he-x-nonikud":
        return hd.renderGematriya(true);
      default:
        return hd.render(locale0, true);
    }
  }
  /**
   * @private
   * @param locale
   */
  renderBriefHebrew(locale) {
    const hd = this.getDate();
    const dd = hd.getDate();
    const mm = Locale.gettext(hd.getMonthName(), locale);
    return gematriya(dd) + " " + mm;
  }
  /**
   * @param [locale] Optional locale name (defaults to active locale).
   * @example
   * import {HDate, HebrewDateEvent, months} from '@hebcal/core';
   *
   * const hd = new HDate(15, months.CHESHVAN, 5769);
   * const ev = new HebrewDateEvent(hd);
   * console.log(ev.renderBrief()); // '15th of Cheshvan'
   * console.log(ev.renderBrief('he')); // 'ט״ו חֶשְׁוָן'
   */
  renderBrief(locale) {
    const locale1 = locale === null || locale === void 0 ? void 0 : locale.toLowerCase();
    const locale0 = locale1 !== null && locale1 !== void 0 ? locale1 : Locale.getLocaleName();
    const hd = this.getDate();
    if (hd.getMonth() === months.TISHREI && hd.getDate() === 1) {
      return this.render(locale0);
    }
    switch (locale0) {
      case "h":
      case "he":
      case "he-x-nonikud":
        return this.renderBriefHebrew(locale0);
      default:
        return hd.render(locale0, false);
    }
  }
};

// node_modules/temporal-polyfill/chunks/internal.js
function clampProp(e2, n2, t2, o2, r2) {
  return clampEntity(n2, ((e3, n3) => {
    const t3 = e3[n3];
    if (void 0 === t3) {
      throw new TypeError(missingField(n3));
    }
    return t3;
  })(e2, n2), t2, o2, r2);
}
function clampEntity(e2, n2, t2, o2, r2, i2) {
  const a2 = clampNumber(n2, t2, o2);
  if (r2 && n2 !== a2) {
    throw new RangeError(numberOutOfRange(e2, n2, t2, o2, i2));
  }
  return a2;
}
function s(e2) {
  return null !== e2 && /object|function/.test(typeof e2);
}
function on(e2, n2 = Map) {
  const t2 = new n2();
  return (n3, ...o2) => {
    if (t2.has(n3)) {
      return t2.get(n3);
    }
    const r2 = e2(n3, ...o2);
    return t2.set(n3, r2), r2;
  };
}
function r(e2) {
  return n({
    name: e2
  }, 1);
}
function n(n2, t2) {
  return e((e2) => ({
    value: e2,
    configurable: 1,
    writable: !t2
  }), n2);
}
function t(n2) {
  return e((e2) => ({
    get: e2,
    configurable: 1
  }), n2);
}
function o(e2) {
  return {
    [Symbol.toStringTag]: {
      value: e2,
      configurable: 1
    }
  };
}
function zipProps(e2, n2) {
  const t2 = {};
  let o2 = e2.length;
  for (const r2 of n2) {
    t2[e2[--o2]] = r2;
  }
  return t2;
}
function e(e2, n2, t2) {
  const o2 = {};
  for (const r2 in n2) {
    o2[r2] = e2(n2[r2], r2, t2);
  }
  return o2;
}
function g(e2, n2, t2) {
  const o2 = {};
  for (let r2 = 0; r2 < n2.length; r2++) {
    const i2 = n2[r2];
    o2[i2] = e2(i2, r2, t2);
  }
  return o2;
}
function remapProps(e2, n2, t2) {
  const o2 = {};
  for (let r2 = 0; r2 < e2.length; r2++) {
    o2[n2[r2]] = t2[e2[r2]];
  }
  return o2;
}
function nn(e2, n2) {
  const t2 = /* @__PURE__ */ Object.create(null);
  for (const o2 of e2) {
    t2[o2] = n2[o2];
  }
  return t2;
}
function hasAnyPropsByName(e2, n2) {
  for (const t2 of n2) {
    if (t2 in e2) {
      return 1;
    }
  }
  return 0;
}
function allPropsEqual(e2, n2, t2) {
  for (const o2 of e2) {
    if (n2[o2] !== t2[o2]) {
      return 0;
    }
  }
  return 1;
}
function zeroOutProps(e2, n2, t2) {
  const o2 = {
    ...t2
  };
  for (let t3 = 0; t3 < n2; t3++) {
    o2[e2[t3]] = 0;
  }
  return o2;
}
function Pt(e2, ...n2) {
  return (...t2) => e2(...n2, ...t2);
}
function capitalize(e2) {
  return e2[0].toUpperCase() + e2.substring(1);
}
function sortStrings(e2) {
  return e2.slice().sort();
}
function padNumber(e2, n2) {
  return String(n2).padStart(e2, "0");
}
function compareNumbers(e2, n2) {
  return Math.sign(e2 - n2);
}
function clampNumber(e2, n2, t2) {
  return Math.min(Math.max(e2, n2), t2);
}
function divModFloor(e2, n2) {
  return [Math.floor(e2 / n2), modFloor(e2, n2)];
}
function modFloor(e2, n2) {
  return (e2 % n2 + n2) % n2;
}
function divModTrunc(e2, n2) {
  return [divTrunc(e2, n2), modTrunc(e2, n2)];
}
function divTrunc(e2, n2) {
  return Math.trunc(e2 / n2) || 0;
}
function modTrunc(e2, n2) {
  return e2 % n2 || 0;
}
function hasHalf(e2) {
  return 0.5 === Math.abs(e2 % 1);
}
function givenFieldsToBigNano(e2, n2, t2) {
  let o2 = 0, r2 = 0;
  for (let i3 = 0; i3 <= n2; i3++) {
    const n3 = e2[t2[i3]], a3 = Ao[i3], s2 = Uo / a3, [c2, u2] = divModTrunc(n3, s2);
    o2 += u2 * a3, r2 += c2;
  }
  const [i2, a2] = divModTrunc(o2, Uo);
  return [r2 + i2, a2];
}
function nanoToGivenFields(e2, n2, t2) {
  const o2 = {};
  for (let r2 = n2; r2 >= 0; r2--) {
    const n3 = Ao[r2];
    o2[t2[r2]] = divTrunc(e2, n3), e2 = modTrunc(e2, n3);
  }
  return o2;
}
function d(e2) {
  if (void 0 !== e2) {
    return m(e2);
  }
}
function P(e2) {
  if (void 0 !== e2) {
    return h(e2);
  }
}
function S(e2) {
  if (void 0 !== e2) {
    return T(e2);
  }
}
function h(e2) {
  return requireNumberIsPositive(T(e2));
}
function T(e2) {
  return ze(cr(e2));
}
function requirePropDefined(e2, n2) {
  if (null == n2) {
    throw new RangeError(missingField(e2));
  }
  return n2;
}
function requireObjectLike(e2) {
  if (!s(e2)) {
    throw new TypeError(oo);
  }
  return e2;
}
function requireType(e2, n2, t2 = e2) {
  if (typeof n2 !== e2) {
    throw new TypeError(invalidEntity(t2, n2));
  }
  return n2;
}
function ze(e2, n2 = "number") {
  if (!Number.isInteger(e2)) {
    throw new RangeError(expectedInteger(n2, e2));
  }
  return e2 || 0;
}
function requireNumberIsPositive(e2, n2 = "number") {
  if (e2 <= 0) {
    throw new RangeError(expectedPositive(n2, e2));
  }
  return e2;
}
function toString(e2) {
  if ("symbol" == typeof e2) {
    throw new TypeError(no);
  }
  return String(e2);
}
function toStringViaPrimitive(e2, n2) {
  return s(e2) ? String(e2) : m(e2, n2);
}
function toBigInt(e2) {
  if ("string" == typeof e2) {
    return BigInt(e2);
  }
  if ("bigint" != typeof e2) {
    throw new TypeError(invalidBigInt(e2));
  }
  return e2;
}
function toNumber(e2, n2 = "number") {
  if ("bigint" == typeof e2) {
    throw new TypeError(forbiddenBigIntToNumber(n2));
  }
  if (e2 = Number(e2), !Number.isFinite(e2)) {
    throw new RangeError(expectedFinite(n2, e2));
  }
  return e2;
}
function toInteger(e2, n2) {
  return Math.trunc(toNumber(e2, n2)) || 0;
}
function toStrictInteger(e2, n2) {
  return ze(toNumber(e2, n2), n2);
}
function toPositiveInteger(e2, n2) {
  return requireNumberIsPositive(toInteger(e2, n2), n2);
}
function createBigNano(e2, n2) {
  let [t2, o2] = divModTrunc(n2, Uo), r2 = e2 + t2;
  const i2 = Math.sign(r2);
  return i2 && i2 === -Math.sign(o2) && (r2 -= i2, o2 += i2 * Uo), [r2, o2];
}
function addBigNanos(e2, n2, t2 = 1) {
  return createBigNano(e2[0] + n2[0] * t2, e2[1] + n2[1] * t2);
}
function moveBigNano(e2, n2) {
  return createBigNano(e2[0], e2[1] + n2);
}
function diffBigNanos(e2, n2) {
  return addBigNanos(n2, e2, -1);
}
function compareBigNanos(e2, n2) {
  return compareNumbers(e2[0], n2[0]) || compareNumbers(e2[1], n2[1]);
}
function bigNanoOutside(e2, n2, t2) {
  return -1 === compareBigNanos(e2, n2) || 1 === compareBigNanos(e2, t2);
}
function bigIntToBigNano(e2, n2 = 1) {
  const t2 = BigInt(Uo / n2);
  return [Number(e2 / t2), Number(e2 % t2) * n2];
}
function Ge(e2, n2 = 1) {
  const t2 = Uo / n2, [o2, r2] = divModTrunc(e2, t2);
  return [o2, r2 * n2];
}
function bigNanoToNumber(e2, n2 = 1, t2) {
  const [o2, r2] = e2, [i2, a2] = divModTrunc(r2, n2);
  return o2 * (Uo / n2) + (i2 + (t2 ? a2 / n2 : 0));
}
function divModBigNano(e2, n2, t2 = divModFloor) {
  const [o2, r2] = e2, [i2, a2] = t2(r2, n2);
  return [o2 * (Uo / n2) + i2, a2];
}
function checkIsoYearMonthInBounds(e2) {
  return clampProp(e2, "isoYear", wr, Fr, 1), e2.isoYear === wr ? clampProp(e2, "isoMonth", 4, 12, 1) : e2.isoYear === Fr && clampProp(e2, "isoMonth", 1, 9, 1), e2;
}
function checkIsoDateInBounds(e2) {
  return checkIsoDateTimeInBounds({
    ...e2,
    ...Nt,
    isoHour: 12
  }), e2;
}
function checkIsoDateTimeInBounds(e2) {
  const n2 = clampProp(e2, "isoYear", wr, Fr, 1), t2 = n2 === wr ? 1 : n2 === Fr ? -1 : 0;
  return t2 && checkEpochNanoInBounds(isoToEpochNano({
    ...e2,
    isoDay: e2.isoDay + t2,
    isoNanosecond: e2.isoNanosecond - t2
  })), e2;
}
function checkEpochNanoInBounds(e2) {
  if (!e2 || bigNanoOutside(e2, Sr, Er)) {
    throw new RangeError(Io);
  }
  return e2;
}
function isoTimeFieldsToNano(e2) {
  return givenFieldsToBigNano(e2, 5, w)[1];
}
function nanoToIsoTimeAndDay(e2) {
  const [n2, t2] = divModFloor(e2, Uo);
  return [nanoToGivenFields(t2, 5, w), n2];
}
function epochNanoToSecMod(e2) {
  return divModBigNano(e2, Ro);
}
function isoToEpochMilli(e2) {
  return isoArgsToEpochMilli(e2.isoYear, e2.isoMonth, e2.isoDay, e2.isoHour, e2.isoMinute, e2.isoSecond, e2.isoMillisecond);
}
function isoToEpochNano(e2) {
  const n2 = isoToEpochMilli(e2);
  if (void 0 !== n2) {
    const [t2, o2] = divModTrunc(n2, ko);
    return [t2, o2 * Qe + (e2.isoMicrosecond || 0) * Yo + (e2.isoNanosecond || 0)];
  }
}
function isoToEpochNanoWithOffset(e2, n2) {
  const [t2, o2] = nanoToIsoTimeAndDay(isoTimeFieldsToNano(e2) - n2);
  return checkEpochNanoInBounds(isoToEpochNano({
    ...e2,
    isoDay: e2.isoDay + o2,
    ...t2
  }));
}
function isoArgsToEpochSec(...e2) {
  return isoArgsToEpochMilli(...e2) / Co;
}
function isoArgsToEpochMilli(...e2) {
  const [n2, t2] = isoToLegacyDate(...e2), o2 = n2.valueOf();
  if (!isNaN(o2)) {
    return o2 - t2 * ko;
  }
}
function isoToLegacyDate(e2, n2 = 1, t2 = 1, o2 = 0, r2 = 0, i2 = 0, a2 = 0) {
  const s2 = e2 === wr ? 1 : e2 === Fr ? -1 : 0, c2 = /* @__PURE__ */ new Date();
  return c2.setUTCHours(o2, r2, i2, a2), c2.setUTCFullYear(e2, n2 - 1, t2 + s2), [c2, s2];
}
function epochNanoToIso(e2, n2) {
  let [t2, o2] = moveBigNano(e2, n2);
  o2 < 0 && (o2 += Uo, t2 -= 1);
  const [r2, i2] = divModFloor(o2, Qe), [a2, s2] = divModFloor(i2, Yo);
  return epochMilliToIso(t2 * ko + r2, a2, s2);
}
function epochMilliToIso(e2, n2 = 0, t2 = 0) {
  const o2 = Math.ceil(Math.max(0, Math.abs(e2) - Pr) / ko) * Math.sign(e2), r2 = new Date(e2 - o2 * ko);
  return zipProps(Tr, [r2.getUTCFullYear(), r2.getUTCMonth() + 1, r2.getUTCDate() + o2, r2.getUTCHours(), r2.getUTCMinutes(), r2.getUTCSeconds(), r2.getUTCMilliseconds(), n2, t2]);
}
function hashIntlFormatParts(e2, n2) {
  if (n2 < -Pr) {
    throw new RangeError(Io);
  }
  const t2 = e2.formatToParts(n2), o2 = {};
  for (const e3 of t2) {
    o2[e3.type] = e3.value;
  }
  return o2;
}
function computeIsoDateParts(e2) {
  return [e2.isoYear, e2.isoMonth, e2.isoDay];
}
function computeIsoMonthCodeParts(e2, n2) {
  return [n2, 0];
}
function computeIsoMonthsInYear() {
  return kr;
}
function computeIsoDaysInMonth(e2, n2) {
  switch (n2) {
    case 2:
      return computeIsoInLeapYear(e2) ? 29 : 28;
    case 4:
    case 6:
    case 9:
    case 11:
      return 30;
  }
  return 31;
}
function computeIsoDaysInYear(e2) {
  return computeIsoInLeapYear(e2) ? 366 : 365;
}
function computeIsoInLeapYear(e2) {
  return e2 % 4 == 0 && (e2 % 100 != 0 || e2 % 400 == 0);
}
function computeIsoDayOfWeek(e2) {
  const [n2, t2] = isoToLegacyDate(e2.isoYear, e2.isoMonth, e2.isoDay);
  return modFloor(n2.getUTCDay() - t2, 7) || 7;
}
function computeIsoEraParts(e2) {
  return this.id === or ? (({ isoYear: e3 }) => e3 < 1 ? ["gregory-inverse", 1 - e3] : ["gregory", e3])(e2) : this.id === rr ? Yr(e2) : [];
}
function computeJapaneseEraParts(e2) {
  const n2 = isoToEpochMilli(e2);
  if (n2 < Cr) {
    const { isoYear: n3 } = e2;
    return n3 < 1 ? ["japanese-inverse", 1 - n3] : ["japanese", n3];
  }
  const t2 = hashIntlFormatParts(Ci(rr), n2), { era: o2, eraYear: r2 } = parseIntlYear(t2, rr);
  return [o2, r2];
}
function checkIsoDateTimeFields(e2) {
  return checkIsoDateFields(e2), constrainIsoTimeFields(e2, 1), e2;
}
function checkIsoDateFields(e2) {
  return constrainIsoDateFields(e2, 1), e2;
}
function isIsoDateFieldsValid(e2) {
  return allPropsEqual(Dr, e2, constrainIsoDateFields(e2));
}
function constrainIsoDateFields(e2, n2) {
  const { isoYear: t2 } = e2, o2 = clampProp(e2, "isoMonth", 1, computeIsoMonthsInYear(), n2);
  return {
    isoYear: t2,
    isoMonth: o2,
    isoDay: clampProp(e2, "isoDay", 1, computeIsoDaysInMonth(t2, o2), n2)
  };
}
function constrainIsoTimeFields(e2, n2) {
  return zipProps(w, [clampProp(e2, "isoHour", 0, 23, n2), clampProp(e2, "isoMinute", 0, 59, n2), clampProp(e2, "isoSecond", 0, 59, n2), clampProp(e2, "isoMillisecond", 0, 999, n2), clampProp(e2, "isoMicrosecond", 0, 999, n2), clampProp(e2, "isoNanosecond", 0, 999, n2)]);
}
function mt(e2) {
  return void 0 === e2 ? 0 : Xr(requireObjectLike(e2));
}
function je(e2, n2 = 0) {
  e2 = normalizeOptions(e2);
  const t2 = ei(e2), o2 = ni(e2, n2);
  return [Xr(e2), o2, t2];
}
function refineDiffOptions(e2, n2, t2, o2 = 9, r2 = 0, i2 = 4) {
  n2 = normalizeOptions(n2);
  let a2 = Kr(n2, o2, r2), s2 = parseRoundingIncInteger(n2), c2 = ii(n2, i2);
  const u2 = Jr(n2, o2, r2, 1);
  return null == a2 ? a2 = Math.max(t2, u2) : checkLargestSmallestUnit(a2, u2), s2 = refineRoundingInc(s2, u2, 1), e2 && (c2 = ((e3) => e3 < 4 ? (e3 + 2) % 4 : e3)(c2)), [a2, u2, s2, c2];
}
function refineRoundingOptions(e2, n2 = 6, t2) {
  let o2 = parseRoundingIncInteger(e2 = normalizeOptionsOrString(e2, Rr));
  const r2 = ii(e2, 7);
  let i2 = Jr(e2, n2);
  return i2 = requirePropDefined(Rr, i2), o2 = refineRoundingInc(o2, i2, void 0, t2), [i2, o2, r2];
}
function refineDateDisplayOptions(e2) {
  return ti(normalizeOptions(e2));
}
function refineTimeDisplayOptions(e2, n2) {
  return refineTimeDisplayTuple(normalizeOptions(e2), n2);
}
function Me(e2) {
  const n2 = normalizeOptionsOrString(e2, qr), t2 = refineChoiceOption(qr, _r, n2, 0);
  if (!t2) {
    throw new RangeError(invalidEntity(qr, t2));
  }
  return t2;
}
function refineTimeDisplayTuple(e2, n2 = 4) {
  const t2 = refineSubsecDigits(e2);
  return [ii(e2, 4), ...refineSmallestUnitAndSubsecDigits(Jr(e2, n2), t2)];
}
function refineSmallestUnitAndSubsecDigits(e2, n2) {
  return null != e2 ? [Ao[e2], e2 < 4 ? 9 - 3 * e2 : -1] : [void 0 === n2 ? 1 : 10 ** (9 - n2), n2];
}
function parseRoundingIncInteger(e2) {
  const n2 = e2[zr];
  return void 0 === n2 ? 1 : toInteger(n2, zr);
}
function refineRoundingInc(e2, n2, t2, o2) {
  const r2 = o2 ? Uo : Ao[n2 + 1];
  if (r2) {
    const t3 = Ao[n2];
    if (r2 % ((e2 = clampEntity(zr, e2, 1, r2 / t3 - (o2 ? 0 : 1), 1)) * t3)) {
      throw new RangeError(invalidEntity(zr, e2));
    }
  } else {
    e2 = clampEntity(zr, e2, 1, t2 ? 10 ** 9 : 1, 1);
  }
  return e2;
}
function refineSubsecDigits(e2) {
  let n2 = e2[Ur];
  if (void 0 !== n2) {
    if ("number" != typeof n2) {
      if ("auto" === toString(n2)) {
        return;
      }
      throw new RangeError(invalidEntity(Ur, n2));
    }
    n2 = clampEntity(Ur, Math.floor(n2), 0, 9, 1);
  }
  return n2;
}
function normalizeOptions(e2) {
  return void 0 === e2 ? {} : requireObjectLike(e2);
}
function normalizeOptionsOrString(e2, n2) {
  return "string" == typeof e2 ? {
    [n2]: e2
  } : requireObjectLike(e2);
}
function fabricateOverflowOptions(e2) {
  return {
    overflow: jr[e2]
  };
}
function refineUnitOption(e2, n2, t2 = 9, o2 = 0, r2) {
  let i2 = n2[e2];
  if (void 0 === i2) {
    return r2 ? o2 : void 0;
  }
  if (i2 = toString(i2), "auto" === i2) {
    return r2 ? o2 : null;
  }
  let a2 = Oo[i2];
  if (void 0 === a2 && (a2 = mr[i2]), void 0 === a2) {
    throw new RangeError(invalidChoice(e2, i2, Oo));
  }
  return clampEntity(e2, a2, o2, t2, 1, Bo), a2;
}
function refineChoiceOption(e2, n2, t2, o2 = 0) {
  const r2 = t2[e2];
  if (void 0 === r2) {
    return o2;
  }
  const i2 = toString(r2), a2 = n2[i2];
  if (void 0 === a2) {
    throw new RangeError(invalidChoice(e2, i2, n2));
  }
  return a2;
}
function checkLargestSmallestUnit(e2, n2) {
  if (n2 > e2) {
    throw new RangeError(Eo);
  }
}
function xe(e2) {
  return {
    branding: Re,
    epochNanoseconds: e2
  };
}
function _e(e2, n2, t2) {
  return {
    branding: z,
    calendar: t2,
    timeZone: n2,
    epochNanoseconds: e2
  };
}
function jt(e2, n2 = e2.calendar) {
  return {
    branding: x,
    calendar: n2,
    ...nn(Nr, e2)
  };
}
function W(e2, n2 = e2.calendar) {
  return {
    branding: G,
    calendar: n2,
    ...nn(Ir, e2)
  };
}
function createPlainYearMonthSlots(e2, n2 = e2.calendar) {
  return {
    branding: Ut,
    calendar: n2,
    ...nn(Ir, e2)
  };
}
function createPlainMonthDaySlots(e2, n2 = e2.calendar) {
  return {
    branding: qt,
    calendar: n2,
    ...nn(Ir, e2)
  };
}
function St(e2) {
  return {
    branding: ft,
    ...nn(Mr, e2)
  };
}
function Oe(e2) {
  return {
    branding: N,
    sign: computeDurationSign(e2),
    ...nn(ur, e2)
  };
}
function I(e2) {
  return divModBigNano(e2.epochNanoseconds, Qe)[0];
}
function v(e2) {
  return ((e3, n2 = 1) => {
    const [t2, o2] = e3, r2 = Math.floor(o2 / n2), i2 = Uo / n2;
    return BigInt(t2) * BigInt(i2) + BigInt(r2);
  })(e2.epochNanoseconds);
}
function extractEpochNano(e2) {
  return e2.epochNanoseconds;
}
function J(e2, n2, t2, o2, r2) {
  const i2 = getMaxDurationUnit(o2), [a2, s2] = ((e3, n3) => {
    const t3 = n3((e3 = normalizeOptionsOrString(e3, Zr))[Ar]);
    let o3 = Qr(e3);
    return o3 = requirePropDefined(Zr, o3), [o3, t3];
  })(r2, e2), c2 = Math.max(a2, i2);
  if (!s2 && isUniformUnit(c2, s2)) {
    return totalDayTimeDuration(o2, a2);
  }
  if (!s2) {
    throw new RangeError(yo);
  }
  if (!o2.sign) {
    return 0;
  }
  const [u2, f2, l2] = createMarkerSystem(n2, t2, s2), d2 = createMarkerToEpochNano(l2), m2 = createMoveMarker(l2), h2 = createDiffMarkers(l2), g2 = m2(f2, u2, o2);
  isZonedEpochSlots(s2) || (checkIsoDateTimeInBounds(u2), checkIsoDateTimeInBounds(g2));
  const D3 = h2(f2, u2, g2, a2);
  return isUniformUnit(a2, s2) ? totalDayTimeDuration(D3, a2) : ((e3, n3, t3, o3, r3, i3, a3) => {
    const s3 = computeDurationSign(e3), [c3, u3] = clampRelativeDuration(o3, gr(t3, e3), t3, s3, r3, i3, a3), f3 = computeEpochNanoFrac(n3, c3, u3);
    return e3[p[t3]] + f3 * s3;
  })(D3, d2(g2), a2, f2, u2, d2, m2);
}
function totalDayTimeDuration(e2, n2) {
  return bigNanoToNumber(durationFieldsToBigNano(e2), Ao[n2], 1);
}
function clampRelativeDuration(e2, n2, t2, o2, r2, i2, a2) {
  const s2 = p[t2], c2 = {
    ...n2,
    [s2]: n2[s2] + o2
  }, u2 = a2(e2, r2, n2), f2 = a2(e2, r2, c2);
  return [i2(u2), i2(f2)];
}
function computeEpochNanoFrac(e2, n2, t2) {
  const o2 = bigNanoToNumber(diffBigNanos(n2, t2));
  if (!o2) {
    throw new RangeError(fo);
  }
  return bigNanoToNumber(diffBigNanos(n2, e2)) / o2;
}
function Le(e2, n2) {
  const [t2, o2, r2] = refineRoundingOptions(n2, 5, 1);
  return xe(roundBigNano(e2.epochNanoseconds, t2, o2, r2, 1));
}
function Ie(e2, n2, t2) {
  let { epochNanoseconds: o2, timeZone: r2, calendar: i2 } = n2;
  const [a2, s2, c2] = refineRoundingOptions(t2);
  if (0 === a2 && 1 === s2) {
    return n2;
  }
  const u2 = e2(r2);
  if (6 === a2) {
    o2 = ((e3, n3, t3, o3) => {
      const r3 = he(t3, n3), [i3, a3] = e3(r3), s3 = t3.epochNanoseconds, c3 = getStartOfDayInstantFor(n3, i3), u3 = getStartOfDayInstantFor(n3, a3);
      if (bigNanoOutside(s3, c3, u3)) {
        throw new RangeError(fo);
      }
      return roundWithMode(computeEpochNanoFrac(s3, c3, u3), o3) ? u3 : c3;
    })(computeDayInterval, u2, n2, c2);
  } else {
    const e3 = u2.R(o2);
    o2 = getMatchingInstantFor(u2, roundDateTime(epochNanoToIso(o2, e3), a2, s2, c2), e3, 2, 0, 1);
  }
  return _e(o2, r2, i2);
}
function vt(e2, n2) {
  return jt(roundDateTime(e2, ...refineRoundingOptions(n2)), e2.calendar);
}
function lt(e2, n2) {
  const [t2, o2, r2] = refineRoundingOptions(n2, 5);
  var i2;
  return St((i2 = r2, roundTimeToNano(e2, computeNanoInc(t2, o2), i2)[0]));
}
function Te(e2, n2) {
  const t2 = e2(n2.timeZone), o2 = he(n2, t2), [r2, i2] = computeDayInterval(o2), a2 = bigNanoToNumber(diffBigNanos(getStartOfDayInstantFor(t2, r2), getStartOfDayInstantFor(t2, i2)), zo, 1);
  if (a2 <= 0) {
    throw new RangeError(fo);
  }
  return a2;
}
function ve(e2, n2) {
  const { timeZone: t2, calendar: o2 } = n2, r2 = ((e3, n3, t3) => getStartOfDayInstantFor(n3, e3(he(t3, n3))))(computeDayFloor, e2(t2), n2);
  return _e(r2, t2, o2);
}
function roundDateTime(e2, n2, t2, o2) {
  return roundDateTimeToNano(e2, computeNanoInc(n2, t2), o2);
}
function roundDateTimeToNano(e2, n2, t2) {
  const [o2, r2] = roundTimeToNano(e2, n2, t2);
  return checkIsoDateTimeInBounds({
    ...moveByDays(e2, r2),
    ...o2
  });
}
function roundTimeToNano(e2, n2, t2) {
  return nanoToIsoTimeAndDay(roundByInc(isoTimeFieldsToNano(e2), n2, t2));
}
function roundToMinute(e2) {
  return roundByInc(e2, Zo, 7);
}
function computeNanoInc(e2, n2) {
  return Ao[e2] * n2;
}
function computeDayInterval(e2) {
  const n2 = computeDayFloor(e2);
  return [n2, moveByDays(n2, 1)];
}
function computeDayFloor(e2) {
  return yr(6, e2);
}
function roundDayTimeDurationByInc(e2, n2, t2) {
  const o2 = Math.min(getMaxDurationUnit(e2), 6);
  return nanoToDurationDayTimeFields(roundBigNanoByInc(durationFieldsToBigNano(e2, o2), n2, t2), o2);
}
function roundRelativeDuration(e2, n2, t2, o2, r2, i2, a2, s2, c2, u2) {
  if (0 === o2 && 1 === r2) {
    return e2;
  }
  const f2 = isUniformUnit(o2, s2) ? isZonedEpochSlots(s2) && o2 < 6 && t2 >= 6 ? nudgeZonedTimeDuration : nudgeDayTimeDuration : nudgeRelativeDuration;
  let [l2, d2, m2] = f2(e2, n2, t2, o2, r2, i2, a2, s2, c2, u2);
  return m2 && 7 !== o2 && (l2 = ((e3, n3, t3, o3, r3, i3, a3, s3) => {
    const c3 = computeDurationSign(e3);
    for (let u3 = o3 + 1; u3 <= t3; u3++) {
      if (7 === u3 && 7 !== t3) {
        continue;
      }
      const o4 = gr(u3, e3);
      o4[p[u3]] += c3;
      const f3 = bigNanoToNumber(diffBigNanos(a3(s3(r3, i3, o4)), n3));
      if (f3 && Math.sign(f3) !== c3) {
        break;
      }
      e3 = o4;
    }
    return e3;
  })(l2, d2, t2, Math.max(6, o2), a2, s2, c2, u2)), l2;
}
function roundBigNano(e2, n2, t2, o2, r2) {
  if (6 === n2) {
    const n3 = ((e3) => e3[0] + e3[1] / Uo)(e2);
    return [roundByInc(n3, t2, o2), 0];
  }
  return roundBigNanoByInc(e2, computeNanoInc(n2, t2), o2, r2);
}
function roundBigNanoByInc(e2, n2, t2, o2) {
  let [r2, i2] = e2;
  o2 && i2 < 0 && (i2 += Uo, r2 -= 1);
  const [a2, s2] = divModFloor(roundByInc(i2, n2, t2), Uo);
  return createBigNano(r2 + a2, s2);
}
function roundByInc(e2, n2, t2) {
  return roundWithMode(e2 / n2, t2) * n2;
}
function roundWithMode(e2, n2) {
  return ai[n2](e2);
}
function nudgeDayTimeDuration(e2, n2, t2, o2, r2, i2) {
  const a2 = computeDurationSign(e2), s2 = durationFieldsToBigNano(e2), c2 = roundBigNano(s2, o2, r2, i2), u2 = diffBigNanos(s2, c2), f2 = Math.sign(c2[0] - s2[0]) === a2, l2 = nanoToDurationDayTimeFields(c2, Math.min(t2, 6));
  return [{
    ...e2,
    ...l2
  }, addBigNanos(n2, u2), f2];
}
function nudgeZonedTimeDuration(e2, n2, t2, o2, r2, i2, a2, s2, c2, u2) {
  const f2 = computeDurationSign(e2) || 1, l2 = bigNanoToNumber(durationFieldsToBigNano(e2, 5)), d2 = computeNanoInc(o2, r2);
  let m2 = roundByInc(l2, d2, i2);
  const [p2, h2] = clampRelativeDuration(a2, {
    ...e2,
    ...hr
  }, 6, f2, s2, c2, u2), g2 = m2 - bigNanoToNumber(diffBigNanos(p2, h2));
  let D3 = 0;
  g2 && Math.sign(g2) !== f2 ? n2 = moveBigNano(p2, m2) : (D3 += f2, m2 = roundByInc(g2, d2, i2), n2 = moveBigNano(h2, m2));
  const T2 = nanoToDurationTimeFields(m2);
  return [{
    ...e2,
    ...T2,
    days: e2.days + D3
  }, n2, Boolean(D3)];
}
function nudgeRelativeDuration(e2, n2, t2, o2, r2, i2, a2, s2, c2, u2) {
  const f2 = computeDurationSign(e2), l2 = p[o2], d2 = gr(o2, e2);
  7 === o2 && (e2 = {
    ...e2,
    weeks: e2.weeks + Math.trunc(e2.days / 7)
  });
  const m2 = divTrunc(e2[l2], r2) * r2;
  d2[l2] = m2;
  const [h2, g2] = clampRelativeDuration(a2, d2, o2, r2 * f2, s2, c2, u2), D3 = m2 + computeEpochNanoFrac(n2, h2, g2) * f2 * r2, T2 = roundByInc(D3, r2, i2), I2 = Math.sign(T2 - D3) === f2;
  return d2[l2] = T2, [d2, I2 ? g2 : h2, I2];
}
function ke(e2, n2, t2, o2) {
  const [r2, i2, a2, s2] = ((e3) => {
    const n3 = refineTimeDisplayTuple(e3 = normalizeOptions(e3));
    return [e3.timeZone, ...n3];
  })(o2), c2 = void 0 !== r2;
  return ((e3, n3, t3, o3, r3, i3) => {
    t3 = roundBigNanoByInc(t3, r3, o3, 1);
    const a3 = n3.R(t3);
    return formatIsoDateTimeFields(epochNanoToIso(t3, a3), i3) + (e3 ? Se(roundToMinute(a3)) : "Z");
  })(c2, n2(c2 ? e2(r2) : si), t2.epochNanoseconds, i2, a2, s2);
}
function Fe(e2, n2, t2) {
  const [o2, r2, i2, a2, s2, c2] = ((e3) => {
    e3 = normalizeOptions(e3);
    const n3 = ti(e3), t3 = refineSubsecDigits(e3), o3 = ri(e3), r3 = ii(e3, 4), i3 = Jr(e3, 4);
    return [n3, oi(e3), o3, r3, ...refineSmallestUnitAndSubsecDigits(i3, t3)];
  })(t2);
  return ((e3, n3, t3, o3, r3, i3, a3, s3, c3, u2) => {
    o3 = roundBigNanoByInc(o3, c3, s3, 1);
    const f2 = e3(t3).R(o3);
    return formatIsoDateTimeFields(epochNanoToIso(o3, f2), u2) + Se(roundToMinute(f2), a3) + ((e4, n4) => 1 !== n4 ? "[" + (2 === n4 ? "!" : "") + e4 + "]" : "")(t3, i3) + formatCalendar(n3, r3);
  })(e2, n2.calendar, n2.timeZone, n2.epochNanoseconds, o2, r2, i2, a2, s2, c2);
}
function Ft(e2, n2) {
  const [t2, o2, r2, i2] = ((e3) => (e3 = normalizeOptions(e3), [ti(e3), ...refineTimeDisplayTuple(e3)]))(n2);
  return a2 = e2.calendar, s2 = t2, c2 = i2, formatIsoDateTimeFields(roundDateTimeToNano(e2, r2, o2), c2) + formatCalendar(a2, s2);
  var a2, s2, c2;
}
function ce(e2, n2) {
  return t2 = e2.calendar, o2 = e2, r2 = refineDateDisplayOptions(n2), formatIsoDateFields(o2) + formatCalendar(t2, r2);
  var t2, o2, r2;
}
function Kt(e2, n2) {
  return formatDateLikeIso(e2.calendar, formatIsoYearMonthFields, e2, refineDateDisplayOptions(n2));
}
function Jt(e2, n2) {
  return formatDateLikeIso(e2.calendar, formatIsoMonthDayFields, e2, refineDateDisplayOptions(n2));
}
function ct(e2, n2) {
  const [t2, o2, r2] = refineTimeDisplayOptions(n2);
  return i2 = r2, formatIsoTimeFields(roundTimeToNano(e2, o2, t2)[0], i2);
  var i2;
}
function k(e2, n2) {
  const [t2, o2, r2] = refineTimeDisplayOptions(n2, 3);
  return o2 > 1 && checkDurationUnits(e2 = {
    ...e2,
    ...roundDayTimeDurationByInc(e2, o2, t2)
  }), ((e3, n3) => {
    const { sign: t3 } = e3, o3 = -1 === t3 ? negateDurationFields(e3) : e3, { hours: r3, minutes: i2 } = o3, [a2, s2] = divModBigNano(durationFieldsToBigNano(o3, 3), Ro, divModTrunc);
    checkDurationTimeUnit(a2);
    const c2 = formatSubsecNano(s2, n3), u2 = n3 >= 0 || !t3 || c2;
    return (t3 < 0 ? "-" : "") + "P" + formatDurationFragments({
      Y: formatDurationNumber(o3.years),
      M: formatDurationNumber(o3.months),
      W: formatDurationNumber(o3.weeks),
      D: formatDurationNumber(o3.days)
    }) + (r3 || i2 || a2 || u2 ? "T" + formatDurationFragments({
      H: formatDurationNumber(r3),
      M: formatDurationNumber(i2),
      S: formatDurationNumber(a2, u2) + c2
    }) : "");
  })(e2, r2);
}
function formatDateLikeIso(e2, n2, t2, o2) {
  const r2 = o2 > 1 || 0 === o2 && e2 !== l;
  return 1 === o2 ? e2 === l ? n2(t2) : formatIsoDateFields(t2) : r2 ? formatIsoDateFields(t2) + formatCalendarId(e2, 2 === o2) : n2(t2);
}
function formatDurationFragments(e2) {
  const n2 = [];
  for (const t2 in e2) {
    const o2 = e2[t2];
    o2 && n2.push(o2, t2);
  }
  return n2.join("");
}
function formatIsoDateTimeFields(e2, n2) {
  return formatIsoDateFields(e2) + "T" + formatIsoTimeFields(e2, n2);
}
function formatIsoDateFields(e2) {
  return formatIsoYearMonthFields(e2) + "-" + bo(e2.isoDay);
}
function formatIsoYearMonthFields(e2) {
  const { isoYear: n2 } = e2;
  return (n2 < 0 || n2 > 9999 ? getSignStr(n2) + padNumber(6, Math.abs(n2)) : padNumber(4, n2)) + "-" + bo(e2.isoMonth);
}
function formatIsoMonthDayFields(e2) {
  return bo(e2.isoMonth) + "-" + bo(e2.isoDay);
}
function formatIsoTimeFields(e2, n2) {
  const t2 = [bo(e2.isoHour), bo(e2.isoMinute)];
  return -1 !== n2 && t2.push(bo(e2.isoSecond) + ((e3, n3, t3, o2) => formatSubsecNano(e3 * Qe + n3 * Yo + t3, o2))(e2.isoMillisecond, e2.isoMicrosecond, e2.isoNanosecond, n2)), t2.join(":");
}
function Se(e2, n2 = 0) {
  if (1 === n2) {
    return "";
  }
  const [t2, o2] = divModFloor(Math.abs(e2), zo), [r2, i2] = divModFloor(o2, Zo), [a2, s2] = divModFloor(i2, Ro);
  return getSignStr(e2) + bo(t2) + ":" + bo(r2) + (a2 || s2 ? ":" + bo(a2) + formatSubsecNano(s2) : "");
}
function formatCalendar(e2, n2) {
  return 1 !== n2 && (n2 > 1 || 0 === n2 && e2 !== l) ? formatCalendarId(e2, 2 === n2) : "";
}
function formatCalendarId(e2, n2) {
  return "[" + (n2 ? "!" : "") + "u-ca=" + e2 + "]";
}
function formatSubsecNano(e2, n2) {
  let t2 = padNumber(9, e2);
  return t2 = void 0 === n2 ? t2.replace(li, "") : t2.slice(0, n2), t2 ? "." + t2 : "";
}
function getSignStr(e2) {
  return e2 < 0 ? "-" : "+";
}
function formatDurationNumber(e2, n2) {
  return e2 || n2 ? e2.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}
function _zonedEpochSlotsToIso(e2, n2) {
  const { epochNanoseconds: t2 } = e2, o2 = (n2.R ? n2 : n2(e2.timeZone)).R(t2), r2 = epochNanoToIso(t2, o2);
  return {
    calendar: e2.calendar,
    ...r2,
    offsetNanoseconds: o2
  };
}
function getMatchingInstantFor(e2, n2, t2, o2 = 0, r2 = 0, i2, a2) {
  if (void 0 !== t2 && 1 === o2 && (1 === o2 || a2)) {
    return isoToEpochNanoWithOffset(n2, t2);
  }
  const s2 = e2.I(n2);
  if (void 0 !== t2 && 3 !== o2) {
    const e3 = ((e4, n3, t3, o3) => {
      const r3 = isoToEpochNano(n3);
      o3 && (t3 = roundToMinute(t3));
      for (const n4 of e4) {
        let e5 = bigNanoToNumber(diffBigNanos(n4, r3));
        if (o3 && (e5 = roundToMinute(e5)), e5 === t3) {
          return n4;
        }
      }
    })(s2, n2, t2, i2);
    if (void 0 !== e3) {
      return e3;
    }
    if (0 === o2) {
      throw new RangeError(Do);
    }
  }
  return a2 ? isoToEpochNano(n2) : getSingleInstantFor(e2, n2, r2, s2);
}
function getSingleInstantFor(e2, n2, t2 = 0, o2 = e2.I(n2)) {
  if (1 === o2.length) {
    return o2[0];
  }
  if (1 === t2) {
    throw new RangeError(To);
  }
  if (o2.length) {
    return o2[3 === t2 ? 1 : 0];
  }
  const r2 = isoToEpochNano(n2), i2 = ((e3, n3) => {
    const t3 = e3.R(moveBigNano(n3, -Uo));
    return ((e4) => {
      if (e4 > Uo) {
        throw new RangeError(go);
      }
      return e4;
    })(e3.R(moveBigNano(n3, Uo)) - t3);
  })(e2, r2), a2 = i2 * (2 === t2 ? -1 : 1);
  return (o2 = e2.I(epochNanoToIso(r2, a2)))[2 === t2 ? 0 : o2.length - 1];
}
function getStartOfDayInstantFor(e2, n2) {
  const t2 = e2.I(n2);
  if (t2.length) {
    return t2[0];
  }
  const o2 = moveBigNano(isoToEpochNano(n2), -Uo);
  return e2.O(o2, 1);
}
function Ye(e2, n2, t2) {
  return xe(checkEpochNanoInBounds(addBigNanos(n2.epochNanoseconds, ((e3) => {
    if (durationHasDateParts(e3)) {
      throw new RangeError(vo);
    }
    return durationFieldsToBigNano(e3, 5);
  })(e2 ? negateDurationFields(t2) : t2))));
}
function pe(e2, n2, t2, o2, r2, i2 = /* @__PURE__ */ Object.create(null)) {
  const a2 = n2(o2.timeZone), s2 = e2(o2.calendar);
  return {
    ...o2,
    ...moveZonedEpochs(a2, s2, o2, t2 ? negateDurationFields(r2) : r2, i2)
  };
}
function wt(e2, n2, t2, o2, r2 = /* @__PURE__ */ Object.create(null)) {
  const { calendar: i2 } = t2;
  return jt(moveDateTime(e2(i2), t2, n2 ? negateDurationFields(o2) : o2, r2), i2);
}
function ne(e2, n2, t2, o2, r2) {
  const { calendar: i2 } = t2;
  return W(moveDate(e2(i2), t2, n2 ? negateDurationFields(o2) : o2, r2), i2);
}
function Gt(e2, n2, t2, o2, r2) {
  const i2 = t2.calendar, a2 = e2(i2);
  let s2 = checkIsoDateInBounds(moveToDayOfMonthUnsafe(a2, t2));
  n2 && (o2 = B(o2)), o2.sign < 0 && (s2 = a2.P(s2, {
    ...pr,
    months: 1
  }), s2 = moveByDays(s2, -1));
  const c2 = a2.P(s2, o2, r2);
  return createPlainYearMonthSlots(moveToDayOfMonthUnsafe(a2, c2), i2);
}
function at(e2, n2, t2) {
  return St(moveTime(n2, e2 ? negateDurationFields(t2) : t2)[0]);
}
function moveZonedEpochs(e2, n2, t2, o2, r2) {
  const i2 = durationFieldsToBigNano(o2, 5);
  let a2 = t2.epochNanoseconds;
  if (durationHasDateParts(o2)) {
    const s2 = he(t2, e2);
    a2 = addBigNanos(getSingleInstantFor(e2, {
      ...moveDate(n2, s2, {
        ...o2,
        ...hr
      }, r2),
      ...nn(w, s2)
    }), i2);
  } else {
    a2 = addBigNanos(a2, i2), mt(r2);
  }
  return {
    epochNanoseconds: checkEpochNanoInBounds(a2)
  };
}
function moveDateTime(e2, n2, t2, o2) {
  const [r2, i2] = moveTime(n2, t2);
  return checkIsoDateTimeInBounds({
    ...moveDate(e2, n2, {
      ...t2,
      ...hr,
      days: t2.days + i2
    }, o2),
    ...r2
  });
}
function moveDate(e2, n2, t2, o2) {
  if (t2.years || t2.months || t2.weeks) {
    return e2.P(n2, t2, o2);
  }
  mt(o2);
  const r2 = t2.days + durationFieldsToBigNano(t2, 5)[0];
  return r2 ? checkIsoDateInBounds(moveByDays(n2, r2)) : n2;
}
function moveToDayOfMonthUnsafe(e2, n2, t2 = 1) {
  return moveByDays(n2, t2 - e2.day(n2));
}
function moveTime(e2, n2) {
  const [t2, o2] = durationFieldsToBigNano(n2, 5), [r2, i2] = nanoToIsoTimeAndDay(isoTimeFieldsToNano(e2) + o2);
  return [r2, t2 + i2];
}
function moveByDays(e2, n2) {
  return n2 ? {
    ...e2,
    ...epochMilliToIso(isoToEpochMilli(e2) + n2 * ko)
  } : e2;
}
function createMarkerSystem(e2, n2, t2) {
  const o2 = e2(t2.calendar);
  return isZonedEpochSlots(t2) ? [t2, o2, n2(t2.timeZone)] : [{
    ...t2,
    ...Nt
  }, o2];
}
function createMarkerToEpochNano(e2) {
  return e2 ? extractEpochNano : isoToEpochNano;
}
function createMoveMarker(e2) {
  return e2 ? Pt(moveZonedEpochs, e2) : moveDateTime;
}
function createDiffMarkers(e2) {
  return e2 ? Pt(diffZonedEpochsExact, e2) : diffDateTimesExact;
}
function isZonedEpochSlots(e2) {
  return e2 && e2.epochNanoseconds;
}
function isUniformUnit(e2, n2) {
  return e2 <= 6 - (isZonedEpochSlots(n2) ? 1 : 0);
}
function E(e2, n2, t2, o2, r2, i2, a2) {
  const s2 = e2(normalizeOptions(a2).relativeTo), c2 = Math.max(getMaxDurationUnit(r2), getMaxDurationUnit(i2));
  if (isUniformUnit(c2, s2)) {
    return Oe(checkDurationUnits(((e3, n3, t3, o3) => {
      const r3 = addBigNanos(durationFieldsToBigNano(e3), durationFieldsToBigNano(n3), o3 ? -1 : 1);
      if (!Number.isFinite(r3[0])) {
        throw new RangeError(Io);
      }
      return {
        ...pr,
        ...nanoToDurationDayTimeFields(r3, t3)
      };
    })(r2, i2, c2, o2)));
  }
  if (!s2) {
    throw new RangeError(yo);
  }
  o2 && (i2 = negateDurationFields(i2));
  const [u2, f2, l2] = createMarkerSystem(n2, t2, s2), d2 = createMoveMarker(l2), m2 = createDiffMarkers(l2), p2 = d2(f2, u2, r2);
  return Oe(m2(f2, u2, d2(f2, p2, i2), c2));
}
function V(e2, n2, t2, o2, r2) {
  const i2 = getMaxDurationUnit(o2), [a2, s2, c2, u2, f2] = ((e3, n3, t3) => {
    e3 = normalizeOptionsOrString(e3, Rr);
    let o3 = Kr(e3);
    const r3 = t3(e3[Ar]);
    let i3 = parseRoundingIncInteger(e3);
    const a3 = ii(e3, 7);
    let s3 = Jr(e3);
    if (void 0 === o3 && void 0 === s3) {
      throw new RangeError(Po);
    }
    if (null == s3 && (s3 = 0), null == o3 && (o3 = Math.max(s3, n3)), checkLargestSmallestUnit(o3, s3), i3 = refineRoundingInc(i3, s3, 1), i3 > 1 && s3 > 5 && o3 !== s3) {
      throw new RangeError("For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit");
    }
    return [o3, s3, i3, a3, r3];
  })(r2, i2, e2), l2 = Math.max(i2, a2);
  if (!f2 && l2 <= 6) {
    return Oe(checkDurationUnits(((e3, n3, t3, o3, r3) => {
      const i3 = roundBigNano(durationFieldsToBigNano(e3), t3, o3, r3);
      return {
        ...pr,
        ...nanoToDurationDayTimeFields(i3, n3)
      };
    })(o2, a2, s2, c2, u2)));
  }
  if (!isZonedEpochSlots(f2) && !o2.sign) {
    return o2;
  }
  if (!f2) {
    throw new RangeError(yo);
  }
  const [d2, m2, p2] = createMarkerSystem(n2, t2, f2), h2 = createMarkerToEpochNano(p2), g2 = createMoveMarker(p2), D3 = createDiffMarkers(p2), T2 = g2(m2, d2, o2);
  isZonedEpochSlots(f2) || (checkIsoDateTimeInBounds(d2), checkIsoDateTimeInBounds(T2));
  let I2 = D3(m2, d2, T2, a2);
  const M2 = o2.sign, N2 = computeDurationSign(I2);
  if (M2 && N2 && M2 !== N2) {
    throw new RangeError(fo);
  }
  return I2 = roundRelativeDuration(I2, h2(T2), a2, s2, c2, u2, m2, d2, h2, g2), Oe(I2);
}
function Y(e2) {
  return -1 === e2.sign ? B(e2) : e2;
}
function B(e2) {
  return Oe(negateDurationFields(e2));
}
function negateDurationFields(e2) {
  const n2 = {};
  for (const t2 of p) {
    n2[t2] = -1 * e2[t2] || 0;
  }
  return n2;
}
function y(e2) {
  return !e2.sign;
}
function computeDurationSign(e2, n2 = p) {
  let t2 = 0;
  for (const o2 of n2) {
    const n3 = Math.sign(e2[o2]);
    if (n3) {
      if (t2 && t2 !== n3) {
        throw new RangeError(No);
      }
      t2 = n3;
    }
  }
  return t2;
}
function checkDurationUnits(e2) {
  for (const n2 of dr) {
    clampEntity(n2, e2[n2], -di, di, 1);
  }
  return checkDurationTimeUnit(bigNanoToNumber(durationFieldsToBigNano(e2), Ro)), e2;
}
function checkDurationTimeUnit(e2) {
  if (!Number.isSafeInteger(e2)) {
    throw new RangeError(Mo);
  }
}
function durationFieldsToBigNano(e2, n2 = 6) {
  return givenFieldsToBigNano(e2, n2, p);
}
function nanoToDurationDayTimeFields(e2, n2 = 6) {
  const [t2, o2] = e2, r2 = nanoToGivenFields(o2, n2, p);
  if (r2[p[n2]] += t2 * (Uo / Ao[n2]), !Number.isFinite(r2[p[n2]])) {
    throw new RangeError(Io);
  }
  return r2;
}
function nanoToDurationTimeFields(e2, n2 = 5) {
  return nanoToGivenFields(e2, n2, p);
}
function durationHasDateParts(e2) {
  return Boolean(computeDurationSign(e2, lr));
}
function getMaxDurationUnit(e2) {
  let n2 = 9;
  for (; n2 > 0 && !e2[p[n2]]; n2--) {
  }
  return n2;
}
function createSplitTuple(e2, n2) {
  return [e2, n2];
}
function computePeriod(e2) {
  const n2 = Math.floor(e2 / ci) * ci;
  return [n2, n2 + ci];
}
function We(e2) {
  const n2 = parseDateTimeLike(e2 = toStringViaPrimitive(e2));
  if (!n2) {
    throw new RangeError(failedParse(e2));
  }
  let t2;
  if (n2.j) {
    t2 = 0;
  } else {
    if (!n2.offset) {
      throw new RangeError(failedParse(e2));
    }
    t2 = parseOffsetNano(n2.offset);
  }
  return n2.timeZone && parseOffsetNanoMaybe(n2.timeZone, 1), xe(isoToEpochNanoWithOffset(checkIsoDateTimeFields(n2), t2));
}
function H(e2) {
  const n2 = parseDateTimeLike(m(e2));
  if (!n2) {
    throw new RangeError(failedParse(e2));
  }
  if (n2.timeZone) {
    return finalizeZonedDateTime(n2, n2.offset ? parseOffsetNano(n2.offset) : void 0);
  }
  if (n2.j) {
    throw new RangeError(failedParse(e2));
  }
  return finalizeDate(n2);
}
function Ae(e2, n2) {
  const t2 = parseDateTimeLike(m(e2));
  if (!t2 || !t2.timeZone) {
    throw new RangeError(failedParse(e2));
  }
  const { offset: o2 } = t2, r2 = o2 ? parseOffsetNano(o2) : void 0, [, i2, a2] = je(n2);
  return finalizeZonedDateTime(t2, r2, i2, a2);
}
function parseOffsetNano(e2) {
  const n2 = parseOffsetNanoMaybe(e2);
  if (void 0 === n2) {
    throw new RangeError(failedParse(e2));
  }
  return n2;
}
function Bt(e2) {
  const n2 = parseDateTimeLike(m(e2));
  if (!n2 || n2.j) {
    throw new RangeError(failedParse(e2));
  }
  return jt(finalizeDateTime(n2));
}
function de(e2, n2, t2) {
  let o2 = parseDateTimeLike(m(e2));
  if (!o2 || o2.j) {
    throw new RangeError(failedParse(e2));
  }
  return n2 ? o2.calendar === l && (o2 = -271821 === o2.isoYear && 4 === o2.isoMonth ? {
    ...o2,
    isoDay: 20,
    ...Nt
  } : {
    ...o2,
    isoDay: 1,
    ...Nt
  }) : t2 && o2.calendar === l && (o2 = {
    ...o2,
    isoYear: Br
  }), W(o2.C ? finalizeDateTime(o2) : finalizeDate(o2));
}
function _t(e2, n2) {
  const t2 = parseYearMonthOnly(m(n2));
  if (t2) {
    return requireIsoCalendar(t2), createPlainYearMonthSlots(checkIsoYearMonthInBounds(checkIsoDateFields(t2)));
  }
  const o2 = de(n2, 1);
  return createPlainYearMonthSlots(moveToDayOfMonthUnsafe(e2(o2.calendar), o2));
}
function requireIsoCalendar(e2) {
  if (e2.calendar !== l) {
    throw new RangeError(invalidSubstring(e2.calendar));
  }
}
function xt(e2, n2) {
  const t2 = parseMonthDayOnly(m(n2));
  if (t2) {
    return requireIsoCalendar(t2), createPlainMonthDaySlots(checkIsoDateFields(t2));
  }
  const o2 = de(n2, 0, 1), { calendar: r2 } = o2, i2 = e2(r2), [a2, s2, c2] = i2.v(o2), [u2, f2] = i2.q(a2, s2), [l2, d2] = i2.G(u2, f2, c2);
  return createPlainMonthDaySlots(checkIsoDateInBounds(i2.V(l2, d2, c2)), r2);
}
function ht(e2) {
  let n2, t2 = ((e3) => {
    const n3 = Pi.exec(e3);
    return n3 ? (organizeAnnotationParts(n3[10]), organizeTimeParts(n3)) : void 0;
  })(m(e2));
  if (!t2) {
    if (t2 = parseDateTimeLike(e2), !t2) {
      throw new RangeError(failedParse(e2));
    }
    if (!t2.C) {
      throw new RangeError(failedParse(e2));
    }
    if (t2.j) {
      throw new RangeError(invalidSubstring("Z"));
    }
    requireIsoCalendar(t2);
  }
  if ((n2 = parseYearMonthOnly(e2)) && isIsoDateFieldsValid(n2)) {
    throw new RangeError(failedParse(e2));
  }
  if ((n2 = parseMonthDayOnly(e2)) && isIsoDateFieldsValid(n2)) {
    throw new RangeError(failedParse(e2));
  }
  return St(constrainIsoTimeFields(t2, 1));
}
function R(e2) {
  const n2 = ((e3) => {
    const n3 = Fi.exec(e3);
    return n3 ? ((e4) => {
      function parseUnit(e5, r3, i2) {
        let a2 = 0, s2 = 0;
        if (i2 && ([a2, o2] = divModFloor(o2, Ao[i2])), void 0 !== e5) {
          if (t2) {
            throw new RangeError(invalidSubstring(e5));
          }
          s2 = ((e6) => {
            const n5 = parseInt(e6);
            if (!Number.isFinite(n5)) {
              throw new RangeError(invalidSubstring(e6));
            }
            return n5;
          })(e5), n4 = 1, r3 && (o2 = parseSubsecNano(r3) * (Ao[i2] / Ro), t2 = 1);
        }
        return a2 + s2;
      }
      let n4 = 0, t2 = 0, o2 = 0, r2 = {
        ...zipProps(p, [parseUnit(e4[2]), parseUnit(e4[3]), parseUnit(e4[4]), parseUnit(e4[5]), parseUnit(e4[6], e4[7], 5), parseUnit(e4[8], e4[9], 4), parseUnit(e4[10], e4[11], 3)]),
        ...nanoToGivenFields(o2, 2, p)
      };
      if (!n4) {
        throw new RangeError(noValidFields(p));
      }
      return parseSign(e4[1]) < 0 && (r2 = negateDurationFields(r2)), r2;
    })(n3) : void 0;
  })(m(e2));
  if (!n2) {
    throw new RangeError(failedParse(e2));
  }
  return Oe(checkDurationUnits(n2));
}
function f(e2) {
  const n2 = parseDateTimeLike(e2) || parseYearMonthOnly(e2) || parseMonthDayOnly(e2);
  return n2 ? n2.calendar : e2;
}
function Z(e2) {
  const n2 = parseDateTimeLike(e2);
  return n2 && (n2.timeZone || n2.j && si || n2.offset) || e2;
}
function finalizeZonedDateTime(e2, n2, t2 = 0, o2 = 0) {
  const r2 = M(e2.timeZone), i2 = L(r2);
  let a2;
  return checkIsoDateTimeFields(e2), a2 = e2.C ? getMatchingInstantFor(i2, e2, n2, t2, o2, !i2.$, e2.j) : getStartOfDayInstantFor(i2, e2), _e(a2, r2, u(e2.calendar));
}
function finalizeDateTime(e2) {
  return resolveSlotsCalendar(checkIsoDateTimeInBounds(checkIsoDateTimeFields(e2)));
}
function finalizeDate(e2) {
  return resolveSlotsCalendar(checkIsoDateInBounds(checkIsoDateFields(e2)));
}
function resolveSlotsCalendar(e2) {
  return {
    ...e2,
    calendar: u(e2.calendar)
  };
}
function parseDateTimeLike(e2) {
  const n2 = vi.exec(e2);
  return n2 ? ((e3) => {
    const n3 = e3[10], t2 = "Z" === (n3 || "").toUpperCase();
    return {
      isoYear: organizeIsoYearParts(e3),
      isoMonth: parseInt(e3[4]),
      isoDay: parseInt(e3[5]),
      ...organizeTimeParts(e3.slice(5)),
      ...organizeAnnotationParts(e3[16]),
      C: Boolean(e3[6]),
      j: t2,
      offset: t2 ? void 0 : n3
    };
  })(n2) : void 0;
}
function parseYearMonthOnly(e2) {
  const n2 = Ni.exec(e2);
  return n2 ? ((e3) => ({
    isoYear: organizeIsoYearParts(e3),
    isoMonth: parseInt(e3[4]),
    isoDay: 1,
    ...organizeAnnotationParts(e3[5])
  }))(n2) : void 0;
}
function parseMonthDayOnly(e2) {
  const n2 = yi.exec(e2);
  return n2 ? ((e3) => ({
    isoYear: Br,
    isoMonth: parseInt(e3[1]),
    isoDay: parseInt(e3[2]),
    ...organizeAnnotationParts(e3[3])
  }))(n2) : void 0;
}
function parseOffsetNanoMaybe(e2, n2) {
  const t2 = Ei.exec(e2);
  return t2 ? ((e3, n3) => {
    const t3 = e3[4] || e3[5];
    if (n3 && t3) {
      throw new RangeError(invalidSubstring(t3));
    }
    return ((e4) => {
      if (Math.abs(e4) >= Uo) {
        throw new RangeError(ho);
      }
      return e4;
    })((parseInt0(e3[2]) * zo + parseInt0(e3[3]) * Zo + parseInt0(e3[4]) * Ro + parseSubsecNano(e3[5] || "")) * parseSign(e3[1]));
  })(t2, n2) : void 0;
}
function organizeIsoYearParts(e2) {
  const n2 = parseSign(e2[1]), t2 = parseInt(e2[2] || e2[3]);
  if (n2 < 0 && !t2) {
    throw new RangeError(invalidSubstring(-0));
  }
  return n2 * t2;
}
function organizeTimeParts(e2) {
  const n2 = parseInt0(e2[3]);
  return {
    ...nanoToIsoTimeAndDay(parseSubsecNano(e2[4] || ""))[0],
    isoHour: parseInt0(e2[1]),
    isoMinute: parseInt0(e2[2]),
    isoSecond: 60 === n2 ? 59 : n2
  };
}
function organizeAnnotationParts(e2) {
  let n2, t2;
  const o2 = [];
  if (e2.replace(Si, (e3, r2, i2) => {
    const a2 = Boolean(r2), [s2, c2] = i2.split("=").reverse();
    if (c2) {
      if ("u-ca" === c2) {
        o2.push(s2), n2 || (n2 = a2);
      } else if (a2 || /[A-Z]/.test(c2)) {
        throw new RangeError(invalidSubstring(e3));
      }
    } else {
      if (t2) {
        throw new RangeError(invalidSubstring(e3));
      }
      t2 = s2;
    }
    return "";
  }), o2.length > 1 && n2) {
    throw new RangeError(invalidSubstring(e2));
  }
  return {
    timeZone: t2,
    calendar: o2[0] || l
  };
}
function parseSubsecNano(e2) {
  return parseInt(e2.padEnd(9, "0"));
}
function createRegExp(e2) {
  return new RegExp(`^${e2}$`, "i");
}
function parseSign(e2) {
  return e2 && "+" !== e2 ? -1 : 1;
}
function parseInt0(e2) {
  return void 0 === e2 ? 0 : parseInt(e2);
}
function Ze(e2) {
  return M(m(e2));
}
function M(e2) {
  const n2 = getTimeZoneEssence(e2);
  return "number" == typeof n2 ? Se(n2) : n2 ? ((e3) => {
    if (Oi.test(e3)) {
      throw new RangeError(F(e3));
    }
    if (bi.test(e3)) {
      throw new RangeError(po);
    }
    return e3.toLowerCase().split("/").map((e4, n3) => (e4.length <= 3 || /\d/.test(e4)) && !/etc|yap/.test(e4) ? e4.toUpperCase() : e4.replace(/baja|dumont|[a-z]+/g, (e5, t2) => e5.length <= 2 && !n3 || "in" === e5 || "chat" === e5 ? e5.toUpperCase() : e5.length > 2 || !t2 ? capitalize(e5).replace(/island|noronha|murdo|rivadavia|urville/, capitalize) : e5)).join("/");
  })(e2) : si;
}
function getTimeZoneAtomic(e2) {
  const n2 = getTimeZoneEssence(e2);
  return "number" == typeof n2 ? n2 : n2 ? n2.resolvedOptions().timeZone : si;
}
function getTimeZoneEssence(e2) {
  const n2 = parseOffsetNanoMaybe(e2 = e2.toUpperCase(), 1);
  return void 0 !== n2 ? n2 : e2 !== si ? wi(e2) : void 0;
}
function Ke(e2, n2) {
  return compareBigNanos(e2.epochNanoseconds, n2.epochNanoseconds);
}
function Be(e2, n2) {
  return compareBigNanos(e2.epochNanoseconds, n2.epochNanoseconds);
}
function K(e2, n2, t2, o2, r2, i2) {
  const a2 = e2(normalizeOptions(i2).relativeTo), s2 = Math.max(getMaxDurationUnit(o2), getMaxDurationUnit(r2));
  if (allPropsEqual(p, o2, r2)) {
    return 0;
  }
  if (isUniformUnit(s2, a2)) {
    return compareBigNanos(durationFieldsToBigNano(o2), durationFieldsToBigNano(r2));
  }
  if (!a2) {
    throw new RangeError(yo);
  }
  const [c2, u2, f2] = createMarkerSystem(n2, t2, a2), l2 = createMarkerToEpochNano(f2), d2 = createMoveMarker(f2);
  return compareBigNanos(l2(d2(u2, c2, o2)), l2(d2(u2, c2, r2)));
}
function Yt(e2, n2) {
  return te(e2, n2) || Dt(e2, n2);
}
function te(e2, n2) {
  return compareNumbers(isoToEpochMilli(e2), isoToEpochMilli(n2));
}
function Dt(e2, n2) {
  return compareNumbers(isoTimeFieldsToNano(e2), isoTimeFieldsToNano(n2));
}
function Ve(e2, n2) {
  return !Ke(e2, n2);
}
function Ce(e2, n2) {
  return !Be(e2, n2) && !!isTimeZoneIdsEqual(e2.timeZone, n2.timeZone) && e2.calendar === n2.calendar;
}
function Ct(e2, n2) {
  return !Yt(e2, n2) && e2.calendar === n2.calendar;
}
function re(e2, n2) {
  return !te(e2, n2) && e2.calendar === n2.calendar;
}
function $t(e2, n2) {
  return !te(e2, n2) && e2.calendar === n2.calendar;
}
function Lt(e2, n2) {
  return !te(e2, n2) && e2.calendar === n2.calendar;
}
function st(e2, n2) {
  return !Dt(e2, n2);
}
function isTimeZoneIdsEqual(e2, n2) {
  if (e2 === n2) {
    return 1;
  }
  try {
    return getTimeZoneAtomic(e2) === getTimeZoneAtomic(n2);
  } catch (e3) {
  }
}
function Ee(e2, n2, t2, o2) {
  const r2 = refineDiffOptions(e2, o2, 3, 5), i2 = diffEpochNanos(n2.epochNanoseconds, t2.epochNanoseconds, ...r2);
  return Oe(e2 ? negateDurationFields(i2) : i2);
}
function we(e2, n2, t2, o2, r2, i2) {
  const a2 = getCommonCalendarId(o2.calendar, r2.calendar), [s2, c2, u2, f2] = refineDiffOptions(t2, i2, 5), l2 = o2.epochNanoseconds, d2 = r2.epochNanoseconds, m2 = compareBigNanos(d2, l2);
  let p2;
  if (m2) {
    if (s2 < 6) {
      p2 = diffEpochNanos(l2, d2, s2, c2, u2, f2);
    } else {
      const t3 = n2(((e3, n3) => {
        if (!isTimeZoneIdsEqual(e3, n3)) {
          throw new RangeError(mo);
        }
        return e3;
      })(o2.timeZone, r2.timeZone)), l3 = e2(a2);
      p2 = diffZonedEpochsBig(l3, t3, o2, r2, m2, s2, i2), p2 = roundRelativeDuration(p2, d2, s2, c2, u2, f2, l3, o2, extractEpochNano, Pt(moveZonedEpochs, t3));
    }
  } else {
    p2 = pr;
  }
  return Oe(t2 ? negateDurationFields(p2) : p2);
}
function It(e2, n2, t2, o2, r2) {
  const i2 = getCommonCalendarId(t2.calendar, o2.calendar), [a2, s2, c2, u2] = refineDiffOptions(n2, r2, 6), f2 = isoToEpochNano(t2), l2 = isoToEpochNano(o2), d2 = compareBigNanos(l2, f2);
  let m2;
  if (d2) {
    if (a2 <= 6) {
      m2 = diffEpochNanos(f2, l2, a2, s2, c2, u2);
    } else {
      const n3 = e2(i2);
      m2 = diffDateTimesBig(n3, t2, o2, d2, a2, r2), m2 = roundRelativeDuration(m2, l2, a2, s2, c2, u2, n3, t2, isoToEpochNano, moveDateTime);
    }
  } else {
    m2 = pr;
  }
  return Oe(n2 ? negateDurationFields(m2) : m2);
}
function oe(e2, n2, t2, o2, r2) {
  const i2 = getCommonCalendarId(t2.calendar, o2.calendar);
  return diffDateLike(n2, () => e2(i2), t2, o2, ...refineDiffOptions(n2, r2, 6, 9, 6));
}
function zt(e2, n2, t2, o2, r2) {
  const i2 = getCommonCalendarId(t2.calendar, o2.calendar), a2 = refineDiffOptions(n2, r2, 9, 9, 8), s2 = e2(i2), c2 = moveToDayOfMonthUnsafe(s2, t2), u2 = moveToDayOfMonthUnsafe(s2, o2);
  return c2.isoYear === u2.isoYear && c2.isoMonth === u2.isoMonth && c2.isoDay === u2.isoDay ? Oe(pr) : diffDateLike(n2, () => s2, checkIsoDateInBounds(c2), checkIsoDateInBounds(u2), ...a2, 8);
}
function diffDateLike(e2, n2, t2, o2, r2, i2, a2, s2, c2 = 6) {
  const u2 = isoToEpochNano(t2), f2 = isoToEpochNano(o2);
  if (void 0 === u2 || void 0 === f2) {
    throw new RangeError(Io);
  }
  let l2;
  if (compareBigNanos(f2, u2)) {
    if (6 === r2) {
      l2 = diffEpochNanos(u2, f2, r2, i2, a2, s2);
    } else {
      const e3 = n2();
      l2 = e3.N(t2, o2, r2), i2 === c2 && 1 === a2 || (l2 = roundRelativeDuration(l2, f2, r2, i2, a2, s2, e3, t2, isoToEpochNano, moveDate));
    }
  } else {
    l2 = pr;
  }
  return Oe(e2 ? negateDurationFields(l2) : l2);
}
function it(e2, n2, t2, o2) {
  const [r2, i2, a2, s2] = refineDiffOptions(e2, o2, 5, 5), c2 = roundByInc(diffTimes(n2, t2), computeNanoInc(i2, a2), s2), u2 = {
    ...pr,
    ...nanoToDurationTimeFields(c2, r2)
  };
  return Oe(e2 ? negateDurationFields(u2) : u2);
}
function diffZonedEpochsExact(e2, n2, t2, o2, r2, i2) {
  const a2 = compareBigNanos(o2.epochNanoseconds, t2.epochNanoseconds);
  return a2 ? r2 < 6 ? diffEpochNanosExact(t2.epochNanoseconds, o2.epochNanoseconds, r2) : diffZonedEpochsBig(n2, e2, t2, o2, a2, r2, i2) : pr;
}
function diffDateTimesExact(e2, n2, t2, o2, r2) {
  const i2 = isoToEpochNano(n2), a2 = isoToEpochNano(t2), s2 = compareBigNanos(a2, i2);
  return s2 ? o2 <= 6 ? diffEpochNanosExact(i2, a2, o2) : diffDateTimesBig(e2, n2, t2, s2, o2, r2) : pr;
}
function diffZonedEpochsBig(e2, n2, t2, o2, r2, i2, a2) {
  const [s2, c2, u2] = ((e3, n3, t3, o3) => {
    function updateMid() {
      return f3 = {
        ...moveByDays(a3, c3++ * -o3),
        ...i3
      }, l3 = getSingleInstantFor(e3, f3), compareBigNanos(s3, l3) === -o3;
    }
    const r3 = he(n3, e3), i3 = nn(w, r3), a3 = he(t3, e3), s3 = t3.epochNanoseconds;
    let c3 = 0;
    const u3 = diffTimes(r3, a3);
    let f3, l3;
    if (Math.sign(u3) === -o3 && c3++, updateMid() && (-1 === o3 || updateMid())) {
      throw new RangeError(fo);
    }
    const d2 = bigNanoToNumber(diffBigNanos(l3, s3));
    return [r3, f3, d2];
  })(n2, t2, o2, r2);
  var f2, l2;
  return {
    ...6 === i2 ? (f2 = s2, l2 = c2, {
      ...pr,
      days: diffDays(f2, l2)
    }) : e2.N(s2, c2, i2, a2),
    ...nanoToDurationTimeFields(u2)
  };
}
function diffDateTimesBig(e2, n2, t2, o2, r2, i2) {
  const [a2, s2, c2] = ((e3, n3, t3) => {
    let o3 = n3, r3 = diffTimes(e3, n3);
    return Math.sign(r3) === -t3 && (o3 = moveByDays(n3, -t3), r3 += Uo * t3), [e3, o3, r3];
  })(n2, t2, o2);
  return {
    ...e2.N(a2, s2, r2, i2),
    ...nanoToDurationTimeFields(c2)
  };
}
function diffEpochNanos(e2, n2, t2, o2, r2, i2) {
  return {
    ...pr,
    ...nanoToDurationDayTimeFields(roundBigNano(diffBigNanos(e2, n2), o2, r2, i2), t2)
  };
}
function diffEpochNanosExact(e2, n2, t2) {
  return {
    ...pr,
    ...nanoToDurationDayTimeFields(diffBigNanos(e2, n2), t2)
  };
}
function diffDays(e2, n2) {
  return diffEpochMilliByDay(isoToEpochMilli(e2), isoToEpochMilli(n2));
}
function diffEpochMilliByDay(e2, n2) {
  return Math.trunc((n2 - e2) / ko);
}
function diffTimes(e2, n2) {
  return isoTimeFieldsToNano(n2) - isoTimeFieldsToNano(e2);
}
function getCommonCalendarId(e2, n2) {
  if (e2 !== n2) {
    throw new RangeError(lo);
  }
  return e2;
}
function computeNativeWeekOfYear(e2) {
  return this.m(e2)[0];
}
function computeNativeYearOfWeek(e2) {
  return this.m(e2)[1];
}
function computeNativeDayOfYear(e2) {
  const [n2] = this.v(e2);
  return diffEpochMilliByDay(this.p(n2), isoToEpochMilli(e2)) + 1;
}
function parseMonthCode(e2) {
  const n2 = Bi.exec(e2);
  if (!n2) {
    throw new RangeError(invalidMonthCode(e2));
  }
  return [parseInt(n2[1]), Boolean(n2[2])];
}
function formatMonthCode(e2, n2) {
  return "M" + bo(e2) + (n2 ? "L" : "");
}
function monthCodeNumberToMonth(e2, n2, t2) {
  return e2 + (n2 || t2 && e2 >= t2 ? 1 : 0);
}
function monthToMonthCodeNumber(e2, n2) {
  return e2 - (n2 && e2 >= n2 ? 1 : 0);
}
function eraYearToYear(e2, n2) {
  return (n2 + e2) * (Math.sign(n2) || 1) || 0;
}
function getCalendarEraOrigins(e2) {
  return ir[getCalendarIdBase(e2)];
}
function getCalendarLeapMonthMeta(e2) {
  return sr[getCalendarIdBase(e2)];
}
function getCalendarIdBase(e2) {
  return computeCalendarIdBase(e2.id || l);
}
function createIntlCalendar(e2) {
  function epochMilliToIntlFields(e3) {
    return ((e4, n3) => ({
      ...parseIntlYear(e4, n3),
      o: e4.month,
      day: parseInt(e4.day)
    }))(hashIntlFormatParts(n2, e3), t2);
  }
  const n2 = Ci(e2), t2 = computeCalendarIdBase(e2);
  return {
    id: e2,
    h: createIntlFieldCache(epochMilliToIntlFields),
    l: createIntlYearDataCache(epochMilliToIntlFields)
  };
}
function createIntlFieldCache(e2) {
  return on((n2) => {
    const t2 = isoToEpochMilli(n2);
    return e2(t2);
  }, WeakMap);
}
function createIntlYearDataCache(e2) {
  const n2 = e2(0).year - Or;
  return on((t2) => {
    let o2, r2 = isoArgsToEpochMilli(t2 - n2), i2 = 0;
    const a2 = [], s2 = [];
    do {
      r2 += 400 * ko;
    } while ((o2 = e2(r2)).year <= t2);
    do {
      if (r2 += (1 - o2.day) * ko, o2.year === t2 && (a2.push(r2), s2.push(o2.o)), r2 -= ko, ++i2 > 100 || r2 < -Pr) {
        throw new RangeError(fo);
      }
    } while ((o2 = e2(r2)).year >= t2);
    return {
      i: a2.reverse(),
      u: Fo(s2.reverse())
    };
  });
}
function parseIntlYear(e2, n2) {
  let t2, o2, r2 = parseIntlPartsYear(e2);
  if (e2.era) {
    const i2 = ir[n2], a2 = ar[n2] || {};
    void 0 !== i2 && (t2 = "islamic" === n2 ? "ah" : e2.era.normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), "bc" === t2 || "b" === t2 ? t2 = "bce" : "ad" === t2 || "a" === t2 ? t2 = "ce" : "beforeroc" === t2 && (t2 = "broc"), t2 = a2[t2] || t2, o2 = r2, r2 = eraYearToYear(o2, i2[t2] || 0));
  }
  return {
    era: t2,
    eraYear: o2,
    year: r2
  };
}
function parseIntlPartsYear(e2) {
  return parseInt(e2.relatedYear || e2.year);
}
function computeIntlDateParts(e2) {
  const { year: n2, o: t2, day: o2 } = this.h(e2), { u: r2 } = this.l(n2);
  return [n2, r2[t2] + 1, o2];
}
function computeIntlEpochMilli(e2, n2 = 1, t2 = 1) {
  return this.l(e2).i[n2 - 1] + (t2 - 1) * ko;
}
function computeIntlMonthCodeParts(e2, n2) {
  const t2 = computeIntlLeapMonth.call(this, e2);
  return [monthToMonthCodeNumber(n2, t2), t2 === n2];
}
function computeIntlLeapMonth(e2) {
  const n2 = queryMonthStrings(this, e2), t2 = queryMonthStrings(this, e2 - 1), o2 = n2.length;
  if (o2 > t2.length) {
    const e3 = getCalendarLeapMonthMeta(this);
    if (e3 < 0) {
      return -e3;
    }
    for (let e4 = 0; e4 < o2; e4++) {
      if (n2[e4] !== t2[e4]) {
        return e4 + 1;
      }
    }
  }
}
function computeIntlDaysInYear(e2) {
  return diffEpochMilliByDay(computeIntlEpochMilli.call(this, e2), computeIntlEpochMilli.call(this, e2 + 1));
}
function computeIntlDaysInMonth(e2, n2) {
  const { i: t2 } = this.l(e2);
  let o2 = n2 + 1, r2 = t2;
  return o2 > t2.length && (o2 = 1, r2 = this.l(e2 + 1).i), diffEpochMilliByDay(t2[n2 - 1], r2[o2 - 1]);
}
function computeIntlMonthsInYear(e2) {
  return this.l(e2).i.length;
}
function computeIntlEraParts(e2) {
  const n2 = this.h(e2);
  return [n2.era, n2.eraYear];
}
function queryMonthStrings(e2, n2) {
  return Object.keys(e2.l(n2).u);
}
function Mt(e2) {
  return u(m(e2));
}
function u(e2) {
  if ((e2 = e2.toLowerCase()) !== l && e2 !== or) {
    const n2 = Ci(e2).resolvedOptions().calendar;
    if (computeCalendarIdBase(e2) !== computeCalendarIdBase(n2)) {
      throw new RangeError(c(e2));
    }
    return n2;
  }
  return e2;
}
function computeCalendarIdBase(e2) {
  return "islamicc" === e2 && (e2 = "islamic"), e2.split("-")[0];
}
function createNativeOpsCreator(e2, n2) {
  return (t2) => t2 === l ? e2 : t2 === or || t2 === rr ? Object.assign(Object.create(e2), {
    id: t2
  }) : Object.assign(Object.create(n2), ki(t2));
}
function $(e2, n2, t2, o2) {
  const r2 = refineCalendarFields(t2, o2, Xo, [], xo);
  if (void 0 !== r2.timeZone) {
    const o3 = t2.F(r2), i2 = refineTimeBag(r2), a2 = e2(r2.timeZone);
    return {
      epochNanoseconds: getMatchingInstantFor(n2(a2), {
        ...o3,
        ...i2
      }, void 0 !== r2.offset ? parseOffsetNano(r2.offset) : void 0),
      timeZone: a2
    };
  }
  return {
    ...t2.F(r2),
    ...Nt
  };
}
function Ne(e2, n2, t2, o2, r2, i2) {
  const a2 = refineCalendarFields(t2, r2, Xo, jo, xo), s2 = e2(a2.timeZone), [c2, u2, f2] = je(i2), l2 = t2.F(a2, fabricateOverflowOptions(c2)), d2 = refineTimeBag(a2, c2);
  return _e(getMatchingInstantFor(n2(s2), {
    ...l2,
    ...d2
  }, void 0 !== a2.offset ? parseOffsetNano(a2.offset) : void 0, u2, f2), s2, o2);
}
function At(e2, n2, t2) {
  const o2 = refineCalendarFields(e2, n2, Xo, [], O), r2 = mt(t2);
  return jt(checkIsoDateTimeInBounds({
    ...e2.F(o2, fabricateOverflowOptions(r2)),
    ...refineTimeBag(o2, r2)
  }));
}
function me(e2, n2, t2, o2 = []) {
  const r2 = refineCalendarFields(e2, n2, Xo, o2);
  return e2.F(r2, t2);
}
function Xt(e2, n2, t2, o2) {
  const r2 = refineCalendarFields(e2, n2, Ko, o2);
  return e2.K(r2, t2);
}
function Rt(e2, n2, t2, o2) {
  const r2 = refineCalendarFields(e2, t2, Xo, Jo);
  return n2 && void 0 !== r2.month && void 0 === r2.monthCode && void 0 === r2.year && (r2.year = Br), e2._(r2, o2);
}
function Tt(e2, n2) {
  return St(refineTimeBag(refineFields(e2, qo, [], 1), mt(n2)));
}
function q(e2) {
  const n2 = refineFields(e2, ur);
  return Oe(checkDurationUnits({
    ...pr,
    ...n2
  }));
}
function refineCalendarFields(e2, n2, t2, o2 = [], r2 = []) {
  return refineFields(n2, [...e2.fields(t2), ...r2].sort(), o2);
}
function refineFields(e2, n2, t2, o2 = !t2) {
  const r2 = {};
  let i2, a2 = 0;
  for (const o3 of n2) {
    if (o3 === i2) {
      throw new RangeError(duplicateFields(o3));
    }
    if ("constructor" === o3 || "__proto__" === o3) {
      throw new RangeError(forbiddenField(o3));
    }
    let n3 = e2[o3];
    if (void 0 !== n3) {
      a2 = 1, Li[o3] && (n3 = Li[o3](n3, o3)), r2[o3] = n3;
    } else if (t2) {
      if (t2.includes(o3)) {
        throw new TypeError(missingField(o3));
      }
      r2[o3] = tr[o3];
    }
    i2 = o3;
  }
  if (o2 && !a2) {
    throw new TypeError(noValidFields(n2));
  }
  return r2;
}
function refineTimeBag(e2, n2) {
  return constrainIsoTimeFields(xi({
    ...tr,
    ...e2
  }), n2);
}
function De(e2, n2, t2, o2, r2) {
  const { calendar: i2, timeZone: a2 } = t2, s2 = e2(i2), c2 = n2(a2), u2 = [...s2.fields(Xo), ...Lo].sort(), f2 = ((e3) => {
    const n3 = he(e3, L), t3 = Se(n3.offsetNanoseconds), o3 = ji(e3.calendar), [r3, i3, a3] = o3.v(n3), [s3, c3] = o3.q(r3, i3), u3 = formatMonthCode(s3, c3);
    return {
      ...$i(n3),
      year: r3,
      monthCode: u3,
      day: a3,
      offset: t3
    };
  })(t2), l2 = refineFields(o2, u2), d2 = s2.k(f2, l2), m2 = {
    ...f2,
    ...l2
  }, [p2, h2, g2] = je(r2, 2);
  return _e(getMatchingInstantFor(c2, {
    ...s2.F(d2, fabricateOverflowOptions(p2)),
    ...constrainIsoTimeFields(xi(m2), p2)
  }, parseOffsetNano(m2.offset), h2, g2), a2, i2);
}
function gt(e2, n2, t2, o2) {
  const r2 = e2(n2.calendar), i2 = [...r2.fields(Xo), ...O].sort(), a2 = {
    ...computeDateEssentials(s2 = n2),
    hour: s2.isoHour,
    minute: s2.isoMinute,
    second: s2.isoSecond,
    millisecond: s2.isoMillisecond,
    microsecond: s2.isoMicrosecond,
    nanosecond: s2.isoNanosecond
  };
  var s2;
  const c2 = refineFields(t2, i2), u2 = mt(o2), f2 = r2.k(a2, c2), l2 = {
    ...a2,
    ...c2
  };
  return jt(checkIsoDateTimeInBounds({
    ...r2.F(f2, fabricateOverflowOptions(u2)),
    ...constrainIsoTimeFields(xi(l2), u2)
  }));
}
function ee(e2, n2, t2, o2) {
  const r2 = e2(n2.calendar), i2 = r2.fields(Xo).sort(), a2 = computeDateEssentials(n2), s2 = refineFields(t2, i2), c2 = r2.k(a2, s2);
  return r2.F(c2, o2);
}
function Wt(e2, n2, t2, o2) {
  const r2 = e2(n2.calendar), i2 = r2.fields(Ko).sort(), a2 = ((e3) => {
    const n3 = ji(e3.calendar), [t3, o3] = n3.v(e3), [r3, i3] = n3.q(t3, o3);
    return {
      year: t3,
      monthCode: formatMonthCode(r3, i3)
    };
  })(n2), s2 = refineFields(t2, i2), c2 = r2.k(a2, s2);
  return r2.K(c2, o2);
}
function Et(e2, n2, t2, o2) {
  const r2 = e2(n2.calendar), i2 = r2.fields(Xo).sort(), a2 = ((e3) => {
    const n3 = ji(e3.calendar), [t3, o3, r3] = n3.v(e3), [i3, a3] = n3.q(t3, o3);
    return {
      monthCode: formatMonthCode(i3, a3),
      day: r3
    };
  })(n2), s2 = refineFields(t2, i2), c2 = r2.k(a2, s2);
  return r2._(c2, o2);
}
function rt(e2, n2, t2) {
  return St(((e3, n3, t3) => refineTimeBag({
    ...nn(qo, e3),
    ...refineFields(n3, qo)
  }, mt(t3)))(e2, n2, t2));
}
function A(e2, n2) {
  return Oe((t2 = e2, o2 = n2, checkDurationUnits({
    ...t2,
    ...refineFields(o2, ur)
  })));
  var t2, o2;
}
function convertToIso(e2, n2, t2, o2, r2) {
  n2 = nn(t2 = e2.fields(t2), n2), o2 = refineFields(o2, r2 = e2.fields(r2), []);
  let i2 = e2.k(n2, o2);
  return i2 = refineFields(i2, [...t2, ...r2].sort(), []), e2.F(i2);
}
function refineYear(e2, n2) {
  const t2 = getCalendarEraOrigins(e2), o2 = ar[e2.id || ""] || {};
  let { era: r2, eraYear: i2, year: a2 } = n2;
  if (void 0 !== r2 || void 0 !== i2) {
    if (void 0 === r2 || void 0 === i2) {
      throw new TypeError(io);
    }
    if (!t2) {
      throw new RangeError(ro);
    }
    const e3 = t2[o2[r2] || r2];
    if (void 0 === e3) {
      throw new RangeError(invalidEra(r2));
    }
    const n3 = eraYearToYear(i2, e3);
    if (void 0 !== a2 && a2 !== n3) {
      throw new RangeError(ao);
    }
    a2 = n3;
  } else if (void 0 === a2) {
    throw new TypeError(missingYear(t2));
  }
  return a2;
}
function refineMonth(e2, n2, t2, o2) {
  let { month: r2, monthCode: i2 } = n2;
  if (void 0 !== i2) {
    const n3 = ((e3, n4, t3, o3) => {
      const r3 = e3.L(t3), [i3, a2] = parseMonthCode(n4);
      let s2 = monthCodeNumberToMonth(i3, a2, r3);
      if (a2) {
        const n5 = getCalendarLeapMonthMeta(e3);
        if (void 0 === n5) {
          throw new RangeError(uo);
        }
        if (n5 > 0) {
          if (s2 > n5) {
            throw new RangeError(uo);
          }
          if (void 0 === r3) {
            if (1 === o3) {
              throw new RangeError(uo);
            }
            s2--;
          }
        } else {
          if (s2 !== -n5) {
            throw new RangeError(uo);
          }
          if (void 0 === r3 && 1 === o3) {
            throw new RangeError(uo);
          }
        }
      }
      return s2;
    })(e2, i2, t2, o2);
    if (void 0 !== r2 && r2 !== n3) {
      throw new RangeError(so);
    }
    r2 = n3, o2 = 1;
  } else if (void 0 === r2) {
    throw new TypeError(co);
  }
  return clampEntity("month", r2, 1, e2.B(t2), o2);
}
function refineDay(e2, n2, t2, o2, r2) {
  return clampProp(n2, "day", 1, e2.U(o2, t2), r2);
}
function spliceFields(e2, n2, t2, o2) {
  let r2 = 0;
  const i2 = [];
  for (const e3 of t2) {
    void 0 !== n2[e3] ? r2 = 1 : i2.push(e3);
  }
  if (Object.assign(e2, n2), r2) {
    for (const n3 of o2 || i2) {
      delete e2[n3];
    }
  }
}
function computeDateEssentials(e2) {
  const n2 = ji(e2.calendar), [t2, o2, r2] = n2.v(e2), [i2, a2] = n2.q(t2, o2);
  return {
    year: t2,
    monthCode: formatMonthCode(i2, a2),
    day: r2
  };
}
function qe(e2) {
  return xe(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(e2))));
}
function ye(e2, n2, t2, o2, r2 = l) {
  return _e(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(t2))), n2(o2), e2(r2));
}
function Zt(n2, t2, o2, r2, i2 = 0, a2 = 0, s2 = 0, c2 = 0, u2 = 0, f2 = 0, d2 = l) {
  return jt(checkIsoDateTimeInBounds(checkIsoDateTimeFields(e(toInteger, zipProps(Tr, [t2, o2, r2, i2, a2, s2, c2, u2, f2])))), n2(d2));
}
function ue(n2, t2, o2, r2, i2 = l) {
  return W(checkIsoDateInBounds(checkIsoDateFields(e(toInteger, {
    isoYear: t2,
    isoMonth: o2,
    isoDay: r2
  }))), n2(i2));
}
function Qt(e2, n2, t2, o2 = l, r2 = 1) {
  const i2 = toInteger(n2), a2 = toInteger(t2), s2 = e2(o2);
  return createPlainYearMonthSlots(checkIsoYearMonthInBounds(checkIsoDateFields({
    isoYear: i2,
    isoMonth: a2,
    isoDay: toInteger(r2)
  })), s2);
}
function kt(e2, n2, t2, o2 = l, r2 = Br) {
  const i2 = toInteger(n2), a2 = toInteger(t2), s2 = e2(o2);
  return createPlainMonthDaySlots(checkIsoDateInBounds(checkIsoDateFields({
    isoYear: toInteger(r2),
    isoMonth: i2,
    isoDay: a2
  })), s2);
}
function ut(n2 = 0, t2 = 0, o2 = 0, r2 = 0, i2 = 0, a2 = 0) {
  return St(constrainIsoTimeFields(e(toInteger, zipProps(w, [n2, t2, o2, r2, i2, a2])), 1));
}
function j(n2 = 0, t2 = 0, o2 = 0, r2 = 0, i2 = 0, a2 = 0, s2 = 0, c2 = 0, u2 = 0, f2 = 0) {
  return Oe(checkDurationUnits(e(toStrictInteger, zipProps(p, [n2, t2, o2, r2, i2, a2, s2, c2, u2, f2]))));
}
function Je(e2, n2, t2 = l) {
  return _e(e2.epochNanoseconds, n2, t2);
}
function be(e2) {
  return xe(e2.epochNanoseconds);
}
function yt(e2, n2) {
  return jt(he(n2, e2));
}
function fe(e2, n2) {
  return W(he(n2, e2));
}
function dt(e2, n2) {
  return St(he(n2, e2));
}
function bt(e2, n2, t2, o2) {
  const r2 = ((e3, n3, t3, o3) => {
    const r3 = ((e4) => ei(normalizeOptions(e4)))(o3);
    return getSingleInstantFor(e3(n3), t3, r3);
  })(e2, t2, n2, o2);
  return _e(checkEpochNanoInBounds(r2), t2, n2.calendar);
}
function ae(e2, n2, t2, o2, r2) {
  const i2 = e2(r2.timeZone), a2 = r2.plainTime, s2 = void 0 !== a2 ? n2(a2) : void 0, c2 = t2(i2);
  let u2;
  return u2 = s2 ? getSingleInstantFor(c2, {
    ...o2,
    ...s2
  }) : getStartOfDayInstantFor(c2, {
    ...o2,
    ...Nt
  }), _e(u2, i2, o2.calendar);
}
function ie(e2, n2 = Nt) {
  return jt(checkIsoDateTimeInBounds({
    ...e2,
    ...n2
  }));
}
function le(e2, n2, t2) {
  return ((e3, n3) => {
    const t3 = refineCalendarFields(e3, n3, Qo);
    return e3.K(t3, void 0);
  })(e2(n2.calendar), t2);
}
function se(e2, n2, t2) {
  return ((e3, n3) => {
    const t3 = refineCalendarFields(e3, n3, nr);
    return e3._(t3);
  })(e2(n2.calendar), t2);
}
function Ht(e2, n2, t2, o2) {
  return ((e3, n3, t3) => convertToIso(e3, n3, Qo, requireObjectLike(t3), Jo))(e2(n2.calendar), t2, o2);
}
function Vt(e2, n2, t2, o2) {
  return ((e3, n3, t3) => convertToIso(e3, n3, nr, requireObjectLike(t3), Go))(e2(n2.calendar), t2, o2);
}
function $e(e2) {
  return xe(checkEpochNanoInBounds(Ge(toStrictInteger(e2), Qe)));
}
function He(e2) {
  return xe(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(e2))));
}
function createOptionsTransformer(e2, n2, t2) {
  const o2 = new Set(t2);
  return (r2, i2) => {
    const a2 = t2 && hasAnyPropsByName(r2, t2);
    if (!hasAnyPropsByName(r2 = ((e3, n3) => {
      const t3 = {};
      for (const o3 in n3) {
        e3.has(o3) || (t3[o3] = n3[o3]);
      }
      return t3;
    })(o2, r2), e2)) {
      if (i2 && a2) {
        throw new TypeError("Invalid formatting options");
      }
      r2 = {
        ...n2,
        ...r2
      };
    }
    return t2 && (r2.timeZone = si, ["full", "long"].includes(r2.J) && (r2.J = "medium")), r2;
  };
}
function Q(e2, n2 = an, t2 = 0) {
  const [o2, , , r2] = e2;
  return (i2, a2 = Na, ...s2) => {
    const c2 = n2(r2 && r2(...s2), i2, a2, o2, t2), u2 = c2.resolvedOptions();
    return [c2, ...toEpochMillis(e2, u2, s2)];
  };
}
function an(e2, n2, t2, o2, r2) {
  if (t2 = o2(t2, r2), e2) {
    if (void 0 !== t2.timeZone) {
      throw new TypeError(So);
    }
    t2.timeZone = e2;
  }
  return new en(n2, t2);
}
function toEpochMillis(e2, n2, t2) {
  const [, o2, r2] = e2;
  return t2.map((e3) => (e3.calendar && ((e4, n3, t3) => {
    if ((t3 || e4 !== l) && e4 !== n3) {
      throw new RangeError(lo);
    }
  })(e3.calendar, n2.calendar, r2), o2(e3, n2)));
}
function ge(e2, n2, t2) {
  const o2 = n2.timeZone, r2 = e2(o2), i2 = {
    ...he(n2, r2),
    ...t2 || Nt
  };
  let a2;
  return a2 = t2 ? getMatchingInstantFor(r2, i2, i2.offsetNanoseconds, 2) : getStartOfDayInstantFor(r2, i2), _e(a2, o2, n2.calendar);
}
function Ot(e2, n2 = Nt) {
  return jt(checkIsoDateTimeInBounds({
    ...e2,
    ...n2
  }));
}
function pt(e2, n2) {
  return {
    ...e2,
    calendar: n2
  };
}
function Pe(e2, n2) {
  return {
    ...e2,
    timeZone: n2
  };
}
function tn(e2) {
  const n2 = Xe();
  return epochNanoToIso(n2, e2.R(n2));
}
function Xe() {
  return Ge(Date.now(), Qe);
}
function Ue() {
  return va || (va = new en().resolvedOptions().timeZone);
}
var expectedInteger = (e2, n2) => `Non-integer ${e2}: ${n2}`;
var expectedPositive = (e2, n2) => `Non-positive ${e2}: ${n2}`;
var expectedFinite = (e2, n2) => `Non-finite ${e2}: ${n2}`;
var forbiddenBigIntToNumber = (e2) => `Cannot convert bigint to ${e2}`;
var invalidBigInt = (e2) => `Invalid bigint: ${e2}`;
var no = "Cannot convert Symbol to string";
var oo = "Invalid object";
var numberOutOfRange = (e2, n2, t2, o2, r2) => r2 ? numberOutOfRange(e2, r2[n2], r2[t2], r2[o2]) : invalidEntity(e2, n2) + `; must be between ${t2}-${o2}`;
var invalidEntity = (e2, n2) => `Invalid ${e2}: ${n2}`;
var missingField = (e2) => `Missing ${e2}`;
var forbiddenField = (e2) => `Invalid field ${e2}`;
var duplicateFields = (e2) => `Duplicate field ${e2}`;
var noValidFields = (e2) => "No valid fields: " + e2.join();
var i = "Invalid bag";
var invalidChoice = (e2, n2, t2) => invalidEntity(e2, n2) + "; must be " + Object.keys(t2).join();
var b = "Cannot use valueOf";
var a = "Invalid calling context";
var ro = "Forbidden era/eraYear";
var io = "Mismatching era/eraYear";
var ao = "Mismatching year/eraYear";
var invalidEra = (e2) => `Invalid era: ${e2}`;
var missingYear = (e2) => "Missing year" + (e2 ? "/era/eraYear" : "");
var invalidMonthCode = (e2) => `Invalid monthCode: ${e2}`;
var so = "Mismatching month/monthCode";
var co = "Missing month/monthCode";
var uo = "Invalid leap month";
var fo = "Invalid protocol results";
var c = (e2) => invalidEntity("Calendar", e2);
var lo = "Mismatching Calendars";
var F = (e2) => invalidEntity("TimeZone", e2);
var mo = "Mismatching TimeZones";
var po = "Forbidden ICU TimeZone";
var ho = "Out-of-bounds offset";
var go = "Out-of-bounds TimeZone gap";
var Do = "Invalid TimeZone offset";
var To = "Ambiguous offset";
var Io = "Out-of-bounds date";
var Mo = "Out-of-bounds duration";
var No = "Cannot mix duration signs";
var yo = "Missing relativeTo";
var vo = "Cannot use large units";
var Po = "Required smallestUnit or largestUnit";
var Eo = "smallestUnit > largestUnit";
var failedParse = (e2) => `Cannot parse: ${e2}`;
var invalidSubstring = (e2) => `Invalid substring: ${e2}`;
var rn = (e2) => `Cannot format ${e2}`;
var ln = "Mismatching types for formatting";
var So = "Cannot specify TimeZone";
var Fo = Pt(g, (e2, n2) => n2);
var wo = Pt(g, (e2, n2, t2) => t2);
var bo = Pt(padNumber, 2);
var Oo = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
};
var Bo = Object.keys(Oo);
var ko = 864e5;
var Co = 1e3;
var Yo = 1e3;
var Qe = 1e6;
var Ro = 1e9;
var Zo = 6e10;
var zo = 36e11;
var Uo = 864e11;
var Ao = [1, Yo, Qe, Ro, Zo, zo, Uo];
var O = Bo.slice(0, 6);
var qo = sortStrings(O);
var Wo = ["offset"];
var jo = ["timeZone"];
var Lo = O.concat(Wo);
var xo = Lo.concat(jo);
var $o = ["era", "eraYear"];
var Ho = $o.concat(["year"]);
var Go = ["year"];
var Vo = ["monthCode"];
var _o = ["month"].concat(Vo);
var Jo = ["day"];
var Ko = _o.concat(Go);
var Qo = Vo.concat(Go);
var Xo = Jo.concat(Ko);
var er = Jo.concat(_o);
var nr = Jo.concat(Vo);
var tr = wo(O, 0);
var l = "iso8601";
var or = "gregory";
var rr = "japanese";
var ir = {
  [or]: {
    "gregory-inverse": -1,
    gregory: 0
  },
  [rr]: {
    "japanese-inverse": -1,
    japanese: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethiopic: {
    ethioaa: 0,
    ethiopic: 5500
  },
  coptic: {
    "coptic-inverse": -1,
    coptic: 0
  },
  roc: {
    "roc-inverse": -1,
    roc: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
};
var ar = {
  [or]: {
    bce: "gregory-inverse",
    ce: "gregory"
  },
  [rr]: {
    bce: "japanese-inverse",
    ce: "japanese"
  },
  ethiopic: {
    era0: "ethioaa",
    era1: "ethiopic"
  },
  coptic: {
    era0: "coptic-inverse",
    era1: "coptic"
  },
  roc: {
    broc: "roc-inverse",
    minguo: "roc"
  }
};
var sr = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
};
var m = Pt(requireType, "string");
var D = Pt(requireType, "boolean");
var cr = Pt(requireType, "number");
var p = Bo.map((e2) => e2 + "s");
var ur = sortStrings(p);
var fr = p.slice(0, 6);
var lr = p.slice(6);
var dr = lr.slice(1);
var mr = Fo(p);
var pr = wo(p, 0);
var hr = wo(fr, 0);
var gr = Pt(zeroOutProps, p);
var w = ["isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour"];
var Dr = ["isoDay", "isoMonth", "isoYear"];
var Tr = w.concat(Dr);
var Ir = sortStrings(Dr);
var Mr = sortStrings(w);
var Nr = sortStrings(Tr);
var Nt = wo(Mr, 0);
var yr = Pt(zeroOutProps, Tr);
var vr = 1e8;
var Pr = vr * ko;
var Er = [vr, 0];
var Sr = [-vr, 0];
var Fr = 275760;
var wr = -271821;
var en = Intl.DateTimeFormat;
var br = "en-GB";
var Or = 1970;
var Br = 1972;
var kr = 12;
var Cr = isoArgsToEpochMilli(1868, 9, 8);
var Yr = on(computeJapaneseEraParts, WeakMap);
var Rr = "smallestUnit";
var Zr = "unit";
var zr = "roundingIncrement";
var Ur = "fractionalSecondDigits";
var Ar = "relativeTo";
var qr = "direction";
var Wr = {
  constrain: 0,
  reject: 1
};
var jr = Object.keys(Wr);
var Lr = {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
};
var xr = {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
};
var $r = {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
};
var Hr = {
  auto: 0,
  never: 1,
  critical: 2
};
var Gr = {
  auto: 0,
  never: 1
};
var Vr = {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
};
var _r = {
  previous: -1,
  next: 1
};
var Jr = Pt(refineUnitOption, Rr);
var Kr = Pt(refineUnitOption, "largestUnit");
var Qr = Pt(refineUnitOption, Zr);
var Xr = Pt(refineChoiceOption, "overflow", Wr);
var ei = Pt(refineChoiceOption, "disambiguation", Lr);
var ni = Pt(refineChoiceOption, "offset", xr);
var ti = Pt(refineChoiceOption, "calendarName", $r);
var oi = Pt(refineChoiceOption, "timeZoneName", Hr);
var ri = Pt(refineChoiceOption, "offset", Gr);
var ii = Pt(refineChoiceOption, "roundingMode", Vr);
var Ut = "PlainYearMonth";
var qt = "PlainMonthDay";
var G = "PlainDate";
var x = "PlainDateTime";
var ft = "PlainTime";
var z = "ZonedDateTime";
var Re = "Instant";
var N = "Duration";
var ai = [Math.floor, (e2) => hasHalf(e2) ? Math.floor(e2) : Math.round(e2), Math.ceil, (e2) => hasHalf(e2) ? Math.ceil(e2) : Math.round(e2), Math.trunc, (e2) => hasHalf(e2) ? Math.trunc(e2) || 0 : Math.round(e2), (e2) => e2 < 0 ? Math.floor(e2) : Math.ceil(e2), (e2) => Math.sign(e2) * Math.round(Math.abs(e2)) || 0, (e2) => hasHalf(e2) ? (e2 = Math.trunc(e2) || 0) + e2 % 2 : Math.round(e2)];
var si = "UTC";
var ci = 5184e3;
var ui = isoArgsToEpochSec(1847);
var fi = isoArgsToEpochSec((/* @__PURE__ */ new Date()).getUTCFullYear() + 10);
var li = /0+$/;
var he = on(_zonedEpochSlotsToIso, WeakMap);
var di = 2 ** 32 - 1;
var L = on((e2) => {
  const n2 = getTimeZoneEssence(e2);
  return "object" == typeof n2 ? new IntlTimeZone(n2) : new FixedTimeZone(n2 || 0);
});
var FixedTimeZone = class {
  constructor(e2) {
    this.$ = e2;
  }
  R() {
    return this.$;
  }
  I(e2) {
    return ((e3) => {
      const n2 = isoToEpochNano({
        ...e3,
        ...Nt
      });
      if (!n2 || Math.abs(n2[0]) > 1e8) {
        throw new RangeError(Io);
      }
    })(e2), [isoToEpochNanoWithOffset(e2, this.$)];
  }
  O() {
  }
};
var IntlTimeZone = class {
  constructor(e2) {
    this.nn = ((e3) => {
      function getOffsetSec(e4) {
        const i2 = clampNumber(e4, o2, r2), [a2, s2] = computePeriod(i2), c2 = n2(a2), u2 = n2(s2);
        return c2 === u2 ? c2 : pinch(t2(a2, s2), c2, u2, e4);
      }
      function pinch(n3, t3, o3, r3) {
        let i2, a2;
        for (; (void 0 === r3 || void 0 === (i2 = r3 < n3[0] ? t3 : r3 >= n3[1] ? o3 : void 0)) && (a2 = n3[1] - n3[0]); ) {
          const t4 = n3[0] + Math.floor(a2 / 2);
          e3(t4) === o3 ? n3[1] = t4 : n3[0] = t4 + 1;
        }
        return i2;
      }
      const n2 = on(e3), t2 = on(createSplitTuple);
      let o2 = ui, r2 = fi;
      return {
        tn(e4) {
          const n3 = getOffsetSec(e4 - 86400), t3 = getOffsetSec(e4 + 86400), o3 = e4 - n3, r3 = e4 - t3;
          if (n3 === t3) {
            return [o3];
          }
          const i2 = getOffsetSec(o3);
          return i2 === getOffsetSec(r3) ? [e4 - i2] : n3 > t3 ? [o3, r3] : [];
        },
        rn: getOffsetSec,
        O(e4, i2) {
          const a2 = clampNumber(e4, o2, r2);
          let [s2, c2] = computePeriod(a2);
          const u2 = ci * i2, f2 = i2 < 0 ? () => c2 > o2 || (o2 = a2, 0) : () => s2 < r2 || (r2 = a2, 0);
          for (; f2(); ) {
            const o3 = n2(s2), r3 = n2(c2);
            if (o3 !== r3) {
              const n3 = t2(s2, c2);
              pinch(n3, o3, r3);
              const a3 = n3[0];
              if ((compareNumbers(a3, e4) || 1) === i2) {
                return a3;
              }
            }
            s2 += u2, c2 += u2;
          }
        }
      };
    })(/* @__PURE__ */ ((e3) => (n2) => {
      const t2 = hashIntlFormatParts(e3, n2 * Co);
      return isoArgsToEpochSec(parseIntlPartsYear(t2), parseInt(t2.month), parseInt(t2.day), parseInt(t2.hour), parseInt(t2.minute), parseInt(t2.second)) - n2;
    })(e2));
  }
  R(e2) {
    return this.nn.rn(((e3) => epochNanoToSecMod(e3)[0])(e2)) * Ro;
  }
  I(e2) {
    const [n2, t2] = [isoArgsToEpochSec((o2 = e2).isoYear, o2.isoMonth, o2.isoDay, o2.isoHour, o2.isoMinute, o2.isoSecond), o2.isoMillisecond * Qe + o2.isoMicrosecond * Yo + o2.isoNanosecond];
    var o2;
    return this.nn.tn(n2).map((e3) => checkEpochNanoInBounds(moveBigNano(Ge(e3, Ro), t2)));
  }
  O(e2, n2) {
    const [t2, o2] = epochNanoToSecMod(e2), r2 = this.nn.O(t2 + (n2 > 0 || o2 ? 1 : 0), n2);
    if (void 0 !== r2) {
      return Ge(r2, Ro);
    }
  }
};
var mi = "([+-])";
var pi = "(?:[.,](\\d{1,9}))?";
var hi = `(?:(?:${mi}(\\d{6}))|(\\d{4}))-?(\\d{2})`;
var gi = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})" + pi + ")?)?";
var Di = mi + gi;
var Ti = hi + "-?(\\d{2})(?:[T ]" + gi + "(Z|" + Di + ")?)?";
var Ii = "\\[(!?)([^\\]]*)\\]";
var Mi = `((?:${Ii}){0,9})`;
var Ni = createRegExp(hi + Mi);
var yi = createRegExp("(?:--)?(\\d{2})-?(\\d{2})" + Mi);
var vi = createRegExp(Ti + Mi);
var Pi = createRegExp("T?" + gi + "(?:" + Di + ")?" + Mi);
var Ei = createRegExp(Di);
var Si = new RegExp(Ii, "g");
var Fi = createRegExp(`${mi}?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)${pi}H)?(?:(\\d+)${pi}M)?(?:(\\d+)${pi}S)?)?`);
var wi = on((e2) => new en(br, {
  timeZone: e2,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
}));
var bi = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/;
var Oi = /[^\w\/:+-]+/;
var Bi = /^M(\d{2})(L?)$/;
var ki = on(createIntlCalendar);
var Ci = on((e2) => new en(br, {
  calendar: e2,
  timeZone: si,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
}));
var Yi = {
  P(e2, n2, t2) {
    const o2 = mt(t2);
    let r2, { years: i2, months: a2, weeks: s2, days: c2 } = n2;
    if (c2 += durationFieldsToBigNano(n2, 5)[0], i2 || a2) {
      r2 = ((e3, n3, t3, o3, r3) => {
        let [i3, a3, s3] = e3.v(n3);
        if (t3) {
          const [n4, o4] = e3.q(i3, a3);
          i3 += t3, a3 = monthCodeNumberToMonth(n4, o4, e3.L(i3)), a3 = clampEntity("month", a3, 1, e3.B(i3), r3);
        }
        return o3 && ([i3, a3] = e3.un(i3, a3, o3)), s3 = clampEntity("day", s3, 1, e3.U(i3, a3), r3), e3.p(i3, a3, s3);
      })(this, e2, i2, a2, o2);
    } else {
      if (!s2 && !c2) {
        return e2;
      }
      r2 = isoToEpochMilli(e2);
    }
    if (void 0 === r2) {
      throw new RangeError(Io);
    }
    return r2 += (7 * s2 + c2) * ko, checkIsoDateInBounds(epochMilliToIso(r2));
  },
  N(e2, n2, t2) {
    if (t2 <= 7) {
      let o3 = 0, r3 = diffDays({
        ...e2,
        ...Nt
      }, {
        ...n2,
        ...Nt
      });
      return 7 === t2 && ([o3, r3] = divModTrunc(r3, 7)), {
        ...pr,
        weeks: o3,
        days: r3
      };
    }
    const o2 = this.v(e2), r2 = this.v(n2);
    let [i2, a2, s2] = ((e3, n3, t3, o3, r3, i3, a3) => {
      let s3 = r3 - n3, c2 = i3 - t3, u2 = a3 - o3;
      if (s3 || c2) {
        const f2 = Math.sign(s3 || c2);
        let l2 = e3.U(r3, i3), d2 = 0;
        if (Math.sign(u2) === -f2) {
          const o4 = l2;
          [r3, i3] = e3.un(r3, i3, -f2), s3 = r3 - n3, c2 = i3 - t3, l2 = e3.U(r3, i3), d2 = f2 < 0 ? -o4 : l2;
        }
        if (u2 = a3 - Math.min(o3, l2) + d2, s3) {
          const [o4, a4] = e3.q(n3, t3), [u3, l3] = e3.q(r3, i3);
          if (c2 = u3 - o4 || Number(l3) - Number(a4), Math.sign(c2) === -f2) {
            const t4 = f2 < 0 && -e3.B(r3);
            s3 = (r3 -= f2) - n3, c2 = i3 - monthCodeNumberToMonth(o4, a4, e3.L(r3)) + (t4 || e3.B(r3));
          }
        }
      }
      return [s3, c2, u2];
    })(this, ...o2, ...r2);
    return 8 === t2 && (a2 += this.cn(i2, o2[0]), i2 = 0), {
      ...pr,
      years: i2,
      months: a2,
      days: s2
    };
  },
  F(e2, n2) {
    const t2 = mt(n2), o2 = refineYear(this, e2), r2 = refineMonth(this, e2, o2, t2), i2 = refineDay(this, e2, r2, o2, t2);
    return W(checkIsoDateInBounds(this.V(o2, r2, i2)), this.id || l);
  },
  K(e2, n2) {
    const t2 = mt(n2), o2 = refineYear(this, e2), r2 = refineMonth(this, e2, o2, t2);
    return createPlainYearMonthSlots(checkIsoYearMonthInBounds(this.V(o2, r2, 1)), this.id || l);
  },
  _(e2, n2) {
    const t2 = mt(n2);
    let o2, r2, i2, a2 = void 0 !== e2.eraYear || void 0 !== e2.year ? refineYear(this, e2) : void 0;
    const s2 = !this.id;
    if (void 0 === a2 && s2 && (a2 = Br), void 0 !== a2) {
      const n3 = refineMonth(this, e2, a2, t2);
      o2 = refineDay(this, e2, n3, a2, t2);
      const s3 = this.L(a2);
      r2 = monthToMonthCodeNumber(n3, s3), i2 = n3 === s3;
    } else {
      if (void 0 === e2.monthCode) {
        throw new TypeError(co);
      }
      if ([r2, i2] = parseMonthCode(e2.monthCode), this.id && this.id !== or && this.id !== rr) {
        if (this.id && "coptic" === computeCalendarIdBase(this.id) && 0 === t2) {
          const n3 = i2 || 13 !== r2 ? 30 : 6;
          o2 = e2.day, o2 = clampNumber(o2, 1, n3);
        } else if (this.id && "chinese" === computeCalendarIdBase(this.id) && 0 === t2) {
          const n3 = !i2 || 1 !== r2 && 9 !== r2 && 10 !== r2 && 11 !== r2 && 12 !== r2 ? 30 : 29;
          o2 = e2.day, o2 = clampNumber(o2, 1, n3);
        } else {
          o2 = e2.day;
        }
      } else {
        o2 = refineDay(this, e2, refineMonth(this, e2, Br, t2), Br, t2);
      }
    }
    const c2 = this.G(r2, i2, o2);
    if (!c2) {
      throw new RangeError("Cannot guess year");
    }
    const [u2, f2] = c2;
    return createPlainMonthDaySlots(checkIsoDateInBounds(this.V(u2, f2, o2)), this.id || l);
  },
  fields(e2) {
    return getCalendarEraOrigins(this) && e2.includes("year") ? [...e2, ...$o] : e2;
  },
  k(e2, n2) {
    const t2 = Object.assign(/* @__PURE__ */ Object.create(null), e2);
    return spliceFields(t2, n2, _o), getCalendarEraOrigins(this) && (spliceFields(t2, n2, Ho), this.id === rr && spliceFields(t2, n2, er, $o)), t2;
  },
  inLeapYear(e2) {
    const [n2] = this.v(e2);
    return this.sn(n2);
  },
  monthsInYear(e2) {
    const [n2] = this.v(e2);
    return this.B(n2);
  },
  daysInMonth(e2) {
    const [n2, t2] = this.v(e2);
    return this.U(n2, t2);
  },
  daysInYear(e2) {
    const [n2] = this.v(e2);
    return this.fn(n2);
  },
  dayOfYear: computeNativeDayOfYear,
  era(e2) {
    return this.hn(e2)[0];
  },
  eraYear(e2) {
    return this.hn(e2)[1];
  },
  monthCode(e2) {
    const [n2, t2] = this.v(e2), [o2, r2] = this.q(n2, t2);
    return formatMonthCode(o2, r2);
  },
  dayOfWeek: computeIsoDayOfWeek,
  daysInWeek() {
    return 7;
  }
};
var Ri = {
  v: computeIsoDateParts,
  hn: computeIsoEraParts,
  q: computeIsoMonthCodeParts
};
var Zi = {
  dayOfYear: computeNativeDayOfYear,
  v: computeIsoDateParts,
  p: isoArgsToEpochMilli
};
var zi = Object.assign({}, Zi, {
  weekOfYear: computeNativeWeekOfYear,
  yearOfWeek: computeNativeYearOfWeek,
  m(e2) {
    function computeWeekShift(e3) {
      return (7 - e3 < n2 ? 7 : 0) - e3;
    }
    function computeWeeksInYear(e3) {
      const n3 = computeIsoDaysInYear(f2 + e3), t3 = e3 || 1, o3 = computeWeekShift(modFloor(a2 + n3 * t3, 7));
      return c2 = (n3 + (o3 - s2) * t3) / 7;
    }
    const n2 = this.id ? 1 : 4, t2 = computeIsoDayOfWeek(e2), o2 = this.dayOfYear(e2), r2 = modFloor(t2 - 1, 7), i2 = o2 - 1, a2 = modFloor(r2 - i2, 7), s2 = computeWeekShift(a2);
    let c2, u2 = Math.floor((i2 - s2) / 7) + 1, f2 = e2.isoYear;
    return u2 ? u2 > computeWeeksInYear(0) && (u2 = 1, f2++) : (u2 = computeWeeksInYear(-1), f2--), [u2, f2, c2];
  }
});
var Ui = Object.assign({}, Yi, zi, {
  v: computeIsoDateParts,
  hn: computeIsoEraParts,
  q: computeIsoMonthCodeParts,
  G(e2, n2) {
    if (!n2) {
      return [Br, e2];
    }
  },
  sn: computeIsoInLeapYear,
  L() {
  },
  B: computeIsoMonthsInYear,
  cn: (e2) => e2 * kr,
  U: computeIsoDaysInMonth,
  fn: computeIsoDaysInYear,
  V: (e2, n2, t2) => ({
    isoYear: e2,
    isoMonth: n2,
    isoDay: t2
  }),
  p: isoArgsToEpochMilli,
  un: (e2, n2, t2) => (e2 += divTrunc(t2, kr), (n2 += modTrunc(t2, kr)) < 1 ? (e2--, n2 += kr) : n2 > kr && (e2++, n2 -= kr), [e2, n2]),
  year(e2) {
    return e2.isoYear;
  },
  month(e2) {
    return e2.isoMonth;
  },
  day: (e2) => e2.isoDay
});
var Ai = {
  v: computeIntlDateParts,
  hn: computeIntlEraParts,
  q: computeIntlMonthCodeParts
};
var qi = {
  dayOfYear: computeNativeDayOfYear,
  v: computeIntlDateParts,
  p: computeIntlEpochMilli,
  weekOfYear: computeNativeWeekOfYear,
  yearOfWeek: computeNativeYearOfWeek,
  m() {
    return [];
  }
};
var Wi = Object.assign({}, Yi, qi, {
  v: computeIntlDateParts,
  hn: computeIntlEraParts,
  q: computeIntlMonthCodeParts,
  G(e2, n2, t2) {
    const o2 = this.id && "chinese" === computeCalendarIdBase(this.id) ? ((e3, n3, t3) => {
      if (n3) {
        switch (e3) {
          case 1:
            return 1651;
          case 2:
            return t3 < 30 ? 1947 : 1765;
          case 3:
            return t3 < 30 ? 1966 : 1955;
          case 4:
            return t3 < 30 ? 1963 : 1944;
          case 5:
            return t3 < 30 ? 1971 : 1952;
          case 6:
            return t3 < 30 ? 1960 : 1941;
          case 7:
            return t3 < 30 ? 1968 : 1938;
          case 8:
            return t3 < 30 ? 1957 : 1718;
          case 9:
            return 1832;
          case 10:
            return 1870;
          case 11:
            return 1814;
          case 12:
            return 1890;
        }
      }
      return 1972;
    })(e2, n2, t2) : Br;
    let [r2, i2, a2] = computeIntlDateParts.call(this, {
      isoYear: o2,
      isoMonth: kr,
      isoDay: 31
    });
    const s2 = computeIntlLeapMonth.call(this, r2), c2 = i2 === s2;
    1 === (compareNumbers(e2, monthToMonthCodeNumber(i2, s2)) || compareNumbers(Number(n2), Number(c2)) || compareNumbers(t2, a2)) && r2--;
    for (let o3 = 0; o3 < 100; o3++) {
      const i3 = r2 - o3, a3 = computeIntlLeapMonth.call(this, i3), s3 = monthCodeNumberToMonth(e2, n2, a3);
      if (n2 === (s3 === a3) && t2 <= computeIntlDaysInMonth.call(this, i3, s3)) {
        return [i3, s3];
      }
    }
  },
  sn(e2) {
    const n2 = computeIntlDaysInYear.call(this, e2);
    return n2 > computeIntlDaysInYear.call(this, e2 - 1) && n2 > computeIntlDaysInYear.call(this, e2 + 1);
  },
  L: computeIntlLeapMonth,
  B: computeIntlMonthsInYear,
  cn(e2, n2) {
    const t2 = n2 + e2, o2 = Math.sign(e2), r2 = o2 < 0 ? -1 : 0;
    let i2 = 0;
    for (let e3 = n2; e3 !== t2; e3 += o2) {
      i2 += computeIntlMonthsInYear.call(this, e3 + r2);
    }
    return i2;
  },
  U: computeIntlDaysInMonth,
  fn: computeIntlDaysInYear,
  V(e2, n2, t2) {
    return epochMilliToIso(computeIntlEpochMilli.call(this, e2, n2, t2));
  },
  p: computeIntlEpochMilli,
  un(e2, n2, t2) {
    if (t2) {
      if (n2 += t2, !Number.isSafeInteger(n2)) {
        throw new RangeError(Io);
      }
      if (t2 < 0) {
        for (; n2 < 1; ) {
          n2 += computeIntlMonthsInYear.call(this, --e2);
        }
      } else {
        let t3;
        for (; n2 > (t3 = computeIntlMonthsInYear.call(this, e2)); ) {
          n2 -= t3, e2++;
        }
      }
    }
    return [e2, n2];
  },
  year(e2) {
    return this.h(e2).year;
  },
  month(e2) {
    const { year: n2, o: t2 } = this.h(e2), { u: o2 } = this.l(n2);
    return o2[t2] + 1;
  },
  day(e2) {
    return this.h(e2).day;
  }
});
var ji = createNativeOpsCreator(Ri, Ai);
var C = createNativeOpsCreator(Ui, Wi);
var Li = {
  ...{
    era: toStringViaPrimitive,
    eraYear: toInteger,
    year: toInteger,
    month: toPositiveInteger,
    monthCode(e2) {
      const n2 = toStringViaPrimitive(e2);
      return parseMonthCode(n2), n2;
    },
    day: toPositiveInteger
  },
  ...wo(O, toInteger),
  ...wo(p, toStrictInteger),
  offset(e2) {
    const n2 = toStringViaPrimitive(e2);
    return parseOffsetNano(n2), n2;
  }
};
var xi = Pt(remapProps, O, w);
var $i = Pt(remapProps, w, O);
var Hi = "numeric";
var Gi = ["timeZoneName"];
var Vi = {
  month: Hi,
  day: Hi
};
var _i = {
  year: Hi,
  month: Hi
};
var Ji = Object.assign({}, _i, {
  day: Hi
});
var Ki = {
  hour: Hi,
  minute: Hi,
  second: Hi
};
var Qi = Object.assign({}, Ji, Ki);
var Xi = Object.assign({}, Qi, {
  timeZoneName: "short"
});
var ea = Object.keys(_i);
var na = Object.keys(Vi);
var ta = Object.keys(Ji);
var oa = Object.keys(Ki);
var ra = ["dateStyle"];
var ia = ea.concat(ra);
var aa = na.concat(ra);
var sa = ta.concat(ra, ["weekday"]);
var ca = oa.concat(["dayPeriod", "timeStyle", "fractionalSecondDigits"]);
var ua = sa.concat(ca);
var fa = Gi.concat(ca);
var la = Gi.concat(sa);
var da = Gi.concat(["day", "weekday"], ca);
var ma = Gi.concat(["year", "weekday"], ca);
var pa = createOptionsTransformer(ua, Qi);
var ha = createOptionsTransformer(ua, Xi);
var ga = createOptionsTransformer(ua, Qi, Gi);
var Da = createOptionsTransformer(sa, Ji, fa);
var Ta = createOptionsTransformer(ca, Ki, la);
var Ia = createOptionsTransformer(ia, _i, da);
var Ma = createOptionsTransformer(aa, Vi, ma);
var Na = {};
var ya = new en(void 0, {
  calendar: l
}).resolvedOptions().calendar === l;
var U = [pa, I];
var ot = [ha, I, 0, (e2, n2) => {
  const t2 = e2.timeZone;
  if (n2 && n2.timeZone !== t2) {
    throw new RangeError(mo);
  }
  return t2;
}];
var X = [ga, isoToEpochMilli];
var _ = [Da, isoToEpochMilli];
var tt = [Ta, (e2) => isoTimeFieldsToNano(e2) / Qe];
var et = [Ia, isoToEpochMilli, ya];
var nt = [Ma, isoToEpochMilli, ya];
var va;

// node_modules/temporal-polyfill/chunks/classApi.js
function createSlotClass(i2, l2, s2, c2, u2) {
  function Class(...t2) {
    if (!(this instanceof Class)) {
      throw new TypeError(a);
    }
    un(this, l2(...t2));
  }
  function bindMethod(t2, e2) {
    return Object.defineProperties(function(...e3) {
      return t2.call(this, getSpecificSlots(this), ...e3);
    }, r(e2));
  }
  function getSpecificSlots(t2) {
    const e2 = cn(t2);
    if (!e2 || e2.branding !== i2) {
      throw new TypeError(a);
    }
    return e2;
  }
  return Object.defineProperties(Class.prototype, {
    ...t(e(bindMethod, s2)),
    ...n(e(bindMethod, c2)),
    ...o("Temporal." + i2)
  }), Object.defineProperties(Class, {
    ...n(u2),
    ...r(i2)
  }), [Class, (t2) => {
    const e2 = Object.create(Class.prototype);
    return un(e2, t2), e2;
  }, getSpecificSlots];
}
function rejectInvalidBag(t2) {
  if (cn(t2) || void 0 !== t2.calendar || void 0 !== t2.timeZone) {
    throw new TypeError(i);
  }
  return t2;
}
function getCalendarIdFromBag(t2) {
  return extractCalendarIdFromBag(t2) || l;
}
function extractCalendarIdFromBag(t2) {
  const { calendar: e2 } = t2;
  if (void 0 !== e2) {
    return refineCalendarArg(e2);
  }
}
function refineCalendarArg(t2) {
  if (s(t2)) {
    const { calendar: e2 } = cn(t2) || {};
    if (!e2) {
      throw new TypeError(c(t2));
    }
    return e2;
  }
  return ((t3) => u(f(m(t3))))(t2);
}
function createCalendarGetters(t2) {
  const e2 = {};
  for (const n2 in t2) {
    e2[n2] = (t3) => {
      const { calendar: e3 } = t3;
      return C(e3)[n2](t3);
    };
  }
  return e2;
}
function neverValueOf() {
  throw new TypeError(b);
}
function refineTimeZoneArg(t2) {
  if (s(t2)) {
    const { timeZone: e2 } = cn(t2) || {};
    if (!e2) {
      throw new TypeError(F(t2));
    }
    return e2;
  }
  return ((t3) => M(Z(m(t3))))(t2);
}
function toDurationSlots(t2) {
  if (s(t2)) {
    const e2 = cn(t2);
    return e2 && e2.branding === N ? e2 : q(t2);
  }
  return R(t2);
}
function refinePublicRelativeTo(t2) {
  if (void 0 !== t2) {
    if (s(t2)) {
      const e2 = cn(t2) || {};
      switch (e2.branding) {
        case z:
        case G:
          return e2;
        case x:
          return W(e2);
      }
      const n2 = getCalendarIdFromBag(t2);
      return {
        ...$(refineTimeZoneArg, L, C(n2), t2),
        calendar: n2
      };
    }
    return H(t2);
  }
}
function toPlainTimeSlots(t2, e2) {
  if (s(t2)) {
    const n3 = cn(t2) || {};
    switch (n3.branding) {
      case ft:
        return mt(e2), n3;
      case x:
        return mt(e2), St(n3);
      case z:
        return mt(e2), dt(L, n3);
    }
    return Tt(t2, e2);
  }
  const n2 = ht(t2);
  return mt(e2), n2;
}
function optionalToPlainTimeFields(t2) {
  return void 0 === t2 ? void 0 : toPlainTimeSlots(t2);
}
function toPlainDateTimeSlots(t2, e2) {
  if (s(t2)) {
    const n3 = cn(t2) || {};
    switch (n3.branding) {
      case x:
        return mt(e2), n3;
      case G:
        return mt(e2), jt({
          ...n3,
          ...Nt
        });
      case z:
        return mt(e2), yt(L, n3);
    }
    return At(C(getCalendarIdFromBag(t2)), t2, e2);
  }
  const n2 = Bt(t2);
  return mt(e2), n2;
}
function toPlainMonthDaySlots(t2, e2) {
  if (s(t2)) {
    const n3 = cn(t2);
    if (n3 && n3.branding === qt) {
      return mt(e2), n3;
    }
    const o2 = extractCalendarIdFromBag(t2);
    return Rt(C(o2 || l), !o2, t2, e2);
  }
  const n2 = xt(C, t2);
  return mt(e2), n2;
}
function toPlainYearMonthSlots(t2, e2) {
  if (s(t2)) {
    const n3 = cn(t2);
    return n3 && n3.branding === Ut ? (mt(e2), n3) : Xt(C(getCalendarIdFromBag(t2)), t2, e2);
  }
  const n2 = _t(C, t2);
  return mt(e2), n2;
}
function toPlainDateSlots(t2, e2) {
  if (s(t2)) {
    const n3 = cn(t2) || {};
    switch (n3.branding) {
      case G:
        return mt(e2), n3;
      case x:
        return mt(e2), W(n3);
      case z:
        return mt(e2), fe(L, n3);
    }
    return me(C(getCalendarIdFromBag(t2)), t2, e2);
  }
  const n2 = de(t2);
  return mt(e2), n2;
}
function toZonedDateTimeSlots(t2, e2) {
  if (s(t2)) {
    const n2 = cn(t2);
    if (n2 && n2.branding === z) {
      return je(e2), n2;
    }
    const o2 = getCalendarIdFromBag(t2);
    return Ne(refineTimeZoneArg, L, C(o2), o2, t2, e2);
  }
  return Ae(t2, e2);
}
function adaptDateMethods(t2) {
  return e((t3) => (e2) => t3(slotsToIso(e2)), t2);
}
function slotsToIso(t2) {
  return he(t2, L);
}
function toInstantSlots(t2) {
  if (s(t2)) {
    const e2 = cn(t2);
    if (e2) {
      switch (e2.branding) {
        case Re:
          return e2;
        case z:
          return xe(e2.epochNanoseconds);
      }
    }
  }
  return We(t2);
}
function toTemporalInstant() {
  const t2 = Date.prototype.valueOf.call(this);
  return Kn(xe(Ge(ze(t2), Qe)));
}
function createDateTimeFormatClass() {
  function DateTimeFormatFunc(t3, e3) {
    return new DateTimeFormatNew(t3, e3);
  }
  function DateTimeFormatNew(t3, e3 = /* @__PURE__ */ Object.create(null)) {
    to.set(this, ((t4, e4) => {
      const n3 = new en(t4, e4), o2 = n3.resolvedOptions(), r2 = o2.locale, a2 = nn(Object.keys(e4), o2), i2 = on(createFormatPrepperForBranding), prepFormat = (t5, ...e5) => {
        if (t5) {
          if (2 !== e5.length) {
            throw new TypeError(ln);
          }
          for (const t6 of e5) {
            if (void 0 === t6) {
              throw new TypeError(ln);
            }
          }
        }
        t5 || void 0 !== e5[0] || (e5 = []);
        const o3 = e5.map((t6) => cn(t6) || Number(t6));
        let l2, s2 = 0;
        for (const t6 of o3) {
          const e6 = "object" == typeof t6 ? t6.branding : void 0;
          if (s2++ && e6 !== l2) {
            throw new TypeError(ln);
          }
          l2 = e6;
        }
        return l2 ? i2(l2)(r2, a2, ...o3) : [n3, ...o3];
      };
      return prepFormat.X = n3, prepFormat;
    })(t3, e3));
  }
  const t2 = en.prototype, e2 = Object.getOwnPropertyDescriptors(t2), n2 = Object.getOwnPropertyDescriptors(en);
  for (const t3 in e2) {
    const n3 = e2[t3], o2 = t3.startsWith("format") && createFormatMethod(t3);
    "function" == typeof n3.value ? n3.value = "constructor" === t3 ? DateTimeFormatFunc : o2 || createProxiedMethod(t3) : o2 && (n3.get = function() {
      if (!to.has(this)) {
        throw new TypeError(a);
      }
      return (...t4) => o2.apply(this, t4);
    }, Object.defineProperties(n3.get, r(`get ${t3}`)));
  }
  return n2.prototype.value = DateTimeFormatNew.prototype = Object.create({}, e2), Object.defineProperties(DateTimeFormatFunc, n2), DateTimeFormatFunc;
}
function createFormatMethod(t2) {
  return Object.defineProperties(function(...e2) {
    const n2 = to.get(this), [o2, ...r2] = n2(t2.includes("Range"), ...e2);
    return o2[t2](...r2);
  }, r(t2));
}
function createProxiedMethod(t2) {
  return Object.defineProperties(function(...e2) {
    return to.get(this).X[t2](...e2);
  }, r(t2));
}
function createFormatPrepperForBranding(t2) {
  const e2 = Cn[t2];
  if (!e2) {
    throw new TypeError(rn(t2));
  }
  return Q(e2, on(an), 1);
}
var sn = /* @__PURE__ */ new WeakMap();
var cn = sn.get.bind(sn);
var un = sn.set.bind(sn);
var fn = {
  era: d,
  eraYear: S,
  year: T,
  month: h,
  daysInMonth: h,
  daysInYear: h,
  inLeapYear: D,
  monthsInYear: h
};
var mn = {
  monthCode: m
};
var dn = {
  day: h
};
var Sn = {
  dayOfWeek: h,
  dayOfYear: h,
  weekOfYear: P,
  yearOfWeek: S,
  daysInWeek: h
};
var Tn = createCalendarGetters(Object.assign({}, fn, mn, dn, Sn));
var hn = createCalendarGetters({
  ...fn,
  ...mn
});
var Dn = createCalendarGetters({
  ...mn,
  ...dn
});
var Pn = {
  calendarId: (t2) => t2.calendar
};
var gn = g((t2) => (e2) => e2[t2], p.concat("sign"));
var pn = g((t2, e2) => (t3) => t3[w[e2]], O);
var On = {
  epochMilliseconds: I,
  epochNanoseconds: v
};
var [wn, In, vn] = createSlotClass(N, j, {
  ...gn,
  blank: y
}, {
  with: (t2, e2) => In(A(t2, e2)),
  negated: (t2) => In(B(t2)),
  abs: (t2) => In(Y(t2)),
  add: (t2, e2, n2) => In(E(refinePublicRelativeTo, C, L, 0, t2, toDurationSlots(e2), n2)),
  subtract: (t2, e2, n2) => In(E(refinePublicRelativeTo, C, L, 1, t2, toDurationSlots(e2), n2)),
  round: (t2, e2) => In(V(refinePublicRelativeTo, C, L, t2, e2)),
  total: (t2, e2) => J(refinePublicRelativeTo, C, L, t2, e2),
  toLocaleString(t2, e2, n2) {
    return Intl.DurationFormat ? new Intl.DurationFormat(e2, n2).format(this) : k(t2);
  },
  toString: k,
  toJSON: (t2) => k(t2),
  valueOf: neverValueOf
}, {
  from: (t2) => In(toDurationSlots(t2)),
  compare: (t2, e2, n2) => K(refinePublicRelativeTo, C, L, toDurationSlots(t2), toDurationSlots(e2), n2)
});
var Cn = {
  Instant: U,
  PlainDateTime: X,
  PlainDate: _,
  PlainTime: tt,
  PlainYearMonth: et,
  PlainMonthDay: nt
};
var bn = Q(U);
var Fn = Q(ot);
var Mn = Q(X);
var Zn = Q(_);
var yn = Q(tt);
var jn = Q(et);
var Nn = Q(nt);
var [An, Bn] = createSlotClass(ft, ut, pn, {
  with(t2, e2, n2) {
    return Bn(rt(this, rejectInvalidBag(e2), n2));
  },
  add: (t2, e2) => Bn(at(0, t2, toDurationSlots(e2))),
  subtract: (t2, e2) => Bn(at(1, t2, toDurationSlots(e2))),
  until: (t2, e2, n2) => In(it(0, t2, toPlainTimeSlots(e2), n2)),
  since: (t2, e2, n2) => In(it(1, t2, toPlainTimeSlots(e2), n2)),
  round: (t2, e2) => Bn(lt(t2, e2)),
  equals: (t2, e2) => st(t2, toPlainTimeSlots(e2)),
  toLocaleString(t2, e2, n2) {
    const [o2, r2] = yn(e2, n2, t2);
    return o2.format(r2);
  },
  toString: ct,
  toJSON: (t2) => ct(t2),
  valueOf: neverValueOf
}, {
  from: (t2, e2) => Bn(toPlainTimeSlots(t2, e2)),
  compare: (t2, e2) => Dt(toPlainTimeSlots(t2), toPlainTimeSlots(e2))
});
var [Yn, En] = createSlotClass(x, Pt(Zt, Mt), {
  ...Pn,
  ...Tn,
  ...pn
}, {
  with: (t2, e2, n2) => En(gt(C, t2, rejectInvalidBag(e2), n2)),
  withCalendar: (t2, e2) => En(pt(t2, refineCalendarArg(e2))),
  withPlainTime: (t2, e2) => En(Ot(t2, optionalToPlainTimeFields(e2))),
  add: (t2, e2, n2) => En(wt(C, 0, t2, toDurationSlots(e2), n2)),
  subtract: (t2, e2, n2) => En(wt(C, 1, t2, toDurationSlots(e2), n2)),
  until: (t2, e2, n2) => In(It(C, 0, t2, toPlainDateTimeSlots(e2), n2)),
  since: (t2, e2, n2) => In(It(C, 1, t2, toPlainDateTimeSlots(e2), n2)),
  round: (t2, e2) => En(vt(t2, e2)),
  equals: (t2, e2) => Ct(t2, toPlainDateTimeSlots(e2)),
  toZonedDateTime: (t2, e2, n2) => $n(bt(L, t2, refineTimeZoneArg(e2), n2)),
  toPlainDate: (t2) => Wn(W(t2)),
  toPlainTime: (t2) => Bn(St(t2)),
  toLocaleString(t2, e2, n2) {
    const [o2, r2] = Mn(e2, n2, t2);
    return o2.format(r2);
  },
  toString: Ft,
  toJSON: (t2) => Ft(t2),
  valueOf: neverValueOf
}, {
  from: (t2, e2) => En(toPlainDateTimeSlots(t2, e2)),
  compare: (t2, e2) => Yt(toPlainDateTimeSlots(t2), toPlainDateTimeSlots(e2))
});
var [Ln, Vn, Jn] = createSlotClass(qt, Pt(kt, Mt), {
  ...Pn,
  ...Dn
}, {
  with: (t2, e2, n2) => Vn(Et(C, t2, rejectInvalidBag(e2), n2)),
  equals: (t2, e2) => Lt(t2, toPlainMonthDaySlots(e2)),
  toPlainDate(t2, e2) {
    return Wn(Vt(C, t2, this, e2));
  },
  toLocaleString(t2, e2, n2) {
    const [o2, r2] = Nn(e2, n2, t2);
    return o2.format(r2);
  },
  toString: Jt,
  toJSON: (t2) => Jt(t2),
  valueOf: neverValueOf
}, {
  from: (t2, e2) => Vn(toPlainMonthDaySlots(t2, e2))
});
var [kn, qn, Rn] = createSlotClass(Ut, Pt(Qt, Mt), {
  ...Pn,
  ...hn
}, {
  with: (t2, e2, n2) => qn(Wt(C, t2, rejectInvalidBag(e2), n2)),
  add: (t2, e2, n2) => qn(Gt(C, 0, t2, toDurationSlots(e2), n2)),
  subtract: (t2, e2, n2) => qn(Gt(C, 1, t2, toDurationSlots(e2), n2)),
  until: (t2, e2, n2) => In(zt(C, 0, t2, toPlainYearMonthSlots(e2), n2)),
  since: (t2, e2, n2) => In(zt(C, 1, t2, toPlainYearMonthSlots(e2), n2)),
  equals: (t2, e2) => $t(t2, toPlainYearMonthSlots(e2)),
  toPlainDate(t2, e2) {
    return Wn(Ht(C, t2, this, e2));
  },
  toLocaleString(t2, e2, n2) {
    const [o2, r2] = jn(e2, n2, t2);
    return o2.format(r2);
  },
  toString: Kt,
  toJSON: (t2) => Kt(t2),
  valueOf: neverValueOf
}, {
  from: (t2, e2) => qn(toPlainYearMonthSlots(t2, e2)),
  compare: (t2, e2) => te(toPlainYearMonthSlots(t2), toPlainYearMonthSlots(e2))
});
var [xn, Wn, Gn] = createSlotClass(G, Pt(ue, Mt), {
  ...Pn,
  ...Tn
}, {
  with: (t2, e2, n2) => Wn(ee(C, t2, rejectInvalidBag(e2), n2)),
  withCalendar: (t2, e2) => Wn(pt(t2, refineCalendarArg(e2))),
  add: (t2, e2, n2) => Wn(ne(C, 0, t2, toDurationSlots(e2), n2)),
  subtract: (t2, e2, n2) => Wn(ne(C, 1, t2, toDurationSlots(e2), n2)),
  until: (t2, e2, n2) => In(oe(C, 0, t2, toPlainDateSlots(e2), n2)),
  since: (t2, e2, n2) => In(oe(C, 1, t2, toPlainDateSlots(e2), n2)),
  equals: (t2, e2) => re(t2, toPlainDateSlots(e2)),
  toZonedDateTime(t2, e2) {
    const n2 = s(e2) ? e2 : {
      timeZone: e2
    };
    return $n(ae(refineTimeZoneArg, toPlainTimeSlots, L, t2, n2));
  },
  toPlainDateTime: (t2, e2) => En(ie(t2, optionalToPlainTimeFields(e2))),
  toPlainYearMonth(t2) {
    return qn(le(C, t2, this));
  },
  toPlainMonthDay(t2) {
    return Vn(se(C, t2, this));
  },
  toLocaleString(t2, e2, n2) {
    const [o2, r2] = Zn(e2, n2, t2);
    return o2.format(r2);
  },
  toString: ce,
  toJSON: (t2) => ce(t2),
  valueOf: neverValueOf
}, {
  from: (t2, e2) => Wn(toPlainDateSlots(t2, e2)),
  compare: (t2, e2) => te(toPlainDateSlots(t2), toPlainDateSlots(e2))
});
var [zn, $n] = createSlotClass(z, Pt(ye, Mt, Ze), {
  ...On,
  ...Pn,
  ...adaptDateMethods(Tn),
  ...adaptDateMethods(pn),
  offset: (t2) => Se(slotsToIso(t2).offsetNanoseconds),
  offsetNanoseconds: (t2) => slotsToIso(t2).offsetNanoseconds,
  timeZoneId: (t2) => t2.timeZone,
  hoursInDay: (t2) => Te(L, t2)
}, {
  with: (t2, e2, n2) => $n(De(C, L, t2, rejectInvalidBag(e2), n2)),
  withCalendar: (t2, e2) => $n(pt(t2, refineCalendarArg(e2))),
  withTimeZone: (t2, e2) => $n(Pe(t2, refineTimeZoneArg(e2))),
  withPlainTime: (t2, e2) => $n(ge(L, t2, optionalToPlainTimeFields(e2))),
  add: (t2, e2, n2) => $n(pe(C, L, 0, t2, toDurationSlots(e2), n2)),
  subtract: (t2, e2, n2) => $n(pe(C, L, 1, t2, toDurationSlots(e2), n2)),
  until: (t2, e2, n2) => In(Oe(we(C, L, 0, t2, toZonedDateTimeSlots(e2), n2))),
  since: (t2, e2, n2) => In(Oe(we(C, L, 1, t2, toZonedDateTimeSlots(e2), n2))),
  round: (t2, e2) => $n(Ie(L, t2, e2)),
  startOfDay: (t2) => $n(ve(L, t2)),
  equals: (t2, e2) => Ce(t2, toZonedDateTimeSlots(e2)),
  toInstant: (t2) => Kn(be(t2)),
  toPlainDateTime: (t2) => En(yt(L, t2)),
  toPlainDate: (t2) => Wn(fe(L, t2)),
  toPlainTime: (t2) => Bn(dt(L, t2)),
  toLocaleString(t2, e2, n2 = {}) {
    const [o2, r2] = Fn(e2, n2, t2);
    return o2.format(r2);
  },
  toString: (t2, e2) => Fe(L, t2, e2),
  toJSON: (t2) => Fe(L, t2),
  valueOf: neverValueOf,
  getTimeZoneTransition(t2, e2) {
    const { timeZone: n2, epochNanoseconds: o2 } = t2, r2 = Me(e2), a2 = L(n2).O(o2, r2);
    return a2 ? $n({
      ...t2,
      epochNanoseconds: a2
    }) : null;
  }
}, {
  from: (t2, e2) => $n(toZonedDateTimeSlots(t2, e2)),
  compare: (t2, e2) => Be(toZonedDateTimeSlots(t2), toZonedDateTimeSlots(e2))
});
var [Hn, Kn, Qn] = createSlotClass(Re, qe, On, {
  add: (t2, e2) => Kn(Ye(0, t2, toDurationSlots(e2))),
  subtract: (t2, e2) => Kn(Ye(1, t2, toDurationSlots(e2))),
  until: (t2, e2, n2) => In(Ee(0, t2, toInstantSlots(e2), n2)),
  since: (t2, e2, n2) => In(Ee(1, t2, toInstantSlots(e2), n2)),
  round: (t2, e2) => Kn(Le(t2, e2)),
  equals: (t2, e2) => Ve(t2, toInstantSlots(e2)),
  toZonedDateTimeISO: (t2, e2) => $n(Je(t2, refineTimeZoneArg(e2))),
  toLocaleString(t2, e2, n2) {
    const [o2, r2] = bn(e2, n2, t2);
    return o2.format(r2);
  },
  toString: (t2, e2) => ke(refineTimeZoneArg, L, t2, e2),
  toJSON: (t2) => ke(refineTimeZoneArg, L, t2),
  valueOf: neverValueOf
}, {
  from: (t2) => Kn(toInstantSlots(t2)),
  fromEpochMilliseconds: (t2) => Kn($e(t2)),
  fromEpochNanoseconds: (t2) => Kn(He(t2)),
  compare: (t2, e2) => Ke(toInstantSlots(t2), toInstantSlots(e2))
});
var Un = Object.defineProperties({}, {
  ...o("Temporal.Now"),
  ...n({
    timeZoneId: () => Ue(),
    instant: () => Kn(xe(Xe())),
    zonedDateTimeISO: (t2 = Ue()) => $n(_e(Xe(), refineTimeZoneArg(t2), l)),
    plainDateTimeISO: (t2 = Ue()) => En(jt(tn(L(refineTimeZoneArg(t2))), l)),
    plainDateISO: (t2 = Ue()) => Wn(W(tn(L(refineTimeZoneArg(t2))), l)),
    plainTimeISO: (t2 = Ue()) => Bn(St(tn(L(refineTimeZoneArg(t2)))))
  })
});
var Xn = Object.defineProperties({}, {
  ...o("Temporal"),
  ...n({
    PlainYearMonth: kn,
    PlainMonthDay: Ln,
    PlainDate: xn,
    PlainTime: An,
    PlainDateTime: Yn,
    ZonedDateTime: zn,
    Instant: Hn,
    Duration: wn,
    Now: Un
  })
});
var _n = createDateTimeFormatClass();
var to = /* @__PURE__ */ new WeakMap();
var eo = Object.defineProperties(Object.create(Intl), n({
  DateTimeFormat: _n
}));

// node_modules/temporal-polyfill/global.esm.js
Object.defineProperties(globalThis, n({
  Temporal: Xn
})), Object.defineProperties(Intl, n({
  DateTimeFormat: _n
})), Object.defineProperties(Date.prototype, n({
  toTemporalInstant
}));

// node_modules/@hebcal/noaa/dist/index.js
function degreesToRadians(degrees) {
  return degrees * Math.PI / 180;
}
function radiansToDegrees(radians) {
  return radians * 180 / Math.PI;
}
var GeoLocation = class {
  /**
   * GeoLocation constructor with parameters for all required fields.
   *
   * @param {string} name
   *            The location name for display use such as &quot;Lakewood, NJ&quot;
   * @param {number} latitude
   *            the latitude in a double format such as 40.095965 for Lakewood, NJ.
   *            <b>Note: </b> For latitudes south of the equator, a negative value should be used.
   * @param {number} longitude
   *            double the longitude in a double format such as -74.222130 for Lakewood, NJ.
   *            <b>Note: </b> For longitudes west of the <a href="http://en.wikipedia.org/wiki/Prime_Meridian">Prime
   *            Meridian </a> (Greenwich), a negative value should be used.
   * @param {number} elevation
   *            the elevation above sea level in Meters. Elevation is not used in most algorithms used for calculating
   *            sunrise and set.
   * @param {string} timeZoneId
   *            the <code>TimeZone</code> for the location.
   */
  constructor(name, latitude, longitude, elevation, timeZoneId) {
    this.locationName = null;
    this.setLocationName(name);
    this.setLatitude(latitude);
    this.setLongitude(longitude);
    this.setElevation(elevation);
    this.setTimeZone(timeZoneId);
  }
  /**
   * Method to get the elevation in Meters.
   *
   * @return {number} Returns the elevation in Meters.
   */
  getElevation() {
    return this.elevation;
  }
  /**
   * Method to set the elevation in Meters <b>above </b> sea level.
   *
   * @param {number} elevation
   *            The elevation to set in Meters. An Error will be thrown if the value is a negative.
   */
  setElevation(elevation) {
    if (typeof elevation !== "number")
      throw new TypeError("Invalid elevation");
    if (elevation < 0) {
      throw new RangeError(`elevation ${elevation} must be zero or positive`);
    }
    this.elevation = elevation;
  }
  setLatitude(latitude) {
    if (typeof latitude !== "number")
      throw new TypeError("Invalid latitude");
    if (latitude < -90 || latitude > 90) {
      throw new RangeError(`Latitude ${latitude} out of range [-90,90]`);
    }
    this.latitude = latitude;
  }
  /**
   * @return {number} Returns the latitude.
   */
  getLatitude() {
    return this.latitude;
  }
  setLongitude(longitude) {
    if (typeof longitude !== "number")
      throw new TypeError("Invalid longitude");
    if (longitude < -180 || longitude > 180) {
      throw new RangeError(`Longitude ${longitude} out of range [-180,180]`);
    }
    this.longitude = longitude;
  }
  /**
   * @return {number} Returns the longitude.
   */
  getLongitude() {
    return this.longitude;
  }
  /**
   * @return {string|null} Returns the location name.
   */
  getLocationName() {
    return this.locationName;
  }
  /**
   * @param {string|null} name
   *            The setter method for the display name.
   */
  setLocationName(name) {
    this.locationName = name;
  }
  /**
   * @return {string} Returns the timeZone.
   */
  getTimeZone() {
    return this.timeZoneId;
  }
  /**
   * Method to set the TimeZone.
   * @param {string} timeZoneId
   *            The timeZone to set.
   */
  setTimeZone(timeZoneId) {
    if (!timeZoneId) {
      throw new RangeError("Invalid timeZoneId");
    }
    this.timeZoneId = timeZoneId;
  }
};
var refraction = 34 / 60;
var solarRadius = 16 / 60;
var earthRadius = 6356.9;
var NOAACalculator = class _NOAACalculator {
  /**
   * A constructor that takes in <a href="http://en.wikipedia.org/wiki/Geolocation">geolocation</a> information as a
   * parameter.
   *
   * @param {GeoLocation} geoLocation
   *            The location information used for calculating astronomical sun times.
   * @param {Temporal.PlainDate} date
   */
  constructor(geoLocation, date) {
    this.date = date;
    this.geoLocation = geoLocation;
  }
  /**
   * The getSunrise method Returns a `Date` representing the
   * {@link getElevationAdjustment elevation adjusted} sunrise time. The zenith used
   * for the calculation uses {@link GEOMETRIC_ZENITH geometric zenith} of 90&deg; plus
   * {@link getElevationAdjustment}. This is adjusted
   * to add approximately 50/60 of a degree to account for 34 archminutes of refraction
   * and 16 archminutes for the sun's radius for a total of {@link adjustZenith 90.83333&deg;}.
   *
   * @return {Temporal.ZonedDateTime | null} the `Date` representing the exact sunrise time. If the calculation can't be computed such as
   *         in the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
   *         does not set, a null will be returned. See detailed explanation on top of the page.
   * @see adjustZenith
   * @see getSeaLevelSunrise()
   * @see getUTCSunrise
   */
  getSunrise() {
    const sunrise = this.getUTCSunrise0(_NOAACalculator.GEOMETRIC_ZENITH);
    if (isNaN(sunrise))
      return null;
    return this.getDateFromTime(sunrise, true);
  }
  /**
   * A method that returns the sunrise without {@link getElevationAdjustment elevation
   * adjustment}. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible light,
   * something that is not affected by elevation. This method returns sunrise calculated at sea level. This forms the
   * base for dawn calculations that are calculated as a dip below the horizon before sunrise.
   *
   * @return {Temporal.ZonedDateTime | null} the `Date` representing the exact sea-level sunrise time. If the calculation can't be computed
   *         such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
   *         where it does not set, a null will be returned. See detailed explanation on top of the page.
   * @see getSunrise
   * @see getUTCSeaLevelSunrise
   * @see getSeaLevelSunset()
   */
  getSeaLevelSunrise() {
    const sunrise = this.getUTCSeaLevelSunrise(_NOAACalculator.GEOMETRIC_ZENITH);
    if (isNaN(sunrise))
      return null;
    return this.getDateFromTime(sunrise, true);
  }
  /**
   * A method that returns the beginning of civil twilight (dawn) using a zenith of {@link CIVIL_ZENITH 96&deg;}.
   *
   * @return {Temporal.ZonedDateTime | null} The `Date` of the beginning of civil twilight using a zenith of 96&deg;. If the calculation
   *         can't be computed, null will be returned. See detailed explanation on top of the page.
   * @see CIVIL_ZENITH
   */
  getBeginCivilTwilight() {
    return this.getSunriseOffsetByDegrees(_NOAACalculator.CIVIL_ZENITH);
  }
  /**
   * A method that returns the beginning of nautical twilight using a zenith of {@link NAUTICAL_ZENITH 102&deg;}.
   *
   * @return {Temporal.ZonedDateTime | null} The `Date` of the beginning of nautical twilight using a zenith of 102&deg;. If the
   *         calculation can't be computed null will be returned. See detailed explanation on top of the page.
   * @see NAUTICAL_ZENITH
   */
  getBeginNauticalTwilight() {
    return this.getSunriseOffsetByDegrees(_NOAACalculator.NAUTICAL_ZENITH);
  }
  /**
   * A method that returns the beginning of astronomical twilight using a zenith of {@link ASTRONOMICAL_ZENITH
   * 108&deg;}.
   *
   * @return {Temporal.ZonedDateTime | null} The `Date` of the beginning of astronomical twilight using a zenith of 108&deg;. If the
   *         calculation can't be computed, null will be returned. See detailed explanation on top of the page.
   * @see ASTRONOMICAL_ZENITH
   */
  getBeginAstronomicalTwilight() {
    return this.getSunriseOffsetByDegrees(_NOAACalculator.ASTRONOMICAL_ZENITH);
  }
  /**
   * The getSunset method Returns a `Date` representing the
   * {@link getElevationAdjustment elevation adjusted} sunset time. The zenith used for
   * the calculation uses {@link GEOMETRIC_ZENITH geometric zenith} of 90&deg; plus
   * {@link getElevationAdjustment}. This is adjusted
   * to add approximately 50/60 of a degree to account for 34 archminutes of refraction
   * and 16 archminutes for the sun's radius for a total of {@link adjustZenith 90.83333&deg;}.
   * Note:
   * In certain cases the calculates sunset will occur before sunrise. This will typically happen when a timezone
   * other than the local timezone is used (calculating Los Angeles sunset using a GMT timezone for example). In this
   * case the sunset date will be incremented to the following date.
   *
   * @return {Temporal.ZonedDateTime | null} The `Date` representing the exact sunset time. If the calculation can't be computed such as in
   *         the Arctic Circle where there is at least one day a year where the sun does not rise, and one where it
   *         does not set, a null will be returned. See detailed explanation on top of the page.
   * @see adjustZenith
   * @see getSeaLevelSunset()
   * @see getUTCSunset
   */
  getSunset() {
    const sunset = this.getUTCSunset0(_NOAACalculator.GEOMETRIC_ZENITH);
    if (isNaN(sunset))
      return null;
    return this.getDateFromTime(sunset, false);
  }
  /**
   * A method that returns the sunset without {@link getElevationAdjustment elevation
   * adjustment}. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible light,
   * something that is not affected by elevation. This method returns sunset calculated at sea level. This forms the
   * base for dusk calculations that are calculated as a dip below the horizon after sunset.
   *
   * @return {Temporal.ZonedDateTime | null} The `Date` representing the exact sea-level sunset time. If the calculation can't be computed
   *         such as in the Arctic Circle where there is at least one day a year where the sun does not rise, and one
   *         where it does not set, a null will be returned. See detailed explanation on top of the page.
   * @see getSunset
   * @see getUTCSeaLevelSunset
   */
  getSeaLevelSunset() {
    const sunset = this.getUTCSeaLevelSunset(_NOAACalculator.GEOMETRIC_ZENITH);
    if (isNaN(sunset))
      return null;
    return this.getDateFromTime(sunset, false);
  }
  /**
   * A method that returns the end of civil twilight using a zenith of {@link CIVIL_ZENITH 96&deg;}.
   *
   * @return {Temporal.ZonedDateTime | null} The `Date` of the end of civil twilight using a zenith of {@link CIVIL_ZENITH 96&deg;}. If
   *         the calculation can't be computed, null will be returned. See detailed explanation on top of the page.
   * @see CIVIL_ZENITH
   */
  getEndCivilTwilight() {
    return this.getSunsetOffsetByDegrees(_NOAACalculator.CIVIL_ZENITH);
  }
  /**
   * A method that returns the end of nautical twilight using a zenith of {@link NAUTICAL_ZENITH 102&deg;}.
   *
   * @return {Temporal.ZonedDateTime | null} The `Date` of the end of nautical twilight using a zenith of {@link NAUTICAL_ZENITH 102&deg;}
   *         . If the calculation can't be computed, null will be returned. See detailed explanation on top of the
   *         page.
   * @see NAUTICAL_ZENITH
   */
  getEndNauticalTwilight() {
    return this.getSunsetOffsetByDegrees(_NOAACalculator.NAUTICAL_ZENITH);
  }
  /**
   * A method that returns the end of astronomical twilight using a zenith of {@link ASTRONOMICAL_ZENITH 108&deg;}.
   *
   * @return {Temporal.ZonedDateTime | null} The `Date` of the end of astronomical twilight using a zenith of {@link ASTRONOMICAL_ZENITH
   *         108&deg;}. If the calculation can't be computed, null will be returned. See detailed explanation on top
   *         of the page.
   * @see ASTRONOMICAL_ZENITH
   */
  getEndAstronomicalTwilight() {
    return this.getSunsetOffsetByDegrees(_NOAACalculator.ASTRONOMICAL_ZENITH);
  }
  /**
   * A utility method that returns a date offset by the offset time passed in. Please note that the level of light
   * during twilight is not affected by elevation, so if this is being used to calculate an offset before sunrise or
   * after sunset with the intent of getting a rough "level of light" calculation, the sunrise or sunset time passed
   * to this method should be sea level sunrise and sunset.
   *
   * @param {Temporal.ZonedDateTime | null} time
   *            the start time
   * @param {number} offset
   *            the offset in milliseconds to add to the time.
   * @return {Temporal.ZonedDateTime | null} the `Date` with the offset in milliseconds added to it
   */
  static getTimeOffset(time, offset) {
    if (time === null || isNaN(offset)) {
      return null;
    }
    return time.add({ milliseconds: offset });
  }
  /**
   * A utility method that returns the time of an offset by degrees below or above the horizon of
   * {@link getSunrise() sunrise}. Note that the degree offset is from the vertical, so for a calculation of 14&deg;
   * before sunrise, an offset of 14 + {@link GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.
   *
   * @param {number} offsetZenith
   *            the degrees before {@link getSunrise} to use in the calculation. For time after sunrise use
   *            negative numbers. Note that the degree offset is from the vertical, so for a calculation of 14&deg;
   *            before sunrise, an offset of 14 + {@link GEOMETRIC_ZENITH} = 104 would have to be passed as a
   *            parameter.
   * @return {Temporal.ZonedDateTime | null} The `Date` of the offset after (or before) {@link getSunrise}. If the calculation
   *         can't be computed such as in the Arctic Circle where there is at least one day a year where the sun does
   *         not rise, and one where it does not set, a null will be returned. See detailed explanation on top of the
   *         page.
   */
  getSunriseOffsetByDegrees(offsetZenith) {
    const dawn = this.getUTCSunrise0(offsetZenith);
    if (isNaN(dawn))
      return null;
    return this.getDateFromTime(dawn, true);
  }
  /**
   * A utility method that returns the time of an offset by degrees below or above the horizon of {@link getSunset()
   * sunset}. Note that the degree offset is from the vertical, so for a calculation of 14&deg; after sunset, an
   * offset of 14 + {@link GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.
   *
   * @param {number} offsetZenith
   *            the degrees after {@link getSunset} to use in the calculation. For time before sunset use negative
   *            numbers. Note that the degree offset is from the vertical, so for a calculation of 14&deg; after
   *            sunset, an offset of 14 + {@link GEOMETRIC_ZENITH} = 104 would have to be passed as a parameter.
   * @return {Temporal.ZonedDateTime | null} The `Date`of the offset after (or before) {@link getSunset}. If the calculation can't
   *         be computed such as in the Arctic Circle where there is at least one day a year where the sun does not
   *         rise, and one where it does not set, a null will be returned. See detailed explanation on top of the
   *         page.
   */
  getSunsetOffsetByDegrees(offsetZenith) {
    const sunset = this.getUTCSunset0(offsetZenith);
    if (isNaN(sunset))
      return null;
    return this.getDateFromTime(sunset, false);
  }
  /**
   * A method that returns the sunrise in UTC time without correction for time zone offset from GMT and without using
   * daylight savings time.
   *
   * @param {number} zenith
   *            the degrees below the horizon. For time after sunrise use negative numbers.
   * @return {number} The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
   *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
   *         not set, `NaN` will be returned. See detailed explanation on top of the page.
   */
  getUTCSunrise0(zenith) {
    return this.getUTCSunrise(this.getAdjustedDate(), this.geoLocation, zenith, true);
  }
  /**
   * A method that returns the sunrise in UTC time without correction for time zone offset from GMT and without using
   * daylight savings time. Non-sunrise and sunset calculations such as dawn and dusk, depend on the amount of visible
   * light, something that is not affected by elevation. This method returns UTC sunrise calculated at sea level. This
   * forms the base for dawn calculations that are calculated as a dip below the horizon before sunrise.
   *
   * @param {number} zenith
   *            the degrees below the horizon. For time after sunrise use negative numbers.
   * @return {number} The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
   *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
   *         not set, `NaN` will be returned. See detailed explanation on top of the page.
   * @see getUTCSunrise
   * @see getUTCSeaLevelSunset
   */
  getUTCSeaLevelSunrise(zenith) {
    return this.getUTCSunrise(this.getAdjustedDate(), this.geoLocation, zenith, false);
  }
  /**
   * A method that returns the sunset in UTC time without correction for time zone offset from GMT and without using
   * daylight savings time.
   *
   * @param {number} zenith
   *            the degrees below the horizon. For time after sunset use negative numbers.
   * @return {number} The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
   *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
   *         not set, `NaN` will be returned. See detailed explanation on top of the page.
   * @see getUTCSeaLevelSunset
   */
  getUTCSunset0(zenith) {
    return this.getUTCSunset(this.getAdjustedDate(), this.geoLocation, zenith, true);
  }
  /**
   * A method that returns the sunset in UTC time without correction for elevation, time zone offset from GMT and
   * without using daylight savings time. Non-sunrise and sunset calculations such as dawn and dusk, depend on the
   * amount of visible light, something that is not affected by elevation. This method returns UTC sunset calculated
   * at sea level. This forms the base for dusk calculations that are calculated as a dip below the horizon after
   * sunset.
   *
   * @param {number} zenith
   *            the degrees below the horizon. For time before sunset use negative numbers.
   * @return {number} The time in the format: 18.75 for 18:45:00 UTC/GMT. If the calculation can't be computed such as in the
   *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
   *         not set, `NaN` will be returned. See detailed explanation on top of the page.
   * @see getUTCSunset
   * @see getUTCSeaLevelSunrise
   */
  getUTCSeaLevelSunset(zenith) {
    return this.getUTCSunset(this.getAdjustedDate(), this.geoLocation, zenith, false);
  }
  /**
   * Adjusts the <code>Calendar</code> to deal with edge cases where the location crosses the antimeridian.
   * @private
   * @see GeoLocation#getAntimeridianAdjustment()
   * @return the adjusted Calendar
   */
  getAdjustedDate() {
    return this.date;
  }
  /**
   * Method to return the adjustment to the zenith required to account for the elevation. Since a person at a higher
   * elevation can see farther below the horizon, the calculation for sunrise / sunset is calculated below the horizon
   * used at sea level. This is only used for sunrise and sunset and not times before or after it such as
   * {@link getBeginNauticalTwilight() nautical twilight} since those
   * calculations are based on the level of available light at the given dip below the horizon, something that is not
   * affected by elevation, the adjustment should only made if the zenith == 90&deg; {@link adjustZenith adjusted}
   * for refraction and solar radius. The algorithm used is
   *
   * <pre>
   * elevationAdjustment = Math.toDegrees(Math.acos(earthRadiusInMeters / (earthRadiusInMeters + elevationMeters)));
   * </pre>
   *
   * The source of this algorithm is <a href="http://www.calendarists.com">Calendrical Calculations</a> by Edward M.
   * Reingold and Nachum Dershowitz. An alternate algorithm that produces an almost identical (but not accurate)
   * result found in Ma'aglay Tzedek by Moishe Kosower and other sources is:
   *
   * <pre>
   * elevationAdjustment = 0.0347 * Math.sqrt(elevationMeters);
   * </pre>
   *
   * @param {number} elevation
   *            elevation in Meters.
   * @return {number} the adjusted zenith
   */
  getElevationAdjustment(elevation) {
    const elevationAdjustment = radiansToDegrees(Math.acos(earthRadius / (earthRadius + elevation / 1e3)));
    return elevationAdjustment;
  }
  /**
   * Adjusts the zenith of astronomical sunrise and sunset to account for solar refraction, solar radius and
   * elevation. The value for Sun's zenith and true rise/set Zenith (used in this class and subclasses) is the angle
   * that the center of the Sun makes to a line perpendicular to the Earth's surface. If the Sun were a point and the
   * Earth were without an atmosphere, true sunset and sunrise would correspond to a 90&deg; zenith. Because the Sun
   * is not a point, and because the atmosphere refracts light, this 90&deg; zenith does not, in fact, correspond to
   * true sunset or sunrise, instead the centre of the Sun's disk must lie just below the horizon for the upper edge
   * to be obscured. This means that a zenith of just above 90&deg; must be used. The Sun subtends an angle of 16
   * minutes of arc, and atmospheric refraction
   * accounts for 34 minutes or so, giving a total
   * of 50 arcminutes. The total value for ZENITH is 90+(5/6) or 90.8333333&deg; for true sunrise/sunset. Since a
   * person at an elevation can see blow the horizon of a person at sea level, this will also adjust the zenith to
   * account for elevation if available. Note that this will only adjust the value if the zenith is exactly 90 degrees.
   * For values below and above this no correction is done. As an example, astronomical twilight is when the sun is
   * 18&deg; below the horizon or {@link ASTRONOMICAL_ZENITH 108&deg;
   * below the zenith}. This is traditionally calculated with none of the above mentioned adjustments. The same goes
   * for various <em>tzais</em> and <em>alos</em> times such as the
   * {@link ZmanimCalendar#ZENITH_16_POINT_1 16.1&deg;} dip used in
   * {@link ComplexZmanimCalendar#getAlos16Point1Degrees}.
   *
   * @param {number} zenith
   *            the azimuth below the vertical zenith of 90&deg;. For sunset typically the {@link adjustZenith
   *            zenith} used for the calculation uses geometric zenith of 90&deg; and {@link adjustZenith adjusts}
   *            this slightly to account for solar refraction and the sun's radius. Another example would be
   *            {@link getEndNauticalTwilight} that passes
   *            {@link NAUTICAL_ZENITH} to this method.
   * @param {number} elevation
   *            elevation in Meters.
   * @return {number} The zenith adjusted to include the sun's radius, refracton
   *         and {@link getElevationAdjustment elevation} adjustment. This will only be adjusted for
   *         sunrise and sunset (if the zenith == 90&deg;)
   * @see getElevationAdjustment
   */
  adjustZenith(zenith, elevation) {
    let adjustedZenith = zenith;
    if (zenith === _NOAACalculator.GEOMETRIC_ZENITH) {
      adjustedZenith = zenith + (solarRadius + refraction + this.getElevationAdjustment(elevation));
    }
    return adjustedZenith;
  }
  /**
   * A method that calculates UTC sunrise as well as any time based on an angle above or below sunrise.
   * @param date
   *            Used to calculate day of year.
   * @param geoLocation
   *            The location information used for astronomical calculating sun times.
   * @param zenith
   *            the azimuth below the vertical zenith of 90 degrees. for sunrise typically the {@link adjustZenith
   *            zenith} used for the calculation uses geometric zenith of 90&deg; and {@link adjustZenith adjusts}
   *            this slightly to account for solar refraction and the sun's radius. Another example would be
   *            {@link getBeginNauticalTwilight} that passes
   *            {@link NAUTICAL_ZENITH} to this method.
   * @param adjustForElevation
   *            Should the time be adjusted for elevation
   * @return The UTC time of sunrise in 24 hour format. 5:45:00 AM will return 5.75.0. If an error was encountered in
   *         the calculation (expected behavior for some locations such as near the poles,
   *         `NaN` will be returned.
   */
  getUTCSunrise(date, geoLocation, zenith, adjustForElevation) {
    const elevation = adjustForElevation ? geoLocation.getElevation() : 0;
    const adjustedZenith = this.adjustZenith(zenith, elevation);
    let sunrise = _NOAACalculator.getSunriseUTC(_NOAACalculator.getJulianDay(date), geoLocation.getLatitude(), -geoLocation.getLongitude(), adjustedZenith);
    sunrise = sunrise / 60;
    while (sunrise < 0) {
      sunrise += 24;
    }
    while (sunrise >= 24) {
      sunrise -= 24;
    }
    return sunrise;
  }
  /**
   * A method that calculates UTC sunset as well as any time based on an angle above or below sunset.
   * @param date
   *            Used to calculate day of year.
   * @param geoLocation
   *            The location information used for astronomical calculating sun times.
   * @param zenith
   *            the azimuth below the vertical zenith of 90&deg;. For sunset typically the {@link adjustZenith
   *            zenith} used for the calculation uses geometric zenith of 90&deg; and {@link adjustZenith adjusts}
   *            this slightly to account for solar refraction and the sun's radius. Another example would be
   *            {@link getEndNauticalTwilight} that passes
   *            {@link NAUTICAL_ZENITH} to this method.
   * @param adjustForElevation
   *            Should the time be adjusted for elevation
   * @return The UTC time of sunset in 24 hour format. 5:45:00 AM will return 5.75.0. If an error was encountered in
   *         the calculation (expected behavior for some locations such as near the poles,
   *         `NaN` will be returned.
   */
  getUTCSunset(date, geoLocation, zenith, adjustForElevation) {
    const elevation = adjustForElevation ? geoLocation.getElevation() : 0;
    const adjustedZenith = this.adjustZenith(zenith, elevation);
    let sunset = _NOAACalculator.getSunsetUTC(_NOAACalculator.getJulianDay(date), geoLocation.getLatitude(), -geoLocation.getLongitude(), adjustedZenith);
    sunset = sunset / 60;
    while (sunset < 0) {
      sunset += 24;
    }
    while (sunset >= 24) {
      sunset -= 24;
    }
    return sunset;
  }
  /**
   * A utility method that will allow the calculation of a temporal (solar) hour based on the sunrise and sunset
   * passed as parameters to this method. An example of the use of this method would be the calculation of a
   * non-elevation adjusted temporal hour by passing in {@link getSeaLevelSunrise() sea level sunrise} and
   * {@link getSeaLevelSunset() sea level sunset} as parameters.
   *
   * @param {Temporal.ZonedDateTime | null} startOfDay
   *            The start of the day.
   * @param {Temporal.ZonedDateTime | null} endOfDay
   *            The end of the day.
   *
   * @return {number} the <code>long</code> millisecond length of the temporal hour. If the calculation can't be computed a
   *         `NaN` will be returned. See detailed explanation on top of the page.
   *
   * @see getTemporalHour()
   */
  getTemporalHour(startOfDay = this.getSeaLevelSunrise(), endOfDay = this.getSeaLevelSunset()) {
    if (startOfDay === null || endOfDay === null) {
      return NaN;
    }
    const delta = endOfDay.epochMilliseconds - startOfDay.epochMilliseconds;
    return Math.floor(delta / 12);
  }
  /**
   * A method that returns sundial or solar noon. It occurs when the Sun is <a href
   * ="http://en.wikipedia.org/wiki/Transit_%28astronomy%29">transiting</a> the <a
   * href="http://en.wikipedia.org/wiki/Meridian_%28astronomy%29">celestial meridian</a>. In this class it is
   * calculated as halfway between the sunrise and sunset passed to this method. This time can be slightly off the
   * real transit time due to changes in declination (the lengthening or shortening day).
   *
   * @param {Temporal.ZonedDateTime | null} startOfDay
   *            the start of day for calculating the sun's transit. This can be sea level sunrise, visual sunrise (or
   *            any arbitrary start of day) passed to this method.
   * @param {Temporal.ZonedDateTime | null} endOfDay
   *            the end of day for calculating the sun's transit. This can be sea level sunset, visual sunset (or any
   *            arbitrary end of day) passed to this method.
   *
   * @return {Temporal.ZonedDateTime | null} The `Date` representing Sun's transit. If the calculation can't be computed such as in the
   *         Arctic Circle where there is at least one day a year where the sun does not rise, and one where it does
   *         not set, null will be returned. See detailed explanation on top of the page.
   */
  getSunTransit(startOfDay = this.getSeaLevelSunrise(), endOfDay = this.getSeaLevelSunset()) {
    const temporalHour = this.getTemporalHour(startOfDay, endOfDay);
    return _NOAACalculator.getTimeOffset(startOfDay, temporalHour * 6);
  }
  /**
   * A method that returns a `Date` from the time passed in as a parameter.
   * @protected
   * @param {number} time
   *            The time to be set as the time for the `Date`. The time expected is in the format: 18.75
   *            for 6:45:00 PM.
   * @param {boolean} isSunrise true if the time is sunrise, and false if it is sunset
   * @return {Temporal.ZonedDateTime | null} The Date.
   */
  getDateFromTime(time, isSunrise) {
    if (isNaN(time)) {
      return null;
    }
    let calculatedTime = time;
    let cal = this.getAdjustedDate();
    const hours = Math.trunc(calculatedTime);
    calculatedTime -= hours;
    const minutes = Math.trunc(calculatedTime *= 60);
    calculatedTime -= minutes;
    const seconds = Math.trunc(calculatedTime *= 60);
    calculatedTime -= seconds;
    const localTimeHours = Math.trunc(this.geoLocation.getLongitude() / 15);
    if (isSunrise && localTimeHours + hours > 18) {
      cal = cal.add({ days: -1 });
    } else if (!isSunrise && localTimeHours + hours < 6) {
      cal = cal.add({ days: 1 });
    }
    return cal.toZonedDateTime({
      timeZone: "UTC",
      plainTime: new Temporal.PlainTime(hours, minutes, seconds, Math.trunc(calculatedTime * 1e3))
    }).withTimeZone(this.geoLocation.getTimeZone());
  }
  /**
   * Return the <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> from a Java Calendar
   * @private
   * @param {Temporal.ZonedDateTime} date
   *            The Java Calendar
   * @return the Julian day corresponding to the date Note: Number is returned for start of day. Fractional days
   *         should be added later.
   */
  static getJulianDay(date) {
    let { year, month } = date;
    const { day } = date;
    if (month <= 2) {
      year -= 1;
      month += 12;
    }
    const a2 = Math.trunc(year / 100);
    const b2 = Math.trunc(2 - a2 + a2 / 4);
    return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + b2 - 1524.5;
  }
  /**
   * Convert <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a> to centuries since J2000.0.
   * @private
   * @param julianDay
   *            the Julian Day to convert
   * @return the centuries since 2000 Julian corresponding to the Julian Day
   */
  static getJulianCenturiesFromJulianDay(julianDay) {
    return (julianDay - _NOAACalculator.JULIAN_DAY_JAN_1_2000) / _NOAACalculator.JULIAN_DAYS_PER_CENTURY;
  }
  /**
   * Convert centuries since J2000.0 to <a href="http://en.wikipedia.org/wiki/Julian_day">Julian day</a>.
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @return the Julian Day corresponding to the Julian centuries passed in
   */
  static getJulianDayFromJulianCenturies(julianCenturies) {
    return julianCenturies * _NOAACalculator.JULIAN_DAYS_PER_CENTURY + _NOAACalculator.JULIAN_DAY_JAN_1_2000;
  }
  /**
   * Returns the Geometric <a href="http://en.wikipedia.org/wiki/Mean_longitude">Mean Longitude</a> of the Sun.
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @return the Geometric Mean Longitude of the Sun in degrees
   */
  static getSunGeometricMeanLongitude(julianCenturies) {
    let longitude = 280.46646 + julianCenturies * (36000.76983 + 3032e-7 * julianCenturies);
    while (longitude > 360) {
      longitude -= 360;
    }
    while (longitude < 0) {
      longitude += 360;
    }
    return longitude;
  }
  /**
   * Returns the Geometric <a href="http://en.wikipedia.org/wiki/Mean_anomaly">Mean Anomaly</a> of the Sun.
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @return the Geometric Mean Anomaly of the Sun in degrees
   */
  static getSunGeometricMeanAnomaly(julianCenturies) {
    return 357.52911 + julianCenturies * (35999.05029 - 1537e-7 * julianCenturies);
  }
  /**
   * Return the <a href="http://en.wikipedia.org/wiki/Eccentricity_%28orbit%29">eccentricity of earth's orbit</a>.
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @return the unitless eccentricity
   */
  static getEarthOrbitEccentricity(julianCenturies) {
    return 0.016708634 - julianCenturies * (42037e-9 + 1267e-10 * julianCenturies);
  }
  /**
   * Returns the <a href="http://en.wikipedia.org/wiki/Equation_of_the_center">equation of center</a> for the sun.
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @return the equation of center for the sun in degrees
   */
  static getSunEquationOfCenter(julianCenturies) {
    const m2 = _NOAACalculator.getSunGeometricMeanAnomaly(julianCenturies);
    const mrad = degreesToRadians(m2);
    const sinm = Math.sin(mrad);
    const sin2m = Math.sin(mrad + mrad);
    const sin3m = Math.sin(mrad + mrad + mrad);
    return sinm * (1.914602 - julianCenturies * (4817e-6 + 14e-6 * julianCenturies)) + sin2m * (0.019993 - 101e-6 * julianCenturies) + sin3m * 289e-6;
  }
  /**
   * Return the true longitude of the sun
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @return the sun's true longitude in degrees
   */
  static getSunTrueLongitude(julianCenturies) {
    const sunLongitude = _NOAACalculator.getSunGeometricMeanLongitude(julianCenturies);
    const center = _NOAACalculator.getSunEquationOfCenter(julianCenturies);
    return sunLongitude + center;
  }
  /**
   * Return the apparent longitude of the sun
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @return sun's apparent longitude in degrees
   */
  static getSunApparentLongitude(julianCenturies) {
    const sunTrueLongitude = _NOAACalculator.getSunTrueLongitude(julianCenturies);
    const omega = 125.04 - 1934.136 * julianCenturies;
    const lambda = sunTrueLongitude - 569e-5 - 478e-5 * Math.sin(degreesToRadians(omega));
    return lambda;
  }
  /**
   * Returns the mean <a href="http://en.wikipedia.org/wiki/Axial_tilt">obliquity of the ecliptic</a> (Axial tilt).
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @return the mean obliquity in degrees
   */
  static getMeanObliquityOfEcliptic(julianCenturies) {
    const seconds = 21.448 - julianCenturies * (46.815 + julianCenturies * (59e-5 - julianCenturies * 1813e-6));
    return 23 + (26 + seconds / 60) / 60;
  }
  /**
   * Returns the corrected <a href="http://en.wikipedia.org/wiki/Axial_tilt">obliquity of the ecliptic</a> (Axial
   * tilt).
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @return the corrected obliquity in degrees
   */
  static getObliquityCorrection(julianCenturies) {
    const obliquityOfEcliptic = _NOAACalculator.getMeanObliquityOfEcliptic(julianCenturies);
    const omega = 125.04 - 1934.136 * julianCenturies;
    return obliquityOfEcliptic + 256e-5 * Math.cos(degreesToRadians(omega));
  }
  /**
   * Return the <a href="http://en.wikipedia.org/wiki/Declination">declination</a> of the sun.
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @return
   *            the sun's declination in degrees
   */
  static getSunDeclination(julianCenturies) {
    const obliquityCorrection = _NOAACalculator.getObliquityCorrection(julianCenturies);
    const lambda = _NOAACalculator.getSunApparentLongitude(julianCenturies);
    const sint = Math.sin(degreesToRadians(obliquityCorrection)) * Math.sin(degreesToRadians(lambda));
    const theta = radiansToDegrees(Math.asin(sint));
    return theta;
  }
  /**
   * Return the <a href="http://en.wikipedia.org/wiki/Equation_of_time">Equation of Time</a> - the difference between
   * true solar time and mean solar time
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @return equation of time in minutes of time
   */
  static getEquationOfTime(julianCenturies) {
    const epsilon = _NOAACalculator.getObliquityCorrection(julianCenturies);
    const geomMeanLongSun = _NOAACalculator.getSunGeometricMeanLongitude(julianCenturies);
    const eccentricityEarthOrbit = _NOAACalculator.getEarthOrbitEccentricity(julianCenturies);
    const geomMeanAnomalySun = _NOAACalculator.getSunGeometricMeanAnomaly(julianCenturies);
    let y2 = Math.tan(degreesToRadians(epsilon) / 2);
    y2 *= y2;
    const sin2l0 = Math.sin(2 * degreesToRadians(geomMeanLongSun));
    const sinm = Math.sin(degreesToRadians(geomMeanAnomalySun));
    const cos2l0 = Math.cos(2 * degreesToRadians(geomMeanLongSun));
    const sin4l0 = Math.sin(4 * degreesToRadians(geomMeanLongSun));
    const sin2m = Math.sin(2 * degreesToRadians(geomMeanAnomalySun));
    const equationOfTime = y2 * sin2l0 - 2 * eccentricityEarthOrbit * sinm + 4 * eccentricityEarthOrbit * y2 * sinm * cos2l0 - 0.5 * y2 * y2 * sin4l0 - 1.25 * eccentricityEarthOrbit * eccentricityEarthOrbit * sin2m;
    return radiansToDegrees(equationOfTime) * 4;
  }
  /**
   * Return the <a href="http://en.wikipedia.org/wiki/Hour_angle">hour angle</a> of the sun at sunrise for the
   * latitude.
   * @private
   * @param {number} lat
   *            , the latitude of observer in degrees
   * @param solarDec
   *            the declination angle of sun in degrees
   * @param {number} zenith
   *            the zenith
   * @return hour angle of sunrise in radians
   */
  static getSunHourAngleAtSunrise(lat, solarDec, zenith) {
    const latRad = degreesToRadians(lat);
    const sdRad = degreesToRadians(solarDec);
    return Math.acos(Math.cos(degreesToRadians(zenith)) / (Math.cos(latRad) * Math.cos(sdRad)) - Math.tan(latRad) * Math.tan(sdRad));
  }
  /**
   * Returns the <a href="http://en.wikipedia.org/wiki/Hour_angle">hour angle</a> of the sun at sunset for the
   * latitude.
   * @private
   * @param {number} lat
   *            the latitude of observer in degrees
   * @param solarDec
   *            the declination angle of sun in degrees
   * @param {number} zenith
   *            the zenith
   * @return the hour angle of sunset in radians
   */
  static getSunHourAngleAtSunset(lat, solarDec, zenith) {
    const latRad = degreesToRadians(lat);
    const sdRad = degreesToRadians(solarDec);
    const hourAngle = Math.acos(Math.cos(degreesToRadians(zenith)) / (Math.cos(latRad) * Math.cos(sdRad)) - Math.tan(latRad) * Math.tan(sdRad));
    return -hourAngle;
  }
  /**
   * Return the <a href="http://en.wikipedia.org/wiki/Celestial_coordinate_system">Solar Elevation</a> for the
   * horizontal coordinate system at the given location at the given time. Can be negative if the sun is below the
   * horizon. Not corrected for altitude.
   *
   * @param {Temporal.ZonedDateTime} date
   *            time of calculation
   * @param {number} lat
   *            latitude of location for calculation
   * @param {number} lon
   *            longitude of location for calculation
   * @return {number} solar elevation in degrees - horizon is 0 degrees, civil twilight is -6 degrees
   */
  static getSolarElevation(date, lat, lon) {
    const julianDay = _NOAACalculator.getJulianDay(date.toPlainDate());
    const julianCenturies = _NOAACalculator.getJulianCenturiesFromJulianDay(julianDay);
    const equationOfTime = _NOAACalculator.getEquationOfTime(julianCenturies);
    let longitude = date.hour + 12 + (date.minute + equationOfTime + date.second / 60) / 60;
    longitude = -(longitude * 360 / 24) % 360;
    const hourAngleRad = degreesToRadians(lon - longitude);
    const declination = _NOAACalculator.getSunDeclination(julianCenturies);
    const decRad = degreesToRadians(declination);
    const latRad = degreesToRadians(lat);
    return radiansToDegrees(Math.asin(Math.sin(latRad) * Math.sin(decRad) + Math.cos(latRad) * Math.cos(decRad) * Math.cos(hourAngleRad)));
  }
  /**
   * Return the <a href="http://en.wikipedia.org/wiki/Celestial_coordinate_system">Solar Azimuth</a> for the
   * horizontal coordinate system at the given location at the given time. Not corrected for altitude. True south is 0
   * degrees.
   *
   * @param {Temporal.ZonedDateTime} date
   *            time of calculation
   * @param {number} latitude
   *            latitude of location for calculation
   * @param {number} lon
   *            longitude of location for calculation
   * @return {number}
   */
  static getSolarAzimuth(date, latitude, lon) {
    const julianDay = _NOAACalculator.getJulianDay(date.toPlainDate());
    const julianCenturies = _NOAACalculator.getJulianCenturiesFromJulianDay(julianDay);
    const equationOfTime = _NOAACalculator.getEquationOfTime(julianCenturies);
    let longitude = date.hour + 12 + (date.minute + equationOfTime + date.second / 60) / 60;
    longitude = -(longitude * 360 / 24) % 360;
    const hourAngleRad = degreesToRadians(lon - longitude);
    const declination = _NOAACalculator.getSunDeclination(julianCenturies);
    const decRad = degreesToRadians(declination);
    const latRad = degreesToRadians(latitude);
    return radiansToDegrees(Math.atan(Math.sin(hourAngleRad) / (Math.cos(hourAngleRad) * Math.sin(latRad) - Math.tan(decRad) * Math.cos(latRad)))) + 180;
  }
  /**
   * Return the <a href="http://en.wikipedia.org/wiki/Universal_Coordinated_Time">Universal Coordinated Time</a> (UTC)
   * of sunrise for the given day at the given location on earth
   * @private
   * @param julianDay
   *            the Julian day
   * @param {number} latitude
   *            the latitude of observer in degrees
   * @param {number} longitude
   *            the longitude of observer in degrees
   * @param {number} zenith
   *            the zenith
   * @return the time in minutes from zero UTC
   */
  static getSunriseUTC(julianDay, latitude, longitude, zenith) {
    const julianCenturies = _NOAACalculator.getJulianCenturiesFromJulianDay(julianDay);
    const noonmin = _NOAACalculator.getSolarNoonUTC(julianCenturies, longitude);
    const tnoon = _NOAACalculator.getJulianCenturiesFromJulianDay(julianDay + noonmin / 1440);
    let eqTime = _NOAACalculator.getEquationOfTime(tnoon);
    let solarDec = _NOAACalculator.getSunDeclination(tnoon);
    let hourAngle = _NOAACalculator.getSunHourAngleAtSunrise(latitude, solarDec, zenith);
    let delta = longitude - radiansToDegrees(hourAngle);
    let timeDiff = 4 * delta;
    let timeUTC = 720 + timeDiff - eqTime;
    const newt = _NOAACalculator.getJulianCenturiesFromJulianDay(_NOAACalculator.getJulianDayFromJulianCenturies(julianCenturies) + timeUTC / 1440);
    eqTime = _NOAACalculator.getEquationOfTime(newt);
    solarDec = _NOAACalculator.getSunDeclination(newt);
    hourAngle = _NOAACalculator.getSunHourAngleAtSunrise(latitude, solarDec, zenith);
    delta = longitude - radiansToDegrees(hourAngle);
    timeDiff = 4 * delta;
    timeUTC = 720 + timeDiff - eqTime;
    return timeUTC;
  }
  /**
   * Return the <a href="http://en.wikipedia.org/wiki/Universal_Coordinated_Time">Universal Coordinated Time</a> (UTC)
   * of <a href="http://en.wikipedia.org/wiki/Noon#Solar_noon">solar noon</a> for the given day at the given location
   * on earth.
   * @private
   * @param julianCenturies
   *            the number of Julian centuries since J2000.0
   * @param {number} longitude
   *            the longitude of observer in degrees
   * @return the time in minutes from zero UTC
   */
  static getSolarNoonUTC(julianCenturies, longitude) {
    const tnoon = _NOAACalculator.getJulianCenturiesFromJulianDay(_NOAACalculator.getJulianDayFromJulianCenturies(julianCenturies) + longitude / 360);
    let eqTime = _NOAACalculator.getEquationOfTime(tnoon);
    const solNoonUTC = 720 + longitude * 4 - eqTime;
    const newt = _NOAACalculator.getJulianCenturiesFromJulianDay(_NOAACalculator.getJulianDayFromJulianCenturies(julianCenturies) - 0.5 + solNoonUTC / 1440);
    eqTime = _NOAACalculator.getEquationOfTime(newt);
    return 720 + longitude * 4 - eqTime;
  }
  /**
   * Return the <a href="http://en.wikipedia.org/wiki/Universal_Coordinated_Time">Universal Coordinated Time</a> (UTC)
   * of sunset for the given day at the given location on earth
   * @private
   * @param julianDay
   *            the Julian day
   * @param {number} latitude
   *            the latitude of observer in degrees
   * @param {number} longitude
   *            : longitude of observer in degrees
   * @param {number} zenith
   *            the zenith
   * @return the time in minutes from zero Universal Coordinated Time (UTC)
   */
  static getSunsetUTC(julianDay, latitude, longitude, zenith) {
    const julianCenturies = _NOAACalculator.getJulianCenturiesFromJulianDay(julianDay);
    const noonmin = _NOAACalculator.getSolarNoonUTC(julianCenturies, longitude);
    const tnoon = _NOAACalculator.getJulianCenturiesFromJulianDay(julianDay + noonmin / 1440);
    let eqTime = _NOAACalculator.getEquationOfTime(tnoon);
    let solarDec = _NOAACalculator.getSunDeclination(tnoon);
    let hourAngle = _NOAACalculator.getSunHourAngleAtSunset(latitude, solarDec, zenith);
    let delta = longitude - radiansToDegrees(hourAngle);
    let timeDiff = 4 * delta;
    let timeUTC = 720 + timeDiff - eqTime;
    const newt = _NOAACalculator.getJulianCenturiesFromJulianDay(_NOAACalculator.getJulianDayFromJulianCenturies(julianCenturies) + timeUTC / 1440);
    eqTime = _NOAACalculator.getEquationOfTime(newt);
    solarDec = _NOAACalculator.getSunDeclination(newt);
    hourAngle = _NOAACalculator.getSunHourAngleAtSunset(latitude, solarDec, zenith);
    delta = longitude - radiansToDegrees(hourAngle);
    timeDiff = 4 * delta;
    timeUTC = 720 + timeDiff - eqTime;
    return timeUTC;
  }
};
NOAACalculator.GEOMETRIC_ZENITH = 90;
NOAACalculator.CIVIL_ZENITH = 96;
NOAACalculator.NAUTICAL_ZENITH = 102;
NOAACalculator.ASTRONOMICAL_ZENITH = 108;
NOAACalculator.JULIAN_DAY_JAN_1_2000 = 2451545;
NOAACalculator.JULIAN_DAYS_PER_CENTURY = 36525;

// node_modules/@hebcal/core/dist/esm/location.js
var classicCities0 = [
  ["Ashdod", "IL", 31.79213, 34.64966, "Asia/Jerusalem", 27],
  ["Atlanta", "US", 33.749, -84.38798, "America/New_York", 336],
  ["Austin", "US", 30.26715, -97.74306, "America/Chicago", 165],
  ["Baghdad", "IQ", 33.34058, 44.40088, "Asia/Baghdad", 41],
  ["Beer Sheva", "IL", 31.25181, 34.7913, "Asia/Jerusalem", 285],
  ["Berlin", "DE", 52.52437, 13.41053, "Europe/Berlin", 43],
  ["Baltimore", "US", 39.29038, -76.61219, "America/New_York", 35],
  ["Bogota", "CO", 4.60971, -74.08175, "America/Bogota", 2582],
  ["Boston", "US", 42.35843, -71.05977, "America/New_York", 38],
  ["Budapest", "HU", 47.49801, 19.03991, "Europe/Budapest", 104],
  [
    "Buenos Aires",
    "AR",
    -34.61315,
    -58.37723,
    "America/Argentina/Buenos_Aires",
    31
  ],
  ["Buffalo", "US", 42.88645, -78.87837, "America/New_York", 191],
  ["Chicago", "US", 41.85003, -87.65005, "America/Chicago", 180],
  ["Cincinnati", "US", 39.162, -84.45689, "America/New_York", 267],
  ["Cleveland", "US", 41.4995, -81.69541, "America/New_York", 204],
  ["Dallas", "US", 32.78306, -96.80667, "America/Chicago", 139],
  ["Denver", "US", 39.73915, -104.9847, "America/Denver", 1636],
  ["Detroit", "US", 42.33143, -83.04575, "America/Detroit", 192],
  ["Eilat", "IL", 29.55805, 34.94821, "Asia/Jerusalem", 63],
  ["Gibraltar", "GI", 36.14474, -5.35257, "Europe/Gibraltar", 11],
  ["Haifa", "IL", 32.81841, 34.9885, "Asia/Jerusalem", 40],
  ["Hawaii", "US", 21.30694, -157.85833, "Pacific/Honolulu", 18],
  ["Helsinki", "FI", 60.16952, 24.93545, "Europe/Helsinki", 26],
  ["Houston", "US", 29.76328, -95.36327, "America/Chicago", 30],
  ["Jerusalem", "IL", 31.76904, 35.21633, "Asia/Jerusalem", 786],
  ["Johannesburg", "ZA", -26.20227, 28.04363, "Africa/Johannesburg", 1767],
  ["Kiev", "UA", 50.45466, 30.5238, "Europe/Kiev", 187],
  ["La Paz", "BO", -16.5, -68.15, "America/La_Paz", 3782],
  ["Livingston", "US", 40.79593, -74.31487, "America/New_York", 98],
  ["Las Vegas", "US", 36.17497, -115.13722, "America/Los_Angeles", 613],
  ["London", "GB", 51.50853, -0.12574, "Europe/London", 25],
  ["Los Angeles", "US", 34.05223, -118.24368, "America/Los_Angeles", 96],
  ["Marseilles", "FR", 43.29695, 5.38107, "Europe/Paris", 28],
  ["Miami", "US", 25.77427, -80.19366, "America/New_York", 25],
  ["Minneapolis", "US", 44.97997, -93.26384, "America/Chicago", 262],
  ["Melbourne", "AU", -37.814, 144.96332, "Australia/Melbourne", 25],
  ["Mexico City", "MX", 19.42847, -99.12766, "America/Mexico_City", 2240],
  ["Montreal", "CA", 45.50884, -73.58781, "America/Toronto", 216],
  ["Moscow", "RU", 55.75222, 37.61556, "Europe/Moscow", 144],
  ["New York", "US", 40.71427, -74.00597, "America/New_York", 57],
  ["Omaha", "US", 41.25861, -95.93779, "America/Chicago", 315],
  ["Ottawa", "CA", 45.41117, -75.69812, "America/Toronto", 71],
  ["Panama City", "PA", 8.9936, -79.51973, "America/Panama", 17],
  ["Paris", "FR", 48.85341, 2.3488, "Europe/Paris", 42],
  ["Pawtucket", "US", 41.87871, -71.38256, "America/New_York", 0],
  // -11
  ["Petach Tikvah", "IL", 32.08707, 34.88747, "Asia/Jerusalem", 54],
  ["Philadelphia", "US", 39.95233, -75.16379, "America/New_York", 8],
  ["Phoenix", "US", 33.44838, -112.07404, "America/Phoenix", 366],
  ["Pittsburgh", "US", 40.44062, -79.99589, "America/New_York", 239],
  ["Providence", "US", 41.82399, -71.41283, "America/New_York", 0],
  // -15
  ["Portland", "US", 45.52345, -122.67621, "America/Los_Angeles", 15],
  ["Saint Louis", "US", 38.62727, -90.19789, "America/Chicago", 149],
  ["Saint Petersburg", "RU", 59.93863, 30.31413, "Europe/Moscow", 11],
  ["San Diego", "US", 32.71533, -117.15726, "America/Los_Angeles", 20],
  ["San Francisco", "US", 37.77493, -122.41942, "America/Los_Angeles", 28],
  ["Sao Paulo", "BR", -23.5475, -46.63611, "America/Sao_Paulo", 769],
  ["Seattle", "US", 47.60621, -122.33207, "America/Los_Angeles", 56],
  ["Sydney", "AU", -33.86785, 151.20732, "Australia/Sydney", 58],
  ["Tel Aviv", "IL", 32.08088, 34.78057, "Asia/Jerusalem", 15],
  ["Tiberias", "IL", 32.79221, 35.53124, "Asia/Jerusalem", 0],
  // -140
  ["Toronto", "CA", 43.70011, -79.4163, "America/Toronto", 175],
  ["Vancouver", "CA", 49.24966, -123.11934, "America/Vancouver", 70],
  ["White Plains", "US", 41.03399, -73.76291, "America/New_York", 82],
  ["Washington DC", "US", 38.89511, -77.03637, "America/New_York", 6],
  ["Worcester", "US", 42.26259, -71.80229, "America/New_York", 164]
];
var classicCities = /* @__PURE__ */ new Map();
var ZIPCODES_TZ_MAP = {
  "0": "UTC",
  "4": "America/Puerto_Rico",
  // Atlantic (GMT -04:00)
  "5": "America/New_York",
  //    Eastern  (GMT -05:00)
  "6": "America/Chicago",
  //     Central  (GMT -06:00)
  "7": "America/Denver",
  //      Mountain (GMT -07:00)
  "8": "America/Los_Angeles",
  // Pacific  (GMT -08:00)
  "9": "America/Anchorage",
  //   Alaska   (GMT -09:00)
  "10": "Pacific/Honolulu",
  //   Hawaii-Aleutian Islands (GMT -10:00)
  "11": "Pacific/Pago_Pago",
  //  American Samoa (GMT -11:00)
  "13": "Pacific/Funafuti",
  //   Marshall Islands (GMT +12:00)
  "14": "Pacific/Guam",
  //       Guam     (GMT +10:00)
  "15": "Pacific/Palau",
  //      Palau    (GMT +9:00)
  "16": "Pacific/Chuuk"
  //      Micronesia (GMT +11:00)
};
var timeFormatCache = /* @__PURE__ */ new Map();
function getFormatter2(tzid) {
  const fmt = timeFormatCache.get(tzid);
  if (fmt)
    return fmt;
  const f2 = new Intl.DateTimeFormat("en-US", {
    timeZone: tzid,
    hour: "numeric",
    minute: "numeric",
    hour12: false
  });
  timeFormatCache.set(tzid, f2);
  return f2;
}
var Location = class extends GeoLocation {
  /**
   * Initialize a Location instance
   * @param latitude - Latitude as a decimal, valid range -90 thru +90 (e.g. 41.85003)
   * @param longitude - Longitude as a decimal, valid range -180 thru +180 (e.g. -87.65005)
   * @param il - in Israel (true) or Diaspora (false)
   * @param tzid - Olson timezone ID, e.g. "America/Chicago"
   * @param [cityName] - optional descriptive city name
   * @param [countryCode] - ISO 3166 alpha-2 country code (e.g. "FR")
   * @param [geoid] - optional string or numeric geographic ID
   * @param [elevation] - in meters (default `0`)
   */
  constructor(latitude, longitude, il, tzid, cityName, countryCode, geoid, elevation) {
    const lat = typeof latitude === "number" ? latitude : parseFloat(latitude);
    if (isNaN(lat) || lat < -90 || lat > 90) {
      throw new RangeError(`Latitude ${latitude} out of range [-90,90]`);
    }
    const long = typeof longitude === "number" ? longitude : parseFloat(longitude);
    if (isNaN(long) || long < -180 || long > 180) {
      throw new RangeError(`Longitude ${longitude} out of range [-180,180]`);
    }
    if (!tzid) {
      throw new RangeError(`Invalid timezone`);
    }
    const elev = typeof elevation === "number" && elevation > 0 ? elevation : 0;
    super(cityName || null, lat, long, elev, tzid);
    this.il = Boolean(il);
    this.cc = countryCode;
    this.geoid = geoid;
  }
  getIsrael() {
    return this.il;
  }
  getName() {
    return this.getLocationName();
  }
  /**
   * Returns the location name, up to the first comma
   */
  getShortName() {
    const name = this.getLocationName();
    if (!name)
      return name;
    const comma = name.indexOf(", ");
    if (comma === -1)
      return name;
    if (this.cc === "US" && name[comma + 2] === "D") {
      if (name[comma + 3] === "C") {
        return name.substring(0, comma + 4);
      } else if (name[comma + 3] === "." && name[comma + 4] === "C") {
        return name.substring(0, comma + 6);
      }
    }
    return name.substring(0, comma);
  }
  getCountryCode() {
    return this.cc;
  }
  getTzid() {
    return this.getTimeZone();
  }
  /**
   * Gets a 24-hour time formatter (e.g. 07:41 or 20:03) for this location
   */
  getTimeFormatter() {
    return getFormatter2(this.getTimeZone());
  }
  getGeoId() {
    return this.geoid;
  }
  /**
   * Creates a location object from one of 60 "classic" Hebcal city names.
   * The following city names are supported:
   * 'Ashdod', 'Atlanta', 'Austin', 'Baghdad', 'Beer Sheva',
   * 'Berlin', 'Baltimore', 'Bogota', 'Boston', 'Budapest',
   * 'Buenos Aires', 'Buffalo', 'Chicago', 'Cincinnati', 'Cleveland',
   * 'Dallas', 'Denver', 'Detroit', 'Eilat', 'Gibraltar', 'Haifa',
   * 'Hawaii', 'Helsinki', 'Houston', 'Jerusalem', 'Johannesburg',
   * 'Kiev', 'La Paz', 'Livingston', 'Las Vegas', 'London', 'Los Angeles',
   * 'Marseilles', 'Miami', 'Minneapolis', 'Melbourne', 'Mexico City',
   * 'Montreal', 'Moscow', 'New York', 'Omaha', 'Ottawa', 'Panama City',
   * 'Paris', 'Pawtucket', 'Petach Tikvah', 'Philadelphia', 'Phoenix',
   * 'Pittsburgh', 'Providence', 'Portland', 'Saint Louis', 'Saint Petersburg',
   * 'San Diego', 'San Francisco', 'Sao Paulo', 'Seattle', 'Sydney',
   * 'Tel Aviv', 'Tiberias', 'Toronto', 'Vancouver', 'White Plains',
   * 'Washington DC', 'Worcester'
   * @param name
   */
  static lookup(name) {
    return classicCities.get(name.toLowerCase());
  }
  toString() {
    return JSON.stringify(this);
  }
  /**
   * Converts legacy Hebcal timezone to a standard Olson tzid.
   * @param tz integer, GMT offset in hours
   * @param dst 'none', 'eu', 'usa', or 'israel'
   */
  static legacyTzToTzid(tz, dst) {
    tz = +tz;
    if (dst === "none") {
      if (tz === 0) {
        return "UTC";
      } else {
        const plus = tz > 0 ? "+" : "";
        return `Etc/GMT${plus}${tz}`;
      }
    } else if (tz === 2 && dst === "israel") {
      return "Asia/Jerusalem";
    } else if (dst === "eu") {
      switch (tz) {
        case -2:
          return "Atlantic/Cape_Verde";
        case -1:
          return "Atlantic/Azores";
        case 0:
          return "Europe/London";
        case 1:
          return "Europe/Paris";
        case 2:
          return "Europe/Athens";
      }
    } else if (dst === "usa") {
      return ZIPCODES_TZ_MAP[String(tz * -1)];
    }
    return void 0;
  }
  /**
   * Converts timezone info from Zip-Codes.com to a standard Olson tzid.
   * @example
   * Location.getUsaTzid('AZ', 7, 'Y') // 'America/Denver'
   * @param state two-letter all-caps US state abbreviation like 'CA'
   * @param tz positive number, 5=America/New_York, 8=America/Los_Angeles
   * @param dst single char 'Y' or 'N'
   */
  static getUsaTzid(state, tz, dst) {
    tz = +tz;
    if (tz === 10 && state === "AK") {
      return "America/Adak";
    } else if (tz === 7 && state === "AZ") {
      return dst === "Y" ? "America/Denver" : "America/Phoenix";
    } else {
      return ZIPCODES_TZ_MAP[tz];
    }
  }
  /**
   * Adds a location name for `Location.lookup()` only if the name isn't
   * already being used. Returns `false` if the name is already taken
   * and `true` if successfully added.
   */
  static addLocation(cityName, location) {
    const name = cityName.toLowerCase();
    if (classicCities.has(name)) {
      return false;
    }
    classicCities.set(name, location);
    return true;
  }
};
for (const city of classicCities0) {
  const location = new Location(city[2], city[3], city[1] === "IL", city[4], city[0], city[1], void 0, city[5]);
  Location.addLocation(city[0], location);
}

// node_modules/@hebcal/core/dist/esm/zmanim.js
function zdtToDate(zdt) {
  if (zdt === null) {
    return /* @__PURE__ */ new Date(NaN);
  }
  const res = new Date(zdt.epochMilliseconds);
  res.setMilliseconds(0);
  return res;
}
function getDate(date) {
  if (isDate(date))
    return date;
  if (HDate.isHDate(date))
    return date.greg();
  throw new TypeError(`invalid date: ${date}`);
}
var Zmanim = class _Zmanim {
  /**
   * Initialize a Zmanim instance.
   * @param gloc GeoLocation including latitude, longitude, and timezone
   * @param date Regular or Hebrew Date. If `date` is a regular `Date`,
   *    hours, minutes, seconds and milliseconds are ignored.
   * @param useElevation use elevation for calculations (default `false`).
   *    If `true`, use elevation to affect the calculation of all sunrise/sunset based
   *    zmanim. Note: there are some zmanim such as degree-based zmanim that are driven
   *    by the amount of light in the sky and are not impacted by elevation.
   *    These zmanim intentionally do not support elevation adjustment.
   */
  constructor(gloc, date, useElevation) {
    const dt2 = getDate(date);
    this.date = dt2;
    this.gloc = gloc;
    const plainDate = Temporal.PlainDate.from({
      year: dt2.getFullYear(),
      month: dt2.getMonth() + 1,
      day: dt2.getDate()
    });
    this.noaa = new NOAACalculator(gloc, plainDate);
    this.useElevation = Boolean(useElevation);
  }
  /**
   * Returns `true` if elevation adjustment is enabled
   * for zmanim support elevation adjustment
   */
  getUseElevation() {
    return this.useElevation;
  }
  /**
   * Enables or disables elevation adjustment for zmanim support elevation adjustment
   * @param useElevation
   */
  setUseElevation(useElevation) {
    this.useElevation = useElevation;
  }
  /**
   * Convenience function to get the time when sun is above or below the horizon
   * for a certain angle (in degrees).
   * This function does not support elevation adjustment.
   * @param angle
   * @param rising
   */
  timeAtAngle(angle, rising) {
    const offsetZenith = 90 + angle;
    const zdt = rising ? this.noaa.getSunriseOffsetByDegrees(offsetZenith) : this.noaa.getSunsetOffsetByDegrees(offsetZenith);
    return zdtToDate(zdt);
  }
  /**
   * Upper edge of the Sun appears over the eastern horizon in the morning (0.833° above horizon)
   * If elevation is enabled, this function will include elevation in the calculation.
   */
  sunrise() {
    const zdt = this.useElevation ? this.noaa.getSunrise() : this.noaa.getSeaLevelSunrise();
    return zdtToDate(zdt);
  }
  /**
   * Upper edge of the Sun appears over the eastern horizon in the morning (0.833° above horizon).
   * This function does not support elevation adjustment.
   */
  seaLevelSunrise() {
    const zdt = this.noaa.getSeaLevelSunrise();
    return zdtToDate(zdt);
  }
  /**
   * When the upper edge of the Sun disappears below the horizon (0.833° below horizon).
   * If elevation is enabled, this function will include elevation in the calculation.
   */
  sunset() {
    const zdt = this.useElevation ? this.noaa.getSunset() : this.noaa.getSeaLevelSunset();
    return zdtToDate(zdt);
  }
  /**
   * When the upper edge of the Sun disappears below the horizon (0.833° below horizon).
   * This function does not support elevation adjustment.
   */
  seaLevelSunset() {
    const zdt = this.noaa.getSeaLevelSunset();
    return zdtToDate(zdt);
  }
  /**
   * Civil dawn; Sun is 6° below the horizon in the morning.
   * Because degree-based functions estimate the amount of light in the sky,
   * the result is not impacted by elevation.
   */
  dawn() {
    const zdt = this.noaa.getBeginCivilTwilight();
    return zdtToDate(zdt);
  }
  /**
   * Civil dusk; Sun is 6° below the horizon in the evening.
   * Because degree-based functions estimate the amount of light in the sky,
   * the result is not impacted by elevation.
   */
  dusk() {
    const zdt = this.noaa.getEndCivilTwilight();
    return zdtToDate(zdt);
  }
  /**
   * Returns sunset for the previous day.
   * If elevation is enabled, this function will include elevation in the calculation.
   */
  gregEve() {
    const prev = new Date(this.date);
    prev.setDate(prev.getDate() - 1);
    const zman = new _Zmanim(this.gloc, prev, this.useElevation);
    return zman.sunset();
  }
  /**
   * @private
   */
  nightHour() {
    return (this.sunrise().getTime() - this.gregEve().getTime()) / 12;
  }
  /**
   * Midday – Chatzot; Sunrise plus 6 halachic hours
   */
  chatzot() {
    const startOfDay = this.noaa.getSeaLevelSunrise();
    const endOfDay = this.noaa.getSeaLevelSunset();
    const zdt = this.noaa.getSunTransit(startOfDay, endOfDay);
    return zdtToDate(zdt);
  }
  /**
   * Midnight – Chatzot; Sunset plus 6 halachic hours.
   * If elevation is enabled, this function will include elevation in the calculation.
   */
  chatzotNight() {
    return new Date(this.sunrise().getTime() - this.nightHour() * 6);
  }
  /**
   * Dawn – Alot haShachar; Sun is 16.1° below the horizon in the morning.
   * Because degree-based functions estimate the amount of light in the sky,
   * the result is not impacted by elevation.
   */
  alotHaShachar() {
    return this.timeAtAngle(16.1, true);
  }
  /**
   * Dawn – Alot haShachar; calculated as 72 minutes before sunrise or
   * sea level sunrise.
   */
  alotHaShachar72() {
    return this.sunriseOffset(-72, false, false);
  }
  /**
   * Earliest talis & tefillin – Misheyakir; Sun is 11.5° below the horizon in the morning.
   * Because degree-based functions estimate the amount of light in the sky,
   * the result is not impacted by elevation.
   */
  misheyakir() {
    return this.timeAtAngle(11.5, true);
  }
  /**
   * Earliest talis & tefillin – Misheyakir Machmir; Sun is 10.2° below the horizon in the morning.
   * Because degree-based functions estimate the amount of light in the sky,
   * the result is not impacted by elevation.
   */
  misheyakirMachmir() {
    return this.timeAtAngle(10.2, true);
  }
  /**
   * Utility method for using elevation-aware sunrise/sunset
   * @private
   * @param hours
   */
  getShaahZmanisBasedZman(hours) {
    const startOfDay = this.useElevation ? this.noaa.getSunrise() : this.noaa.getSeaLevelSunrise();
    const endOfDay = this.useElevation ? this.noaa.getSunset() : this.noaa.getSeaLevelSunset();
    const temporalHour = this.noaa.getTemporalHour(startOfDay, endOfDay);
    const offset = Math.round(temporalHour * hours);
    const zdt = NOAACalculator.getTimeOffset(startOfDay, offset);
    return zdtToDate(zdt);
  }
  /**
   * Latest Shema (Gra); Sunrise plus 3 halachic hours, according to the Gra.
   * If elevation is enabled, this function will include elevation in the calculation.
   */
  sofZmanShma() {
    return this.getShaahZmanisBasedZman(3);
  }
  /**
   * Latest Shacharit (Gra); Sunrise plus 4 halachic hours, according to the Gra.
   *
   * This method returns the latest *zman tfila* (time to recite shema in the morning)
   * that is 4 *shaos zmaniyos* (solar hours) after sunrise or sea level sunrise
   * (depending on the `useElevation` setting), according
   * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).
   *
   * If elevation is enabled, this function will include elevation in the calculation.
   */
  sofZmanTfilla() {
    return this.getShaahZmanisBasedZman(4);
  }
  /**
   * Returns an array with alot (Date) and ms in hour (number)
   * @private
   */
  getTemporalHour72(forceSeaLevel) {
    const alot72 = this.sunriseOffset(-72, false, forceSeaLevel);
    const tzeit72 = this.sunsetOffset(72, false, forceSeaLevel);
    const temporalHour = (tzeit72.getTime() - alot72.getTime()) / 12;
    return [alot72, temporalHour];
  }
  /**
   * Returns an array with alot (Date) and ms in hour (number)
   * @private
   */
  getTemporalHourByDeg(angle) {
    const alot = this.timeAtAngle(angle, true);
    const tzeit = this.timeAtAngle(angle, false);
    const temporalHour = (tzeit.getTime() - alot.getTime()) / 12;
    return [alot, temporalHour];
  }
  /**
   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham.
   * Based on the opinion of the MGA that the day is calculated from
   * dawn being fixed 72 minutes before sea-level sunrise, and nightfall is fixed
   * 72 minutes after sea-level sunset.
   */
  sofZmanShmaMGA() {
    const [alot72, temporalHour] = this.getTemporalHour72(true);
    const offset = Math.floor(3 * temporalHour);
    return new Date(alot72.getTime() + offset);
  }
  /**
   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham.
   * Based on the opinion of the MGA that the day is calculated from
   * dawn to nightfall with both being 16.1° below the horizon.
   */
  sofZmanShmaMGA16Point1() {
    const [alot, temporalHour] = this.getTemporalHourByDeg(16.1);
    const offset = Math.floor(3 * temporalHour);
    return new Date(alot.getTime() + offset);
  }
  /**
   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham.
   * Based on the opinion of the MGA that the day is calculated from
   * dawn to nightfall with both being 19.8° below the horizon.
   *
   * This calculation is based on the position of the sun 90 minutes after sunset in Jerusalem
   * around the equinox / equilux which calculates to 19.8° below geometric zenith.
   * https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/
   */
  sofZmanShmaMGA19Point8() {
    const [alot, temporalHour] = this.getTemporalHourByDeg(19.8);
    const offset = Math.floor(3 * temporalHour);
    return new Date(alot.getTime() + offset);
  }
  /**
   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham
   */
  sofZmanTfillaMGA() {
    const [alot72, temporalHour] = this.getTemporalHour72(true);
    const offset = Math.floor(4 * temporalHour);
    return new Date(alot72.getTime() + offset);
  }
  /**
   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham.
   * Based on the opinion of the MGA that the day is calculated from
   * dawn to nightfall with both being 16.1° below the horizon.
   */
  sofZmanTfillaMGA16Point1() {
    const [alot, temporalHour] = this.getTemporalHourByDeg(16.1);
    const offset = Math.floor(4 * temporalHour);
    return new Date(alot.getTime() + offset);
  }
  /**
   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham.
   * Based on the opinion of the MGA that the day is calculated from
   * dawn to nightfall with both being 19.8° below the horizon.
   *
   * This calculation is based on the position of the sun 90 minutes after sunset in Jerusalem
   * around the equinox / equilux which calculates to 19.8° below geometric zenith.
   * https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/
   */
  sofZmanTfillaMGA19Point8() {
    const [alot, temporalHour] = this.getTemporalHourByDeg(19.8);
    const offset = Math.floor(4 * temporalHour);
    return new Date(alot.getTime() + offset);
  }
  /**
   * Earliest Mincha – Mincha Gedola (GRA); Sunrise plus 6.5 halachic hours.
   * If elevation is enabled, this function will include elevation in the calculation.
   *
   * This method returns the latest mincha gedola, the earliest time one can pray mincha
   * that is 6.5 shaos zmaniyos (solar hours) after sunrise or sea level sunrise
   * (depending on the `useElevation` setting), according
   * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).
   *
   * The Ramba"m is of the opinion that it is better to delay *mincha* until
   * *mincha ketana* while the Ra"sh, Tur, GRA and others are of the
   * opinion that *mincha* can be prayed *lechatchila* starting at *mincha gedola*.
   */
  minchaGedola() {
    return this.getShaahZmanisBasedZman(6.5);
  }
  /**
   * Earliest Mincha – Mincha Gedola (MGA); Sunrise plus 6.5 halachic hours.
   * If elevation is enabled, this function will include elevation in the calculation.
   *
   * This method returns the time of *mincha gedola* according to the Magen Avraham
   * with the day starting 72 minutes before sunrise and ending 72 minutes after sunset.
   * This is the earliest time to pray *mincha*.
   */
  minchaGedolaMGA() {
    const [alot72, temporalHour] = this.getTemporalHour72(false);
    const offset = Math.floor(6.5 * temporalHour);
    return new Date(alot72.getTime() + offset);
  }
  /**
   * Preferable earliest time to recite Minchah – Mincha Ketana; Sunrise plus 9.5 halachic hours.
   * If elevation is enabled, this function will include elevation in the calculation.
   *
   * This method returns *mincha ketana*, the preferred earliest time to pray *mincha* in the
   * opinion of the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others,
   * that is 9.5 *shaos zmaniyos* (solar hours) after sunrise or sea level sunrise
   * (depending on the `useElevation` setting), according
   * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).
   */
  minchaKetana() {
    return this.getShaahZmanisBasedZman(9.5);
  }
  /**
   * This method returns the time of *mincha ketana* according to the Magen Avraham
   * with the day starting 72 minutes before sunrise and ending 72 minutes after sunset.
   * This is the preferred earliest time to pray *mincha* according to the opinion of
   * the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others.
   *
   * If elevation is enabled, this function will include elevation in the calculation.
   */
  minchaKetanaMGA() {
    const [alot72, temporalHour] = this.getTemporalHour72(false);
    return new Date(alot72.getTime() + Math.floor(9.5 * temporalHour));
  }
  /**
   * Plag haMincha; Sunrise plus 10.75 halachic hours.
   * If elevation is enabled, this function will include elevation in the calculation.
   */
  plagHaMincha() {
    return this.getShaahZmanisBasedZman(10.75);
  }
  /**
   * @param [angle=8.5] optional time for solar depression.
   *   Default is 8.5 degrees for 3 small stars, use 7.083 degrees for 3 medium-sized stars.
   * Because degree-based functions estimate the amount of light in the sky,
   * the result is not impacted by elevation.
   */
  tzeit(angle = 8.5) {
    return this.timeAtAngle(angle, false);
  }
  /**
   * Alias for sunrise
   */
  neitzHaChama() {
    return this.sunrise();
  }
  /**
   * Alias for sunset
   */
  shkiah() {
    return this.sunset();
  }
  /**
   * Rabbeinu Tam holds that bein hashmashos is a specific time
   * between sunset and tzeis hakochavim.
   * One opinion on how to calculate this time is that
   * it is 13.5 minutes before tzies 7.083.
   * Because degree-based functions estimate the amount of light in the sky,
   * the result is not impacted by elevation.
   */
  beinHaShmashos() {
    const tzeit = this.tzeit(7.083);
    const millis = tzeit.getTime();
    if (isNaN(millis)) {
      return tzeit;
    }
    return new Date(millis - 13.5 * 60 * 1e3);
  }
  /**
   * Uses timeFormat to return a date like '20:34'.
   * Returns `XX:XX` if the date is invalid.
   */
  static formatTime(dt2, timeFormat) {
    if (isNaN(dt2.getTime())) {
      return "XX:XX";
    }
    const time = timeFormat.format(dt2);
    const hm = time.split(":");
    if (hm[0] === "24") {
      return "00:" + hm[1];
    }
    return time;
  }
  /**
   * Discards seconds, rounding to nearest minute.
   * @param dt
   */
  static roundTime(dt2) {
    const millis = dt2.getTime();
    if (isNaN(millis)) {
      return dt2;
    }
    const millisOnly = dt2.getMilliseconds();
    const seconds = dt2.getSeconds();
    if (seconds === 0 && millisOnly === 0) {
      return dt2;
    }
    const secAndMillis = seconds * 1e3 + millisOnly;
    const delta = secAndMillis >= 3e4 ? 6e4 - secAndMillis : -1 * secAndMillis;
    return new Date(millis + delta);
  }
  /**
   * Get offset string (like "+05:00" or "-08:00") from tzid (like "Europe/Moscow")
   * @param tzid
   * @param date
   */
  static timeZoneOffset(tzid, date) {
    const offset = getTimezoneOffset(tzid, date);
    const offsetAbs = Math.abs(offset);
    const hours = Math.floor(offsetAbs / 60);
    const minutes = offsetAbs % 60;
    return (offset < 0 ? "+" : "-") + pad2(hours) + ":" + pad2(minutes);
  }
  /**
   * Returns a string like "2022-04-01T13:06:00-11:00"
   * @param tzid
   * @param date
   */
  static formatISOWithTimeZone(tzid, date) {
    if (isNaN(date.getTime())) {
      return "0000-00-00T00:00:00Z";
    }
    return getPseudoISO(tzid, date).substring(0, 19) + _Zmanim.timeZoneOffset(tzid, date);
  }
  /**
   * Returns sunrise + `offset` minutes (either positive or negative).
   * If elevation is enabled, this function will include elevation in the calculation
   *  unless `forceSeaLevel` is `true`.
   * @param offset minutes
   * @param roundMinute round time to nearest minute (default true)
   * @param forceSeaLevel use sea-level sunrise (default false)
   */
  sunriseOffset(offset, roundMinute = true, forceSeaLevel = false) {
    const sunrise = forceSeaLevel ? this.seaLevelSunrise() : this.sunrise();
    if (isNaN(sunrise.getTime())) {
      return sunrise;
    }
    if (roundMinute) {
      if (offset > 0 && sunrise.getSeconds() >= 30) {
        offset++;
      }
      sunrise.setSeconds(0, 0);
    }
    return new Date(sunrise.getTime() + offset * 60 * 1e3);
  }
  /**
   * Returns sunset + `offset` minutes (either positive or negative).
   * If elevation is enabled, this function will include elevation in the calculation
   *  unless `forceSeaLevel` is `true`.
   * @param offset minutes
   * @param roundMinute round time to nearest minute (default true)
   * @param forceSeaLevel use sea-level sunset (default false)
   */
  sunsetOffset(offset, roundMinute = true, forceSeaLevel = false) {
    const sunset = forceSeaLevel ? this.seaLevelSunset() : this.sunset();
    if (isNaN(sunset.getTime())) {
      return sunset;
    }
    if (roundMinute) {
      if (offset > 0 && sunset.getSeconds() >= 30) {
        offset++;
      }
      sunset.setSeconds(0, 0);
    }
    return new Date(sunset.getTime() + offset * 60 * 1e3);
  }
  /**
   * Returns the Hebrew date relative to the specified location and Gregorian date,
   * taking into consideration whether the time is before or after sunset.
   *
   * For example, if the given date and is `2024-09-22T10:35` (before sunset), and
   * sunset for the specified location is **19:04**, then this function would
   * return a Hebrew date of `19th of Elul, 5784`.
   * If the given date is the same Gregorian day after sunset
   * (for example `2024-09-22T20:07`), this function would return a
   * Hebrew date of `20th of Elul, 5784`.
   * @example
   * const {GeoLocation, Zmanim, HDate} = require('@hebcal/core');
   * const latitude = 48.85341;
   * const longitude = 2.3488;
   * const timezone = 'Europe/Paris';
   * const gloc = new GeoLocation(null, latitude, longitude, 0, timezone);
   * const before = Zmanim.makeSunsetAwareHDate(gloc, new Date('2024-09-22T17:38:46.123Z'), false);
   * console.log(before.toString()); // '19 Elul 5784'
   * const after = Zmanim.makeSunsetAwareHDate(gloc, new Date('2024-09-22T23:45:18.345Z'), false);
   * console.log(after.toString()); // '20 Elul 5784'
   */
  static makeSunsetAwareHDate(gloc, date, useElevation) {
    const zmanim = new _Zmanim(gloc, date, useElevation);
    const sunset = zmanim.sunset();
    let hd = new HDate(date);
    const sunsetMillis = sunset.getTime();
    if (isNaN(sunsetMillis)) {
      return hd;
    }
    if (date.getTime() >= sunsetMillis) {
      hd = hd.next();
    }
    return hd;
  }
};

// node_modules/quick-lru/index.js
var QuickLRU = class extends Map {
  constructor(options = {}) {
    super();
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  // TODO: Use private class methods when targeting Node.js 16.
  _emitEvictions(cache) {
    if (typeof this.onEviction !== "function") {
      return;
    }
    for (const [key, item] of cache) {
      this.onEviction(key, item.value);
    }
  }
  _deleteIfExpired(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof this.onEviction === "function") {
        this.onEviction(key, item.value);
      }
      return this.delete(key);
    }
    return false;
  }
  _getOrDeleteIfExpired(key, item) {
    const deleted = this._deleteIfExpired(key, item);
    if (deleted === false) {
      return item.value;
    }
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache) {
    const item = cache.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value) {
    this.cache.set(key, value);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      this._emitEvictions(this.oldCache);
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key);
    this._set(key, item);
  }
  *_entriesAscending() {
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield item;
      }
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      const item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === false) {
        this._moveToRecent(key, item);
        return item.value;
      }
    }
  }
  set(key, value, { maxAge = this.maxAge } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (this.cache.has(key)) {
      this.cache.set(key, {
        value,
        expiry
      });
    } else {
      this._set(key, { value, expiry });
    }
    return this;
  }
  has(key) {
    if (this.cache.has(key)) {
      return !this._deleteIfExpired(key, this.cache.get(key));
    }
    if (this.oldCache.has(key)) {
      return !this._deleteIfExpired(key, this.oldCache.get(key));
    }
    return false;
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this._peek(key, this.cache);
    }
    if (this.oldCache.has(key)) {
      return this._peek(key, this.oldCache);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...this._entriesAscending()];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      this.cache = new Map(items);
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = items.length;
    } else {
      if (removeCount > 0) {
        this._emitEvictions(items.slice(0, removeCount));
      }
      this.oldCache = new Map(items.slice(removeCount));
      this.cache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    this.maxSize = newSize;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    items = [...this.oldCache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value] of this._entriesAscending()) {
      yield [key, value.value];
    }
  }
  get size() {
    if (!this._size) {
      return this.oldCache.size;
    }
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
};

// node_modules/@hebcal/core/dist/esm/modern.js
var SUN = 0;
var TUE = 2;
var FRI = 5;
var SAT = 6;
var NISAN3 = months.NISAN;
var IYYAR2 = months.IYYAR;
function dateYomHaShoah(year) {
  if (year < 5711) {
    return null;
  }
  let nisan27dt = new HDate(27, NISAN3, year);
  if (nisan27dt.getDay() === FRI) {
    nisan27dt = new HDate(26, NISAN3, year);
  } else if (nisan27dt.getDay() === SUN) {
    nisan27dt = new HDate(28, NISAN3, year);
  }
  return nisan27dt;
}
function dateYomHaZikaron(year) {
  if (year < 5708) {
    return null;
  }
  let day;
  const pesach = new HDate(15, NISAN3, year);
  const pdow = pesach.getDay();
  if (pdow === SUN) {
    day = 2;
  } else if (pdow === SAT) {
    day = 3;
  } else if (year < 5764) {
    day = 4;
  } else if (pdow === TUE) {
    day = 5;
  } else {
    day = 4;
  }
  return new HDate(day, IYYAR2, year);
}

// node_modules/@hebcal/core/dist/esm/parshaName.js
function renderParshaName(parsha, locale) {
  const locale0 = locale !== null && locale !== void 0 ? locale : Locale.getLocaleName();
  let name = Locale.gettext(parsha[0], locale0);
  if (parsha.length === 2) {
    const hyphen = locale0 === "he" ? "־" : "-";
    name += hyphen + Locale.gettext(parsha[1], locale0);
  }
  name = name.replace(/'/g, "’");
  const str = Locale.gettext("Parashat", locale) + " " + name;
  return str.normalize();
}

// node_modules/@hebcal/core/dist/esm/sedra.js
var INCOMPLETE = 0;
var REGULAR = 1;
var COMPLETE = 2;
function yearType(hyear) {
  const longC = HDate.longCheshvan(hyear);
  const shortK = HDate.shortKislev(hyear);
  if (longC && !shortK) {
    return COMPLETE;
  } else if (!longC && shortK) {
    return INCOMPLETE;
  } else {
    return REGULAR;
  }
}
var Sedra = class {
  /**
   * Caculates the Parashah HaShavua for an entire Hebrew year
   * @param hyear - Hebrew year (e.g. 5749)
   * @param il - Use Israel sedra schedule (false for Diaspora)
   */
  constructor(hyear, il) {
    hyear = +hyear;
    this.year = hyear;
    const rh0 = new HDate(1, months.TISHREI, hyear);
    const rh = rh0.abs();
    const rhDay = rh0.getDay() + 1;
    this.firstSaturday = HDate.dayOnOrBefore(6, rh + 6);
    const leap = +HDate.isLeapYear(hyear);
    this.il = Boolean(il);
    const type = yearType(hyear);
    let key = `${leap}${rhDay}${type}`;
    if (types[key]) {
      this.theSedraArray = types[key];
      this.yearKey = key;
    } else {
      key = key + +this.il;
      this.theSedraArray = types[key];
      this.yearKey = key;
    }
    if (!this.theSedraArray) {
      throw new Error(`improper sedra year type ${key} calculated for ${hyear}`);
    }
  }
  /**
   * Returns the parsha (or parshiyot) read on Hebrew date
   * @deprecated Use {@link lookup} instead
   * @param hd Hebrew date or R.D. days
   */
  get(hd) {
    return this.lookup(hd).parsha;
  }
  /**
   * Looks up parsha for the date, then returns a translated or transliterated string
   * @deprecated Use {@link lookup} instead
   * @param hd Hebrew date or R.D. days
   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale
   */
  getString(hd, locale) {
    const parsha = this.get(hd);
    return renderParshaName(parsha, locale);
  }
  /**
   * Checks to see if this day would be a regular parasha HaShavua
   * Torah reading or special holiday reading
   * @deprecated Use {@link lookup} instead
   * @param hd Hebrew date or R.D. days
   */
  isParsha(hd) {
    return !this.lookup(hd).chag;
  }
  /**
   * Returns the date that a parsha occurs
   * or `null` if the parsha doesn't occur this year
   * @param parsha if a `string`, specified with Sephardic transliterations
   *  like `'Noach'` or `'Matot-Masei'`. If an array, must be a 1- or 2-element
   *  array such as `['Noach']` or `['Matot', 'Masei']`. If a `number`, should
   *  be a 0-based parsha index (`0` for Bereshit, `1` for Noach) or a negative
   *  number for a doubled parsha (e.g. `-21` for Vayakhel-Pekudei)
   */
  find(parsha) {
    if (typeof parsha === "number") {
      if (parsha >= parshiot.length || parsha < 0 && !isValidDouble(parsha)) {
        throw new RangeError(`Invalid parsha number: ${parsha}`);
      }
      return this.findInternal(parsha);
    } else if (typeof parsha === "string") {
      const num = parsha2id.get(parsha);
      if (typeof num === "number") {
        return this.find(num);
      } else if (parsha.indexOf("-") !== -1) {
        if (parsha === CHMPESACH || parsha === CHMSUKOT) {
          return this.findInternal(parsha);
        }
        return this.find(parsha.split("-"));
      } else {
        return this.findInternal(parsha);
      }
    } else if (Array.isArray(parsha)) {
      const plen = parsha.length;
      if (plen !== 1 && plen !== 2 || typeof parsha[0] !== "string") {
        throw new TypeError(`Invalid parsha argument: ${JSON.stringify(parsha)}`);
      }
      if (plen === 1) {
        return this.find(parsha[0]);
      }
      const p1 = parsha[0];
      const p2 = parsha[1];
      const num1 = parsha2id.get(p1);
      const num2 = parsha2id.get(p2);
      if (typeof num1 !== "number" || typeof num2 !== "number" || num2 !== num1 + 1 || !isValidDouble(-num1)) {
        throw new RangeError(`Unrecognized parsha name: ${p1}-${p2}`);
      }
      return this.find(-num1);
    }
    return null;
  }
  findInternal(parsha) {
    const idx = this.theSedraArray.indexOf(parsha);
    if (idx === -1) {
      return null;
    }
    return new HDate(this.firstSaturday + idx * 7);
  }
  /**
   * Returns the date that a parsha (or its doubled or undoubled counterpart)
   * occurs, or `null` if the parsha doesn't occur this year
   */
  findContaining(parsha) {
    const hdate = this.find(parsha);
    if (hdate) {
      return hdate;
    }
    if (typeof parsha === "number") {
      const p1 = -parsha;
      if (isValidDouble(p1)) {
        return this.find(p1);
      } else {
        return this.find(p1 + 1);
      }
    } else {
      const num = parsha2id.get(parsha);
      if (num) {
        const p1 = -num;
        if (isValidDouble(p1)) {
          return this.find(p1);
        } else {
          return this.find(p1 + 1);
        }
      } else {
        const [p1] = parsha.split("-");
        return this.find(p1);
      }
    }
  }
  /**
   * Returns the underlying annual sedra schedule.
   * Used by `@hebcal/triennial`
   */
  getSedraArray() {
    return this.theSedraArray;
  }
  /**
   * R.D. date of the first Saturday on or after Rosh Hashana
   */
  getFirstSaturday() {
    return this.firstSaturday;
  }
  getYear() {
    return this.year;
  }
  /**
   * Returns an object describing the parsha on the first Saturday on or after `hd`
   * @param hd Hebrew date or R.D. days
   */
  lookup(hd) {
    const abs = typeof hd === "number" ? hd : HDate.isHDate(hd) ? hd.abs() : NaN;
    if (isNaN(abs)) {
      throw new TypeError(`Bad date argument: ${hd}`);
    }
    const saturday = HDate.dayOnOrBefore(6, abs + 6);
    const weekNum = (saturday - this.firstSaturday) / 7;
    const index = this.theSedraArray[weekNum];
    if (typeof index === "undefined") {
      const sedra = getSedra(this.year + 1, this.il);
      return sedra.lookup(saturday);
    }
    const hdate = new HDate(saturday);
    if (typeof index === "string") {
      return { parsha: [index], chag: true, hdate };
    }
    if (index >= 0) {
      return { parsha: [parshiot[index]], chag: false, num: index + 1, hdate };
    }
    const p1 = D2(index);
    return {
      parsha: [parshiot[p1], parshiot[p1 + 1]],
      chag: false,
      num: [p1 + 1, p1 + 2],
      hdate
    };
  }
};
var parshiot = [
  "Bereshit",
  "Noach",
  "Lech-Lecha",
  "Vayera",
  "Chayei Sara",
  "Toldot",
  "Vayetzei",
  "Vayishlach",
  "Vayeshev",
  "Miketz",
  "Vayigash",
  "Vayechi",
  "Shemot",
  "Vaera",
  "Bo",
  "Beshalach",
  "Yitro",
  "Mishpatim",
  "Terumah",
  "Tetzaveh",
  "Ki Tisa",
  "Vayakhel",
  "Pekudei",
  "Vayikra",
  "Tzav",
  "Shmini",
  "Tazria",
  "Metzora",
  "Achrei Mot",
  "Kedoshim",
  "Emor",
  "Behar",
  "Bechukotai",
  "Bamidbar",
  "Nasso",
  "Beha'alotcha",
  "Sh'lach",
  "Korach",
  "Chukat",
  "Balak",
  "Pinchas",
  "Matot",
  "Masei",
  "Devarim",
  "Vaetchanan",
  "Eikev",
  "Re'eh",
  "Shoftim",
  "Ki Teitzei",
  "Ki Tavo",
  "Nitzavim",
  "Vayeilech",
  "Ha'azinu"
];
var parsha2id = /* @__PURE__ */ new Map();
for (let id = 0; id < parshiot.length; id++) {
  const name = parshiot[id];
  parsha2id.set(name, id);
}
var doubles = [
  21,
  // Vayakhel-Pekudei
  26,
  // Tazria-Metzora
  28,
  // Achrei Mot-Kedoshim
  31,
  // Behar-Bechukotai
  38,
  // Chukat-Balak
  41,
  // Matot-Masei
  50
  // Nitzavim-Vayeilech
];
function isValidDouble(id) {
  return doubles.includes(-id);
}
function D2(p2) {
  return -p2;
}
var RH = "Rosh Hashana";
var YK = "Yom Kippur";
var SUKKOT = "Sukkot";
var CHMSUKOT = "Sukkot Shabbat Chol ha-Moed";
var SHMINI = "Shmini Atzeret";
var PESACH = "Pesach";
var PESACH1 = "Pesach I";
var CHMPESACH = "Pesach Shabbat Chol ha-Moed";
var PESACH7 = "Pesach VII";
var PESACH8 = "Pesach VIII";
var SHAVUOT = "Shavuot";
function range(start, stop) {
  return Array.from({ length: stop - start + 1 }, (v2, k2) => k2 + start);
}
var yearStartVayeilech = [51, 52, CHMSUKOT];
var yearStartHaazinu = [52, YK, CHMSUKOT];
var yearStartRH = [RH, 52, SUKKOT, SHMINI];
var r020 = range(0, 20);
var r027 = range(0, 27);
var r3340 = range(33, 40);
var r4349 = range(43, 49);
var r4350 = range(43, 50);
var types = {
  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and
   * Kislev each have 29 days), and has Passover start on Tuesday. */
  // e.g. 5753
  "020": yearStartVayeilech.concat(r020, D2(21), 23, 24, CHMPESACH, 25, D2(26), D2(28), 30, D2(31), r3340, D2(41), r4349, D2(50)),
  /* Hebrew year that starts on Monday, is `complete' (Heshvan and
   * Kislev each have 30 days), and has Passover start on Thursday. */
  // e.g. 5756
  "0220": yearStartVayeilech.concat(r020, D2(21), 23, 24, CHMPESACH, 25, D2(26), D2(28), 30, D2(31), 33, SHAVUOT, range(34, 37), D2(38), 40, D2(41), r4349, D2(50)),
  /* Hebrew year that starts on Thursday, is `regular' (Heshvan has 29
   * days and Kislev has 30 days), and has Passover start on Saturday. */
  // e.g. 5701
  "0510": yearStartHaazinu.concat(r020, D2(21), 23, 24, PESACH1, PESACH8, 25, D2(26), D2(28), 30, D2(31), r3340, D2(41), r4350),
  /* Hebrew year that starts on Thursday, is `regular' (Heshvan has 29
   * days and Kislev has 30 days), and has Passover start on Saturday. */
  // e.g. 5745
  "0511": yearStartHaazinu.concat(r020, D2(21), 23, 24, PESACH, 25, D2(26), D2(28), range(30, 40), D2(41), r4350),
  /* Hebrew year that starts on Thursday, is `complete' (Heshvan and
   * Kislev each have 30 days), and has Passover start on Sunday. */
  // e.g. 5754
  "052": yearStartHaazinu.concat(range(0, 24), PESACH7, 25, D2(26), D2(28), 30, D2(31), r3340, D2(41), r4350),
  /* Hebrew year that starts on Saturday, is `incomplete' (Heshvan and Kislev
   * each have 29 days), and has Passover start on Sunday. */
  // e.g. 5761
  "070": yearStartRH.concat(r020, D2(21), 23, 24, PESACH7, 25, D2(26), D2(28), 30, D2(31), r3340, D2(41), r4350),
  /* Hebrew year that starts on Saturday, is `complete' (Heshvan and
   * Kislev each have 30 days), and has Passover start on Tuesday. */
  // e.g. 5716
  "072": yearStartRH.concat(r020, D2(21), 23, 24, CHMPESACH, 25, D2(26), D2(28), 30, D2(31), r3340, D2(41), r4349, D2(50)),
  /* --  The leap year types (keviot) -- */
  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and
   * Kislev each have 29 days), and has Passover start on Thursday. */
  // e.g. 5746
  "1200": yearStartVayeilech.concat(r027, CHMPESACH, range(28, 33), SHAVUOT, range(34, 37), D2(38), 40, D2(41), r4349, D2(50)),
  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and
   * Kislev each have 29 days), and has Passover start on Thursday. */
  // e.g. 5746
  "1201": yearStartVayeilech.concat(r027, CHMPESACH, range(28, 40), D2(41), r4349, D2(50)),
  /* Hebrew year that starts on Monday, is `complete' (Heshvan and
   * Kislev each have 30 days), and has Passover start on Saturday. */
  // e.g.5752
  "1220": yearStartVayeilech.concat(r027, PESACH1, PESACH8, range(28, 40), D2(41), r4350),
  /* Hebrew year that starts on Monday, is `complete' (Heshvan and
   * Kislev each have 30 days), and has Passover start on Saturday. */
  // e.g.5752
  "1221": yearStartVayeilech.concat(r027, PESACH, range(28, 50)),
  /* Hebrew year that starts on Thursday, is `incomplete' (Heshvan and
   * Kislev both have 29 days), and has Passover start on Sunday. */
  // e.g. 5768
  "150": yearStartHaazinu.concat(range(0, 28), PESACH7, range(29, 50)),
  /* Hebrew year that starts on Thursday, is `complete' (Heshvan and
   * Kislev both have 30 days), and has Passover start on Tuesday. */
  // eg. 5771
  "152": yearStartHaazinu.concat(range(0, 28), CHMPESACH, range(29, 49), D2(50)),
  /* Hebrew year that starts on Saturday, is `incomplete' (Heshvan and
   * Kislev each have 29 days), and has Passover start on Tuesday. */
  // e.g.5757
  "170": yearStartRH.concat(r027, CHMPESACH, range(28, 40), D2(41), r4349, D2(50)),
  /* Hebrew year that starts on Saturday, is `complete' (Heshvan and
   * Kislev each have 30 days), and has Passover start on Thursday. */
  "1720": yearStartRH.concat(r027, CHMPESACH, range(28, 33), SHAVUOT, range(34, 37), D2(38), 40, D2(41), r4349, D2(50))
};
types["0221"] = types["020"];
types["0310"] = types["0220"];
types["0311"] = types["020"];
types["1310"] = types["1220"];
types["1311"] = types["1221"];
types["1721"] = types["170"];
var sedraCache = new QuickLRU({ maxSize: 400 });
function getSedra(hyear, il) {
  const cacheKey = `${hyear}-${il ? 1 : 0}`;
  let sedra = sedraCache.get(cacheKey);
  if (!sedra) {
    sedra = new Sedra(hyear, il);
    sedraCache.set(cacheKey, sedra);
  }
  return sedra;
}

// node_modules/@hebcal/core/dist/esm/staticHolidays.js
var Nisan = months.NISAN;
var Iyyar = months.IYYAR;
var Sivan = months.SIVAN;
var Tamuz = months.TAMUZ;
var Av = months.AV;
var Elul = months.ELUL;
var Tishrei = months.TISHREI;
var Cheshvan = months.CHESHVAN;
var Kislev = months.KISLEV;
var Shvat = months.SHVAT;
var Adar2 = months.ADAR_II;
var CHAG = flags.CHAG;
var LIGHT_CANDLES = flags.LIGHT_CANDLES;
var YOM_TOV_ENDS = flags.YOM_TOV_ENDS;
var CHUL_ONLY = flags.CHUL_ONLY;
var IL_ONLY = flags.IL_ONLY;
var LIGHT_CANDLES_TZEIS = flags.LIGHT_CANDLES_TZEIS;
var CHANUKAH_CANDLES = flags.CHANUKAH_CANDLES;
var MAJOR_FAST = flags.MAJOR_FAST;
var MINOR_HOLIDAY = flags.MINOR_HOLIDAY;
var EREV = flags.EREV;
var CHOL_HAMOED = flags.CHOL_HAMOED;
var emojiPesach = "🫓";
var emojiSukkot = "🌿🍋";
var ROSH_HASHANA_II = "Rosh Hashana II";
var EREV_YOM_KIPPUR = "Erev Yom Kippur";
var YOM_KIPPUR = "Yom Kippur";
var EREV_SUKKOT = "Erev Sukkot";
var SUKKOT_I = "Sukkot I";
var SUKKOT_II = "Sukkot II";
var SUKKOT_III_CHM = "Sukkot III (CH''M)";
var SUKKOT_IV_CHM = "Sukkot IV (CH''M)";
var SUKKOT_V_CHM = "Sukkot V (CH''M)";
var SUKKOT_VI_CHM = "Sukkot VI (CH''M)";
var SHMINI_ATZERET = "Shmini Atzeret";
var SIMCHAT_TORAH = "Simchat Torah";
var SUKKOT_II_CHM = "Sukkot II (CH''M)";
var SUKKOT_VII_HOSHANA_RABA = "Sukkot VII (Hoshana Raba)";
var CHANUKAH_1_CANDLE = "Chanukah: 1 Candle";
var TU_BISHVAT = "Tu BiShvat";
var EREV_PURIM = "Erev Purim";
var PURIM = "Purim";
var SHUSHAN_PURIM = "Shushan Purim";
var EREV_PESACH = "Erev Pesach";
var PESACH_I = "Pesach I";
var PESACH_II = "Pesach II";
var PESACH_II_CHM = "Pesach II (CH''M)";
var PESACH_III_CHM = "Pesach III (CH''M)";
var PESACH_IV_CHM = "Pesach IV (CH''M)";
var PESACH_V_CHM = "Pesach V (CH''M)";
var PESACH_VI_CHM = "Pesach VI (CH''M)";
var PESACH_VII = "Pesach VII";
var PESACH_VIII = "Pesach VIII";
var PESACH_SHENI = "Pesach Sheni";
var LAG_BAOMER = "Lag BaOmer";
var EREV_SHAVUOT = "Erev Shavuot";
var SHAVUOT2 = "Shavuot";
var SHAVUOT_I = "Shavuot I";
var SHAVUOT_II = "Shavuot II";
var TU_BAV = "Tu B'Av";
var ROSH_HASHANA_LABEHEMOT = "Rosh Hashana LaBehemot";
var EREV_ROSH_HASHANA = "Erev Rosh Hashana";
var YOM_YERUSHALAYIM = "Yom Yerushalayim";
var BEN_GURION_DAY = "Ben-Gurion Day";
var FAMILY_DAY = "Family Day";
var YITZHAK_RABIN_MEMORIAL_DAY = "Yitzhak Rabin Memorial Day";
var HERZL_DAY = "Herzl Day";
var JABOTINSKY_DAY = "Jabotinsky Day";
var SIGD = "Sigd";
var YOM_HAALIYAH = "Yom HaAliyah";
var YOM_HAALIYAH_SCHOOL_OBSERVANCE = "Yom HaAliyah School Observance";
var HEBREW_LANGUAGE_DAY = "Hebrew Language Day";
var holidayDesc = {
  /** Asara B'Tevet */
  ASARA_BTEVET: "Asara B'Tevet",
  /** Birkat Hachamah */
  BIRKAT_HACHAMAH: "Birkat Hachamah",
  /** Chag HaBanot */
  CHAG_HABANOT: "Chag HaBanot",
  /** Chanukah: 8th Day */
  CHANUKAH_8TH_DAY: "Chanukah: 8th Day",
  /** Erev Tish'a B'Av */
  EREV_TISHA_BAV: "Erev Tish'a B'Av",
  /** Leil Selichot */
  LEIL_SELICHOT: "Leil Selichot",
  /** Purim Katan */
  PURIM_KATAN: "Purim Katan",
  /** Purim Meshulash */
  PURIM_MESHULASH: "Purim Meshulash",
  /** Shabbat Chazon */
  SHABBAT_CHAZON: "Shabbat Chazon",
  /** Shabbat HaChodesh */
  SHABBAT_HACHODESH: "Shabbat HaChodesh",
  /** Shabbat HaGadol */
  SHABBAT_HAGADOL: "Shabbat HaGadol",
  /** Shabbat Nachamu */
  SHABBAT_NACHAMU: "Shabbat Nachamu",
  /** Shabbat Parah */
  SHABBAT_PARAH: "Shabbat Parah",
  /** Shabbat Shekalim */
  SHABBAT_SHEKALIM: "Shabbat Shekalim",
  /** Shabbat Shirah */
  SHABBAT_SHIRAH: "Shabbat Shirah",
  /** Shabbat Shuva */
  SHABBAT_SHUVA: "Shabbat Shuva",
  /** Shabbat Zachor */
  SHABBAT_ZACHOR: "Shabbat Zachor",
  /** Shushan Purim Katan */
  SHUSHAN_PURIM_KATAN: "Shushan Purim Katan",
  /** Ta'anit Bechorot */
  TAANIT_BECHOROT: "Ta'anit Bechorot",
  /** Ta'anit Esther */
  TAANIT_ESTHER: "Ta'anit Esther",
  /** Tish'a B'Av */
  TISHA_BAV: "Tish'a B'Av",
  /** Tzom Gedaliah */
  TZOM_GEDALIAH: "Tzom Gedaliah",
  /** Tzom Tammuz */
  TZOM_TAMMUZ: "Tzom Tammuz",
  /** Yom HaAtzma'ut */
  YOM_HAATZMA_UT: "Yom HaAtzma'ut",
  /** Yom HaShoah */
  YOM_HASHOAH: "Yom HaShoah",
  /** Yom HaZikaron */
  YOM_HAZIKARON: "Yom HaZikaron",
  /** Ben-Gurion Day */
  BEN_GURION_DAY,
  /** Chanukah: 1 Candle */
  CHANUKAH_1_CANDLE,
  /** Erev Pesach */
  EREV_PESACH,
  /** Erev Purim */
  EREV_PURIM,
  /** Erev Rosh Hashana */
  EREV_ROSH_HASHANA,
  /** Erev Shavuot */
  EREV_SHAVUOT,
  /** Erev Sukkot */
  EREV_SUKKOT,
  /** Erev Yom Kippur */
  EREV_YOM_KIPPUR,
  /** Family Day */
  FAMILY_DAY,
  /** Hebrew Language Day */
  HEBREW_LANGUAGE_DAY,
  /** Herzl Day */
  HERZL_DAY,
  /** Jabotinsky Day */
  JABOTINSKY_DAY,
  /** Lag BaOmer */
  LAG_BAOMER,
  /** Pesach I */
  PESACH_I,
  /** Pesach II */
  PESACH_II,
  /** Pesach III (CH''M) */
  PESACH_III_CHM,
  /** Pesach II (CH''M) */
  PESACH_II_CHM,
  /** Pesach IV (CH''M) */
  PESACH_IV_CHM,
  /** Pesach Sheni */
  PESACH_SHENI,
  /** Pesach VII */
  PESACH_VII,
  /** Pesach VIII */
  PESACH_VIII,
  /** Pesach VI (CH''M) */
  PESACH_VI_CHM,
  /** Pesach V (CH''M) */
  PESACH_V_CHM,
  /** Purim */
  PURIM,
  /** Rosh Hashana II */
  ROSH_HASHANA_II,
  /** Rosh Hashana LaBehemot */
  ROSH_HASHANA_LABEHEMOT,
  /** Shavuot */
  SHAVUOT: SHAVUOT2,
  /** Shavuot I */
  SHAVUOT_I,
  /** Shavuot II */
  SHAVUOT_II,
  /** Shmini Atzeret */
  SHMINI_ATZERET,
  /** Shushan Purim */
  SHUSHAN_PURIM,
  /** Sigd */
  SIGD,
  /** Simchat Torah */
  SIMCHAT_TORAH,
  /** Sukkot I */
  SUKKOT_I,
  /** Sukkot II */
  SUKKOT_II,
  /** Sukkot III (CH''M) */
  SUKKOT_III_CHM,
  /** Sukkot II (CH''M) */
  SUKKOT_II_CHM,
  /** Sukkot IV (CH''M) */
  SUKKOT_IV_CHM,
  /** Sukkot VII (Hoshana Raba) */
  SUKKOT_VII_HOSHANA_RABA,
  /** Sukkot VI (CH''M) */
  SUKKOT_VI_CHM,
  /** Sukkot V (CH''M) */
  SUKKOT_V_CHM,
  /** Tu B\'Av */
  TU_BAV,
  /** Tu BiShvat */
  TU_BISHVAT,
  /** Yitzhak Rabin Memorial Day */
  YITZHAK_RABIN_MEMORIAL_DAY,
  /** Yom HaAliyah */
  YOM_HAALIYAH,
  /** Yom HaAliyah School Observance */
  YOM_HAALIYAH_SCHOOL_OBSERVANCE,
  /** Yom Kippur */
  YOM_KIPPUR,
  /** Yom Yerushalayim */
  YOM_YERUSHALAYIM
};
var staticHolidays = [
  {
    mm: Tishrei,
    dd: 2,
    desc: ROSH_HASHANA_II,
    flags: CHAG | YOM_TOV_ENDS,
    emoji: "🍏🍯"
  },
  { mm: Tishrei, dd: 9, desc: EREV_YOM_KIPPUR, flags: EREV | LIGHT_CANDLES },
  {
    mm: Tishrei,
    dd: 10,
    desc: YOM_KIPPUR,
    flags: CHAG | MAJOR_FAST | YOM_TOV_ENDS
  },
  {
    mm: Tishrei,
    dd: 14,
    desc: EREV_SUKKOT,
    flags: CHUL_ONLY | EREV | LIGHT_CANDLES,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 15,
    desc: SUKKOT_I,
    flags: CHUL_ONLY | CHAG | LIGHT_CANDLES_TZEIS,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 16,
    desc: SUKKOT_II,
    flags: CHUL_ONLY | CHAG | YOM_TOV_ENDS,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 17,
    desc: SUKKOT_III_CHM,
    flags: CHUL_ONLY | CHOL_HAMOED,
    chmDay: 1,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 18,
    desc: SUKKOT_IV_CHM,
    flags: CHUL_ONLY | CHOL_HAMOED,
    chmDay: 2,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 19,
    desc: SUKKOT_V_CHM,
    flags: CHUL_ONLY | CHOL_HAMOED,
    chmDay: 3,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 20,
    desc: SUKKOT_VI_CHM,
    flags: CHUL_ONLY | CHOL_HAMOED,
    chmDay: 4,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 22,
    desc: SHMINI_ATZERET,
    flags: CHUL_ONLY | CHAG | LIGHT_CANDLES_TZEIS
  },
  {
    mm: Tishrei,
    dd: 23,
    desc: SIMCHAT_TORAH,
    flags: CHUL_ONLY | CHAG | YOM_TOV_ENDS
  },
  {
    mm: Tishrei,
    dd: 14,
    desc: EREV_SUKKOT,
    flags: IL_ONLY | EREV | LIGHT_CANDLES,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 15,
    desc: SUKKOT_I,
    flags: IL_ONLY | CHAG | YOM_TOV_ENDS,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 16,
    desc: SUKKOT_II_CHM,
    flags: IL_ONLY | CHOL_HAMOED,
    chmDay: 1,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 17,
    desc: SUKKOT_III_CHM,
    flags: IL_ONLY | CHOL_HAMOED,
    chmDay: 2,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 18,
    desc: SUKKOT_IV_CHM,
    flags: IL_ONLY | CHOL_HAMOED,
    chmDay: 3,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 19,
    desc: SUKKOT_V_CHM,
    flags: IL_ONLY | CHOL_HAMOED,
    chmDay: 4,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 20,
    desc: SUKKOT_VI_CHM,
    flags: IL_ONLY | CHOL_HAMOED,
    chmDay: 5,
    emoji: emojiSukkot
  },
  {
    mm: Tishrei,
    dd: 22,
    desc: SHMINI_ATZERET,
    flags: IL_ONLY | CHAG | YOM_TOV_ENDS
  },
  {
    mm: Tishrei,
    dd: 21,
    desc: SUKKOT_VII_HOSHANA_RABA,
    flags: LIGHT_CANDLES | CHOL_HAMOED,
    chmDay: -1,
    emoji: emojiSukkot
  },
  {
    mm: Kislev,
    dd: 24,
    desc: CHANUKAH_1_CANDLE,
    flags: EREV | MINOR_HOLIDAY | CHANUKAH_CANDLES,
    emoji: "🕎1️⃣"
  },
  { mm: Shvat, dd: 15, desc: TU_BISHVAT, flags: MINOR_HOLIDAY, emoji: "🌳" },
  {
    mm: Adar2,
    dd: 13,
    desc: EREV_PURIM,
    flags: EREV | MINOR_HOLIDAY,
    emoji: "🎭️📜"
  },
  { mm: Adar2, dd: 14, desc: PURIM, flags: MINOR_HOLIDAY, emoji: "🎭️📜" },
  {
    mm: Adar2,
    dd: 15,
    desc: SHUSHAN_PURIM,
    flags: MINOR_HOLIDAY,
    emoji: "🎭️📜"
  },
  // Pesach Israel
  {
    mm: Nisan,
    dd: 14,
    desc: EREV_PESACH,
    flags: IL_ONLY | EREV | LIGHT_CANDLES,
    emoji: "🫓🍷"
  },
  {
    mm: Nisan,
    dd: 15,
    desc: PESACH_I,
    flags: IL_ONLY | CHAG | YOM_TOV_ENDS,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 16,
    desc: PESACH_II_CHM,
    flags: IL_ONLY | CHOL_HAMOED,
    chmDay: 1,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 17,
    desc: PESACH_III_CHM,
    flags: IL_ONLY | CHOL_HAMOED,
    chmDay: 2,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 18,
    desc: PESACH_IV_CHM,
    flags: IL_ONLY | CHOL_HAMOED,
    chmDay: 3,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 19,
    desc: PESACH_V_CHM,
    flags: IL_ONLY | CHOL_HAMOED,
    chmDay: 4,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 20,
    desc: PESACH_VI_CHM,
    flags: IL_ONLY | CHOL_HAMOED | LIGHT_CANDLES,
    chmDay: 5,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 21,
    desc: PESACH_VII,
    flags: IL_ONLY | CHAG | YOM_TOV_ENDS,
    emoji: emojiPesach
  },
  // Pesach chutz l'aretz
  {
    mm: Nisan,
    dd: 14,
    desc: EREV_PESACH,
    flags: CHUL_ONLY | EREV | LIGHT_CANDLES,
    emoji: "🫓🍷"
  },
  {
    mm: Nisan,
    dd: 15,
    desc: PESACH_I,
    flags: CHUL_ONLY | CHAG | LIGHT_CANDLES_TZEIS,
    emoji: "🫓🍷"
  },
  {
    mm: Nisan,
    dd: 16,
    desc: PESACH_II,
    flags: CHUL_ONLY | CHAG | YOM_TOV_ENDS,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 17,
    desc: PESACH_III_CHM,
    flags: CHUL_ONLY | CHOL_HAMOED,
    chmDay: 1,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 18,
    desc: PESACH_IV_CHM,
    flags: CHUL_ONLY | CHOL_HAMOED,
    chmDay: 2,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 19,
    desc: PESACH_V_CHM,
    flags: CHUL_ONLY | CHOL_HAMOED,
    chmDay: 3,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 20,
    desc: PESACH_VI_CHM,
    flags: CHUL_ONLY | CHOL_HAMOED | LIGHT_CANDLES,
    chmDay: 4,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 21,
    desc: PESACH_VII,
    flags: CHUL_ONLY | CHAG | LIGHT_CANDLES_TZEIS,
    emoji: emojiPesach
  },
  {
    mm: Nisan,
    dd: 22,
    desc: PESACH_VIII,
    flags: CHUL_ONLY | CHAG | YOM_TOV_ENDS,
    emoji: emojiPesach
  },
  { mm: Iyyar, dd: 14, desc: PESACH_SHENI, flags: MINOR_HOLIDAY },
  { mm: Iyyar, dd: 18, desc: LAG_BAOMER, flags: MINOR_HOLIDAY, emoji: "🔥" },
  {
    mm: Sivan,
    dd: 5,
    desc: EREV_SHAVUOT,
    flags: EREV | LIGHT_CANDLES,
    emoji: "⛰️🌸"
  },
  {
    mm: Sivan,
    dd: 6,
    desc: SHAVUOT2,
    flags: IL_ONLY | CHAG | YOM_TOV_ENDS,
    emoji: "⛰️🌸"
  },
  {
    mm: Sivan,
    dd: 6,
    desc: SHAVUOT_I,
    flags: CHUL_ONLY | CHAG | LIGHT_CANDLES_TZEIS,
    emoji: "⛰️🌸"
  },
  {
    mm: Sivan,
    dd: 7,
    desc: SHAVUOT_II,
    flags: CHUL_ONLY | CHAG | YOM_TOV_ENDS,
    emoji: "⛰️🌸"
  },
  { mm: Av, dd: 15, desc: TU_BAV, flags: MINOR_HOLIDAY, emoji: "❤️" },
  {
    mm: Elul,
    dd: 1,
    desc: ROSH_HASHANA_LABEHEMOT,
    flags: MINOR_HOLIDAY,
    emoji: "🐑"
  },
  {
    mm: Elul,
    dd: 29,
    desc: EREV_ROSH_HASHANA,
    flags: EREV | LIGHT_CANDLES,
    emoji: "🍏🍯"
  }
];
var staticModernHolidays = [
  { firstYear: 5727, mm: Iyyar, dd: 28, desc: YOM_YERUSHALAYIM, chul: true },
  {
    firstYear: 5737,
    mm: Kislev,
    dd: 6,
    desc: BEN_GURION_DAY,
    satPostponeToSun: true,
    friPostponeToSun: true
  },
  { firstYear: 5750, mm: Shvat, dd: 30, desc: FAMILY_DAY },
  {
    firstYear: 5758,
    mm: Cheshvan,
    dd: 12,
    desc: YITZHAK_RABIN_MEMORIAL_DAY,
    friSatMovetoThu: true
  },
  { firstYear: 5764, mm: Iyyar, dd: 10, desc: HERZL_DAY, satPostponeToSun: true },
  {
    firstYear: 5765,
    mm: Tamuz,
    dd: 29,
    desc: JABOTINSKY_DAY,
    satPostponeToSun: true
  },
  {
    firstYear: 5769,
    mm: Cheshvan,
    dd: 29,
    desc: SIGD,
    chul: true,
    suppressEmoji: true,
    friSatMovetoThu: true
  },
  { firstYear: 5777, mm: Nisan, dd: 10, desc: YOM_HAALIYAH, chul: true },
  { firstYear: 5777, mm: Cheshvan, dd: 7, desc: YOM_HAALIYAH_SCHOOL_OBSERVANCE },
  // https://www.gov.il/he/departments/policies/2012_des5234
  {
    firstYear: 5773,
    mm: months.TEVET,
    dd: 21,
    desc: HEBREW_LANGUAGE_DAY,
    friSatMovetoThu: true
  }
];

// node_modules/@hebcal/core/dist/esm/HolidayEvent.js
var HolidayEvent = class _HolidayEvent extends Event {
  basename() {
    return this.getDesc().replace(/ \d{4}$/, "").replace(/ \(CH''M\)$/, "").replace(/ \(observed\)$/, "").replace(/ \(Hoshana Raba\)$/, "").replace(/ [IV]+$/, "").replace(/: \d Candles?$/, "").replace(/: 8th Day$/, "").replace(/^Erev /, "");
  }
  url() {
    const year = this.getDate().greg().getFullYear();
    if (year < 100) {
      return void 0;
    }
    const url = "https://www.hebcal.com/holidays/" + this.basename().toLowerCase().replace(/'/g, "").replace(/ /g, "-") + "-" + this.urlDateSuffix();
    return this.getFlags() & flags.IL_ONLY ? url + "?i=on" : url;
  }
  urlDateSuffix() {
    const year = this.getDate().greg().getFullYear();
    return String(year);
  }
  getEmoji() {
    if (this.emoji) {
      return this.emoji;
    } else if (this.getFlags() & flags.SPECIAL_SHABBAT) {
      return "🕍";
    } else {
      return "✡️";
    }
  }
  getCategories() {
    if (this.cholHaMoedDay) {
      return ["holiday", "major", "cholhamoed"];
    }
    const cats = super.getCategories();
    if (cats[0] !== "unknown") {
      return cats;
    }
    const desc = this.getDesc();
    switch (desc) {
      case holidayDesc.LAG_BAOMER:
      case holidayDesc.LEIL_SELICHOT:
      case holidayDesc.PESACH_SHENI:
      case holidayDesc.EREV_PURIM:
      case holidayDesc.PURIM_KATAN:
      case holidayDesc.SHUSHAN_PURIM:
      case holidayDesc.TU_BAV:
      case holidayDesc.TU_BISHVAT:
      case holidayDesc.ROSH_HASHANA_LABEHEMOT:
        return ["holiday", "minor"];
    }
    return ["holiday", "major"];
  }
  /**
   * Returns (translated) description of this event
   * @param [locale] Optional locale name (defaults to active locale).
   */
  render(locale) {
    const str = super.render(locale);
    return str.replace(/'/g, "’");
  }
  /**
   * Returns a brief (translated) description of this event.
   * For most events, this is the same as render(). For some events, it procudes
   * a shorter text (e.g. without a time or added description).
   * @param [locale] Optional locale name (defaults to active locale).
   */
  renderBrief(locale) {
    const str = super.renderBrief(locale);
    return str.replace(/'/g, "’");
  }
  /**
   * Makes a clone of this Event object
   * @deprecated
   */
  clone() {
    const ev = new _HolidayEvent(this.date, this.desc, this.mask);
    Object.assign(ev, this);
    return ev;
  }
};
var AsaraBTevetEvent = class extends HolidayEvent {
  urlDateSuffix() {
    const isoDate = isoDateString(this.getDate().greg());
    return isoDate.replace(/-/g, "");
  }
};
var ChanukahEvent = class extends HolidayEvent {
  urlDateSuffix() {
    const dt2 = this.getDate().greg();
    let year = dt2.getFullYear();
    if (dt2.getMonth() === 0) {
      year--;
    }
    return String(year);
  }
};
var RoshHashanaEvent = class extends HolidayEvent {
  /**
   * @private
   * @param date Hebrew date event occurs
   * @param hyear Hebrew year
   * @param mask optional holiday flags
   */
  constructor(date, hyear, mask) {
    super(date, `Rosh Hashana ${hyear}`, mask);
    this.hyear = hyear;
  }
  /**
   * Returns (translated) description of this event
   * @param [locale] Optional locale name (defaults to active locale).
   */
  render(locale) {
    return Locale.gettext("Rosh Hashana", locale) + " " + this.hyear;
  }
  getEmoji() {
    return "🍏🍯";
  }
};
var roshChodeshStr = "Rosh Chodesh";
var RoshChodeshEvent = class extends HolidayEvent {
  /**
   * Constructs Rosh Chodesh event
   * @param date Hebrew date event occurs
   * @param monthName Hebrew month name (not translated)
   */
  constructor(date, monthName) {
    super(date, `${roshChodeshStr} ${monthName}`, flags.ROSH_CHODESH);
  }
  /**
   * Returns (translated) description of this event
   * @param [locale] Optional locale name (defaults to active locale).
   */
  render(locale) {
    const monthName = this.getDesc().substring(roshChodeshStr.length + 1);
    const monthName0 = Locale.gettext(monthName, locale);
    const monthName1 = monthName0.replace(/'/g, "’");
    return Locale.gettext(roshChodeshStr, locale) + " " + monthName1;
  }
  basename() {
    return this.getDesc();
  }
  getEmoji() {
    return this.emoji || "🌒";
  }
};

// node_modules/@hebcal/core/dist/esm/YomKippurKatanEvent.js
var ykk = "Yom Kippur Katan";
var YomKippurKatanEvent = class extends HolidayEvent {
  /**
   * @private
   * @param date Hebrew date event occurs
   * @param nextMonthName name of the upcoming month
   */
  constructor(date, nextMonthName) {
    super(date, `${ykk} ${nextMonthName}`, flags.MINOR_FAST | flags.YOM_KIPPUR_KATAN);
    this.nextMonthName = nextMonthName;
    this.memo = `Minor Day of Atonement on the day preceeding Rosh Chodesh ${nextMonthName}`;
  }
  basename() {
    return this.getDesc();
  }
  /**
   * @param [locale] Optional locale name (defaults to active locale).
   */
  render(locale) {
    const monthName0 = Locale.gettext(this.nextMonthName, locale);
    const monthName = monthName0.replace(/'/g, "’");
    return Locale.gettext(ykk, locale) + " " + monthName;
  }
  /**
   * @param [locale] Optional locale name (defaults to active locale).
   */
  renderBrief(locale) {
    return Locale.gettext(ykk, locale);
  }
  url() {
    return void 0;
  }
};

// node_modules/@hebcal/core/dist/esm/holidays.js
function observedInIsrael(ev) {
  return ev.observedInIsrael();
}
function observedInDiaspora(ev) {
  return ev.observedInDiaspora();
}
function holidayFilter(il) {
  return il ? observedInIsrael : observedInDiaspora;
}
function getHolidaysOnDate(date, il) {
  const hd = HDate.isHDate(date) ? date : new HDate(date);
  const hdStr = hd.toString();
  const yearMap = getHolidaysForYear_(hd.getFullYear());
  const events = yearMap.get(hdStr);
  if (typeof il === "undefined" || typeof events === "undefined") {
    return events;
  }
  const filtered = events.filter(holidayFilter(il));
  return filtered;
}
var CHAG2 = flags.CHAG;
var IL_ONLY2 = flags.IL_ONLY;
var LIGHT_CANDLES_TZEIS2 = flags.LIGHT_CANDLES_TZEIS;
var CHANUKAH_CANDLES2 = flags.CHANUKAH_CANDLES;
var MINOR_FAST = flags.MINOR_FAST;
var SPECIAL_SHABBAT = flags.SPECIAL_SHABBAT;
var MODERN_HOLIDAY = flags.MODERN_HOLIDAY;
var MAJOR_FAST2 = flags.MAJOR_FAST;
var MINOR_HOLIDAY2 = flags.MINOR_HOLIDAY;
var EREV2 = flags.EREV;
var SUN2 = 0;
var TUE2 = 2;
var THU = 4;
var FRI2 = 5;
var SAT2 = 6;
var NISAN4 = months.NISAN;
var TAMUZ2 = months.TAMUZ;
var AV2 = months.AV;
var TISHREI2 = months.TISHREI;
var KISLEV3 = months.KISLEV;
var TEVET3 = months.TEVET;
var ADAR_I3 = months.ADAR_I;
var ADAR_II3 = months.ADAR_II;
var emojiIsraelFlag = { emoji: "🇮🇱" };
var chanukahEmoji = "🕎";
var yearCache = new QuickLRU({ maxSize: 400 });
var KEYCAP_DIGITS = [
  "0️⃣",
  "1️⃣",
  "2️⃣",
  "3️⃣",
  "4️⃣",
  "5️⃣",
  "6️⃣",
  "7️⃣",
  "8️⃣",
  "9️⃣"
];
function getHolidaysForYear_(year) {
  if (typeof year !== "number") {
    throw new TypeError(`bad Hebrew year: ${year}`);
  } else if (year < 1 || year > 32658) {
    throw new RangeError(`Hebrew year ${year} out of range 1-32658`);
  }
  const cached = yearCache.get(year);
  if (cached) {
    return cached;
  }
  const RH2 = new HDate(1, TISHREI2, year);
  const pesach = new HDate(15, NISAN4, year);
  const map = /* @__PURE__ */ new Map();
  function add(...events) {
    for (const ev of events) {
      const key = ev.date.toString();
      const arr = map.get(key);
      if (typeof arr === "object") {
        if (arr[0].getFlags() & EREV2) {
          arr.unshift(ev);
        } else {
          arr.push(ev);
        }
      } else {
        map.set(key, [ev]);
      }
    }
  }
  for (const h2 of staticHolidays) {
    const hd = new HDate(h2.dd, h2.mm, year);
    const ev = new HolidayEvent(hd, h2.desc, h2.flags);
    if (h2.emoji)
      ev.emoji = h2.emoji;
    if (h2.chmDay)
      ev.cholHaMoedDay = h2.chmDay;
    add(ev);
  }
  add(new RoshHashanaEvent(RH2, year, CHAG2 | LIGHT_CANDLES_TZEIS2));
  const tzomGedaliahDay = RH2.getDay() === THU ? 4 : 3;
  add(new HolidayEvent(new HDate(tzomGedaliahDay, TISHREI2, year), holidayDesc.TZOM_GEDALIAH, MINOR_FAST));
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT2, 7 + RH2.abs())), holidayDesc.SHABBAT_SHUVA, SPECIAL_SHABBAT));
  const rchTevet = HDate.shortKislev(year) ? new HDate(1, TEVET3, year) : new HDate(30, KISLEV3, year);
  add(new HolidayEvent(rchTevet, holidayDesc.CHAG_HABANOT, MINOR_HOLIDAY2));
  for (let candles = 2; candles <= 8; candles++) {
    const hd = new HDate(23 + candles, KISLEV3, year);
    add(new ChanukahEvent(hd, `Chanukah: ${candles} Candles`, MINOR_HOLIDAY2 | CHANUKAH_CANDLES2, {
      chanukahDay: candles - 1,
      emoji: chanukahEmoji + KEYCAP_DIGITS[candles]
    }));
  }
  add(new ChanukahEvent(new HDate(32, KISLEV3, year), holidayDesc.CHANUKAH_8TH_DAY, MINOR_HOLIDAY2, { chanukahDay: 8, emoji: chanukahEmoji }));
  add(new AsaraBTevetEvent(new HDate(10, TEVET3, year), holidayDesc.ASARA_BTEVET, MINOR_FAST));
  const pesachAbs = pesach.abs();
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT2, pesachAbs - 43)), holidayDesc.SHABBAT_SHEKALIM, SPECIAL_SHABBAT), new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT2, pesachAbs - 30)), holidayDesc.SHABBAT_ZACHOR, SPECIAL_SHABBAT), new HolidayEvent(new HDate(pesachAbs - (pesach.getDay() === TUE2 ? 33 : 31)), holidayDesc.TAANIT_ESTHER, MINOR_FAST));
  const haChodeshAbs = HDate.dayOnOrBefore(SAT2, pesachAbs - 14);
  add(new HolidayEvent(new HDate(haChodeshAbs - 7), holidayDesc.SHABBAT_PARAH, SPECIAL_SHABBAT), new HolidayEvent(new HDate(haChodeshAbs), holidayDesc.SHABBAT_HACHODESH, SPECIAL_SHABBAT), new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT2, pesachAbs - 1)), holidayDesc.SHABBAT_HAGADOL, SPECIAL_SHABBAT), new HolidayEvent(
    // if the fast falls on Shabbat, move to Thursday
    pesach.prev().getDay() === SAT2 ? pesach.onOrBefore(THU) : new HDate(14, NISAN4, year),
    holidayDesc.TAANIT_BECHOROT,
    MINOR_FAST
  ));
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT2, new HDate(1, TISHREI2, year + 1).abs() - 4)), holidayDesc.LEIL_SELICHOT, MINOR_HOLIDAY2, { emoji: "🕍" }));
  if (pesach.getDay() === SUN2) {
    add(new HolidayEvent(new HDate(16, ADAR_II3, year), holidayDesc.PURIM_MESHULASH, MINOR_HOLIDAY2));
  }
  if (HDate.isLeapYear(year)) {
    add(new HolidayEvent(new HDate(14, ADAR_I3, year), holidayDesc.PURIM_KATAN, MINOR_HOLIDAY2, { emoji: "🎭️" }));
    add(new HolidayEvent(new HDate(15, ADAR_I3, year), holidayDesc.SHUSHAN_PURIM_KATAN, MINOR_HOLIDAY2, { emoji: "🎭️" }));
  }
  const nisan27dt = dateYomHaShoah(year);
  if (nisan27dt) {
    add(new HolidayEvent(nisan27dt, holidayDesc.YOM_HASHOAH, MODERN_HOLIDAY));
  }
  const yomHaZikaronDt = dateYomHaZikaron(year);
  if (yomHaZikaronDt) {
    add(new HolidayEvent(yomHaZikaronDt, holidayDesc.YOM_HAZIKARON, MODERN_HOLIDAY, emojiIsraelFlag), new HolidayEvent(yomHaZikaronDt.next(), holidayDesc.YOM_HAATZMA_UT, MODERN_HOLIDAY, emojiIsraelFlag));
  }
  for (const h2 of staticModernHolidays) {
    if (year >= h2.firstYear) {
      let hd = new HDate(h2.dd, h2.mm, year);
      const dow = hd.getDay();
      if (h2.friSatMovetoThu && (dow === FRI2 || dow === SAT2)) {
        hd = hd.onOrBefore(THU);
      } else if (h2.friPostponeToSun && dow === FRI2) {
        hd = new HDate(hd.abs() + 2);
      } else if (h2.satPostponeToSun && dow === SAT2) {
        hd = hd.next();
      }
      const mask = h2.chul ? MODERN_HOLIDAY : MODERN_HOLIDAY | IL_ONLY2;
      const ev = new HolidayEvent(hd, h2.desc, mask);
      if (!h2.suppressEmoji) {
        ev.emoji = "🇮🇱";
      }
      add(ev);
    }
  }
  let tamuz17 = new HDate(17, TAMUZ2, year);
  let tamuz17attrs;
  if (tamuz17.getDay() === SAT2) {
    tamuz17 = new HDate(18, TAMUZ2, year);
    tamuz17attrs = { observed: true };
  }
  add(new HolidayEvent(tamuz17, holidayDesc.TZOM_TAMMUZ, MINOR_FAST, tamuz17attrs));
  let av9dt = new HDate(9, AV2, year);
  let av9title = holidayDesc.TISHA_BAV;
  let av9attrs;
  if (av9dt.getDay() === SAT2) {
    av9dt = av9dt.next();
    av9attrs = { observed: true };
    av9title += " (observed)";
  }
  const av9abs = av9dt.abs();
  add(new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT2, av9abs)), holidayDesc.SHABBAT_CHAZON, SPECIAL_SHABBAT), new HolidayEvent(av9dt.prev(), holidayDesc.EREV_TISHA_BAV, EREV2 | MAJOR_FAST2, av9attrs), new HolidayEvent(av9dt, av9title, MAJOR_FAST2, av9attrs), new HolidayEvent(new HDate(HDate.dayOnOrBefore(SAT2, av9abs + 7)), holidayDesc.SHABBAT_NACHAMU, SPECIAL_SHABBAT));
  const monthsInYear2 = HDate.monthsInYear(year);
  for (let month = 1; month <= monthsInYear2; month++) {
    const monthName = HDate.getMonthName(month, year);
    if ((month === NISAN4 ? HDate.daysInMonth(HDate.monthsInYear(year - 1), year - 1) : HDate.daysInMonth(month - 1, year)) === 30) {
      add(new RoshChodeshEvent(new HDate(1, month, year), monthName));
      add(new RoshChodeshEvent(new HDate(30, month - 1, year), monthName));
    } else if (month !== TISHREI2) {
      add(new RoshChodeshEvent(new HDate(1, month, year), monthName));
    }
  }
  for (let month = months.IYYAR; month <= monthsInYear2; month++) {
    const nextMonth = month + 1;
    if (nextMonth === TISHREI2 || nextMonth === months.CHESHVAN || nextMonth === TEVET3) {
      continue;
    }
    let ykk2 = new HDate(29, month, year);
    const dow = ykk2.getDay();
    if (dow === FRI2 || dow === SAT2) {
      ykk2 = ykk2.onOrBefore(THU);
    }
    const nextMonthName = HDate.getMonthName(nextMonth, year);
    const ev = new YomKippurKatanEvent(ykk2, nextMonthName);
    add(ev);
  }
  const sedra = getSedra(year, false);
  const beshalachHd = sedra.find(15);
  add(new HolidayEvent(beshalachHd, holidayDesc.SHABBAT_SHIRAH, SPECIAL_SHABBAT));
  const birkatHaChama = getBirkatHaChama(year);
  if (birkatHaChama) {
    const hd = new HDate(birkatHaChama);
    add(new HolidayEvent(hd, holidayDesc.BIRKAT_HACHAMAH, MINOR_HOLIDAY2, { emoji: "☀️" }));
  }
  yearCache.set(year, map);
  return map;
}
function getBirkatHaChama(year) {
  const leap = HDate.isLeapYear(year);
  const startMonth = leap ? ADAR_II3 : NISAN4;
  const startDay = leap ? 20 : 1;
  const baseRd = HDate.hebrew2abs(year, startMonth, startDay);
  for (let day = 0; day <= 40; day++) {
    const abs = baseRd + day;
    const elapsed = abs + 1373429;
    if (elapsed % 10227 === 172) {
      return abs;
    }
  }
  return 0;
}
function getHolidaysForYearArray(year, il) {
  const yearMap = getHolidaysForYear_(year);
  const startAbs = HDate.hebrew2abs(year, TISHREI2, 1);
  const endAbs = HDate.hebrew2abs(year + 1, TISHREI2, 1) - 1;
  let events = [];
  const myFilter = il ? observedInIsrael : observedInDiaspora;
  for (let absDt = startAbs; absDt <= endAbs; absDt++) {
    const hd = new HDate(absDt);
    const holidays = yearMap.get(hd.toString());
    if (holidays) {
      const filtered = holidays.filter(myFilter);
      events = events.concat(filtered);
    }
  }
  return events;
}

// node_modules/@hebcal/core/dist/esm/isAssurBemlacha.js
var LIGHT_CANDLES2 = flags.LIGHT_CANDLES | flags.LIGHT_CANDLES_TZEIS;
function isTomorrowShabbosOrYomTov(dow, events) {
  if (dow === 5) {
    return true;
  }
  const erev = events.find((ev) => ev.getFlags() & LIGHT_CANDLES2);
  if (erev) {
    return true;
  }
  return false;
}
function isTodayAssurBemelacha(dow, events) {
  if (dow === 6) {
    return true;
  }
  const chag = events.find((ev) => ev.getFlags() & flags.CHAG);
  if (chag) {
    return true;
  }
  return false;
}
function isAssurBemlacha(currentTime, location, useElevation) {
  const zmanim = new Zmanim(location, currentTime, useElevation);
  const sunset = zmanim.sunset();
  const sunsetMillis = sunset.getTime();
  if (isNaN(sunsetMillis)) {
    throw new Error("Could not determine sunset");
  }
  const il = location.getIsrael();
  const currentMillis = currentTime.getTime();
  const hd = new HDate(currentTime);
  const dow = hd.getDay();
  const events = getHolidaysOnDate(hd, il) || [];
  if (isTomorrowShabbosOrYomTov(dow, events) && currentMillis >= sunsetMillis) {
    return true;
  }
  if (isTodayAssurBemelacha(dow, events)) {
    const tzais = zmanim.tzeit();
    const tzaisMillis = tzais.getTime();
    return currentMillis <= tzaisMillis;
  }
  return false;
}

// node_modules/@hebcal/core/dist/esm/reformatTimeStr.js
var hour12cc = {
  US: 1,
  CA: 1,
  BR: 1,
  AU: 1,
  NZ: 1,
  DO: 1,
  PR: 1,
  GR: 1,
  IN: 1,
  KR: 1,
  NP: 1,
  ZA: 1
};
function reformatTimeStr(timeStr, suffix, options) {
  var _a;
  if (typeof timeStr !== "string")
    throw new TypeError(`Bad timeStr: ${timeStr}`);
  const cc = ((_a = options === null || options === void 0 ? void 0 : options.location) === null || _a === void 0 ? void 0 : _a.getCountryCode()) || ((options === null || options === void 0 ? void 0 : options.il) ? "IL" : "US");
  const hour12 = options === null || options === void 0 ? void 0 : options.hour12;
  if (typeof hour12 !== "undefined" && !hour12) {
    return timeStr;
  }
  if (!hour12 && typeof hour12cc[cc] === "undefined") {
    return timeStr;
  }
  const hm = timeStr.split(":");
  let hour = parseInt(hm[0], 10);
  if (hour < 12 && suffix) {
    suffix = suffix.replace("p", "a").replace("P", "A");
    if (hour === 0) {
      hour = 12;
    }
  } else if (hour > 12) {
    hour = hour % 12;
  } else if (hour === 0) {
    hour = "00";
  }
  return `${hour}:${hm[1]}${suffix}`;
}

// node_modules/@hebcal/core/dist/esm/TimedEvent.js
var TimedEvent = class extends Event {
  /**
   * @param desc Description (not translated)
   */
  constructor(date, desc, mask, eventTime, location, linkedEvent, options) {
    super(date, desc, mask);
    this.eventTime = Zmanim.roundTime(eventTime);
    this.location = location;
    const timeFormat = location.getTimeFormatter();
    this.eventTimeStr = Zmanim.formatTime(this.eventTime, timeFormat);
    const opts = Object.assign(Object.assign({}, options), { location });
    this.fmtTime = reformatTimeStr(this.eventTimeStr, "pm", opts);
    if (typeof linkedEvent !== "undefined") {
      this.linkedEvent = linkedEvent;
    }
  }
  /**
   * @param [locale] Optional locale name (defaults to active locale).
   */
  render(locale) {
    return Locale.gettext(this.getDesc(), locale) + ": " + this.fmtTime;
  }
  /**
   * Returns translation of "Candle lighting" without the time.
   * @param [locale] Optional locale name (defaults to active locale).
   */
  renderBrief(locale) {
    return Locale.gettext(this.getDesc(), locale);
  }
  getCategories() {
    const desc = this.getDesc();
    switch (desc) {
      case "Candle lighting":
        return ["candles"];
      case "Havdalah":
        return ["havdalah"];
      case "Fast begins":
      case "Fast ends":
        return ["zmanim", "fast"];
    }
    return ["unknown"];
  }
};
var CandleLightingEvent = class extends TimedEvent {
  constructor(date, mask, eventTime, location, linkedEvent, options) {
    super(date, "Candle lighting", mask, eventTime, location, linkedEvent, options);
  }
  getEmoji() {
    return "🕯️";
  }
};
var HavdalahEvent = class extends TimedEvent {
  constructor(date, mask, eventTime, location, havdalahMins, linkedEvent, options) {
    super(date, "Havdalah", mask, eventTime, location, linkedEvent, options);
    if (havdalahMins) {
      this.havdalahMins = havdalahMins;
    }
  }
  /**
   * @param [locale] Optional locale name (defaults to active locale).
   */
  render(locale) {
    return this.renderBrief(locale) + ": " + this.fmtTime;
  }
  /**
   * Returns translation of "Havdalah" without the time.
   * @param [locale] Optional locale name (defaults to active locale).
   */
  renderBrief(locale) {
    let str = Locale.gettext(this.getDesc(), locale);
    if (this.havdalahMins) {
      const min = Locale.gettext("min", locale);
      str += ` (${this.havdalahMins} ${min})`;
    }
    return str;
  }
  getEmoji() {
    return "✨";
  }
};

// node_modules/@hebcal/core/dist/esm/candles.js
var LIGHT_CANDLES3 = flags.LIGHT_CANDLES;
var LIGHT_CANDLES_TZEIS3 = flags.LIGHT_CANDLES_TZEIS;
function makeCandleEvent(ev, hd, options, isFriday, isSaturday) {
  let havdalahTitle = false;
  let useHavdalahOffset = isSaturday;
  let mask = ev ? ev.getFlags() : LIGHT_CANDLES3;
  if (typeof ev !== "undefined") {
    if (!isFriday) {
      if (mask & (LIGHT_CANDLES_TZEIS3 | flags.CHANUKAH_CANDLES)) {
        useHavdalahOffset = true;
      } else if (mask & flags.YOM_TOV_ENDS) {
        havdalahTitle = true;
        useHavdalahOffset = true;
      }
    }
  } else if (isSaturday) {
    havdalahTitle = true;
    mask = LIGHT_CANDLES_TZEIS3;
  }
  const offset = useHavdalahOffset ? Number(options.havdalahMins) : Number(options.candleLightingMins);
  const location = options.location;
  const useElevation = Boolean(options.useElevation);
  const zmanim = new Zmanim(location, hd, useElevation);
  const time = useHavdalahOffset && !offset ? zmanim.tzeit(options.havdalahDeg) : zmanim.sunsetOffset(offset, true);
  if (isNaN(time.getTime())) {
    return void 0;
  }
  if (havdalahTitle) {
    return new HavdalahEvent(hd, mask, time, location, options.havdalahMins, ev, options);
  } else {
    mask |= LIGHT_CANDLES3;
    return new CandleLightingEvent(hd, mask, time, location, ev, options);
  }
}
var FAST_BEGINS = "Fast begins";
var FAST_ENDS = "Fast ends";
var FastDayEvent = class extends HolidayEvent {
  constructor(linkedEvent, startEvent, endEvent) {
    super(linkedEvent.getDate(), linkedEvent.getDesc(), linkedEvent.getFlags());
    this.linkedEvent = linkedEvent;
    this.startEvent = startEvent;
    this.endEvent = endEvent;
  }
  render(locale) {
    return this.linkedEvent.render(locale);
  }
  renderBrief(locale) {
    return this.linkedEvent.renderBrief(locale);
  }
  urlDateSuffix() {
    return this.linkedEvent.urlDateSuffix();
  }
  url() {
    return this.linkedEvent.url();
  }
  getEmoji() {
    return this.linkedEvent.getEmoji();
  }
  getCategories() {
    return this.linkedEvent.getCategories();
  }
};
function makeFastStartEnd(ev, options) {
  const desc = ev.getDesc();
  if (desc === "Yom Kippur") {
    throw new RangeError("YK does not require this function");
  }
  const hd = ev.getDate();
  const dt2 = hd.greg();
  const location = options.location;
  const fastEndDeg = options.fastEndDeg;
  const useElevation = Boolean(options.useElevation);
  const zmanim = new Zmanim(location, dt2, useElevation);
  let startEvent;
  let endEvent;
  if (desc === "Erev Tish'a B'Av") {
    const sunset = zmanim.sunset();
    if (!isNaN(sunset.getTime())) {
      startEvent = makeTimedEvent(ev, sunset, FAST_BEGINS, options);
    }
  } else if (desc.startsWith("Tish'a B'Av")) {
    const tzeit = zmanim.tzeit(fastEndDeg);
    if (!isNaN(tzeit.getTime())) {
      endEvent = makeTimedEvent(ev, tzeit, FAST_ENDS, options);
    }
  } else {
    const dawn = zmanim.alotHaShachar();
    if (!isNaN(dawn.getTime())) {
      startEvent = makeTimedEvent(ev, dawn, FAST_BEGINS, options);
    }
    if (dt2.getDay() !== 5 && !(hd.getDate() === 14 && hd.getMonth() === months.NISAN)) {
      const tzeit = zmanim.tzeit(fastEndDeg);
      if (!isNaN(tzeit.getTime())) {
        endEvent = makeTimedEvent(ev, tzeit, FAST_ENDS, options);
      }
    }
  }
  const ev2 = new FastDayEvent(ev, startEvent, endEvent);
  Object.assign(ev2, ev);
  return ev2;
}
function makeTimedEvent(ev, time, desc, options) {
  const location = options.location;
  const hd = ev.getDate();
  return new TimedEvent(hd, desc, ev.getFlags(), time, location, ev, options);
}
var TimedChanukahEvent = class extends ChanukahEvent {
  constructor(date, desc, mask, eventTime, location) {
    super(date, desc, mask);
    this.eventTime = Zmanim.roundTime(eventTime);
    const timeFormat = location.getTimeFormatter();
    this.eventTimeStr = Zmanim.formatTime(this.eventTime, timeFormat);
    this.location = location;
  }
};
function makeWeekdayChanukahCandleLighting(ev, hd, options) {
  const location = options.location;
  const useElevation = Boolean(options.useElevation);
  const zmanim = new Zmanim(location, hd.greg(), useElevation);
  const candleLightingTime = zmanim.beinHaShmashos();
  if (isNaN(candleLightingTime.getTime())) {
    return null;
  }
  const ev2 = new TimedChanukahEvent(hd, ev.getDesc(), ev.getFlags(), candleLightingTime, location);
  ev2.emoji = ev.emoji;
  ev2.chanukahDay = ev.chanukahDay;
  return ev2;
}

// node_modules/@hebcal/core/dist/esm/molad.js
var shortDayNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var heDayNames = [
  "רִאשׁוֹן",
  "שֵׁנִי",
  "שְׁלִישִׁי",
  "רְבִיעִי",
  "חֲמִישִׁי",
  "שִׁישִּׁי",
  "שַׁבָּת"
];
var frDayNames = ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"];
var night = "בַּלַּ֥יְלָה";
function getHebrewTimeOfDay(hour) {
  if (hour < 5)
    return night;
  else if (hour < 12)
    return "בַּבֹּקֶר";
  else if (hour < 17)
    return "בַּצׇּהֳרַיִים";
  else if (hour < 21)
    return "בָּעֶרֶב";
  return night;
}
var Molad = class {
  /**
   * Calculates the molad for a Hebrew month
   * @param year
   * @param month
   */
  constructor(year, month) {
    this.m = molad(year, month);
  }
  /**
   */
  getYear() {
    return this.m.year;
  }
  /**
   */
  getMonth() {
    return this.m.month;
  }
  /**
   */
  getMonthName() {
    return HDate.getMonthName(this.m.month, this.m.year);
  }
  /**
   * @returns Day of Week (0=Sunday, 6=Saturday)
   */
  getDow() {
    return this.m.dayOfWeek;
  }
  /**
   * @returns hour of day (0-23)
   */
  getHour() {
    return this.m.hour;
  }
  /**
   * @returns minutes past hour (0-59)
   */
  getMinutes() {
    return this.m.minutes;
  }
  /**
   * @returns parts of a minute (0-17)
   */
  getChalakim() {
    return this.m.chalakim;
  }
  /**
   * @param [locale] Optional locale name (defaults to active locale)
   * @param options
   */
  render(locale, options) {
    var _a;
    locale = locale !== null && locale !== void 0 ? locale : Locale.getLocaleName();
    if (typeof locale === "string") {
      locale = locale.toLowerCase();
    }
    const isHebrewLocale = locale === "he" || locale === "he-x-nonikud" || locale === "h";
    const isFrenchLocale = locale === "fr";
    const monthName = Locale.gettext(this.getMonthName(), locale);
    const dayNames = isHebrewLocale ? heDayNames : isFrenchLocale ? frDayNames : shortDayNames;
    const dow = dayNames[this.getDow()];
    const minutes = this.getMinutes();
    const hour = this.getHour();
    const chalakim = this.getChalakim();
    const moladStr = Locale.gettext("Molad", locale);
    const minutesStr = (_a = Locale.lookupTranslation("min", locale)) !== null && _a !== void 0 ? _a : "minutes";
    const chalakimStr = Locale.gettext("chalakim", locale);
    const and = Locale.gettext("and", locale);
    const after = Locale.gettext("after", locale);
    if (isHebrewLocale) {
      const ampm = getHebrewTimeOfDay(hour);
      const result = `${moladStr} ${monthName} יִהְיֶה בַּיּוֹם ${dow} בשָׁבוּעַ, בְּשָׁעָה ${hour} ${ampm}, ו-${minutes} ${minutesStr} ו-${chalakim} ${chalakimStr}`;
      if (locale === "he-x-nonikud") {
        return Locale.hebrewStripNikkud(result);
      }
      return result;
    }
    const fmtTime = reformatTimeStr(`${hour}:00`, "pm", options);
    const month = monthName.replace(/'/g, "’");
    return `${moladStr} ${month}: ${dow}, ${minutes} ${minutesStr} ${and} ${chalakim} ${chalakimStr} ${after} ${fmtTime}`;
  }
};
var MoladEvent = class extends Event {
  /**
   * @param date Hebrew date event occurs
   * @param hyear molad year
   * @param hmonth molad month
   * @param options
   */
  constructor(date, hyear, hmonth, options) {
    const m2 = new Molad(hyear, hmonth);
    const monthName = m2.getMonthName();
    super(date, `Molad ${monthName} ${hyear}`, flags.MOLAD);
    this.molad = m2;
    this.options = options;
  }
  /**
   * @param [locale] Optional locale name (defaults to active locale).
   */
  render(locale) {
    return this.molad.render(locale, this.options);
  }
};

// node_modules/@hebcal/core/dist/esm/omer.js
var sefirot = {
  en: {
    infix: "within ",
    infix26: "within ",
    words: [
      "",
      "Lovingkindness",
      "Might",
      "Beauty",
      "Eternity",
      "Splendor",
      "Foundation",
      "Majesty"
    ],
    pfxWords: null
  },
  he: {
    infix: null,
    infix26: null,
    words: [
      "",
      "חֶֽסֶד",
      "גְּבוּרָה",
      "תִּפְאֶֽרֶת",
      "נֶּֽצַח",
      "הוֹד",
      "יְּסוֹד",
      "מַלְכוּת"
    ],
    pfxWords: [
      "",
      "שֶׁבְּחֶֽסֶד",
      "שֶׁבִּגְבוּרָה",
      "שֶׁבְּתִפְאֶֽרֶת",
      "שֶׁבְּנֶֽצַח",
      "שֶׁבְּהוֹד",
      "שֶׁבִּיְסוֹד",
      "שֶׁבְּמַלְכוּת"
    ]
  },
  translit: {
    infix: "sheb'",
    infix26: "shebi",
    words: [
      "",
      "Chesed",
      "Gevurah",
      "Tiferet",
      "Netzach",
      "Hod",
      "Yesod",
      "Malkhut"
    ],
    pfxWords: null
  }
};
function checkDay(omerDay) {
  if (omerDay < 1 || omerDay > 49) {
    throw new RangeError(`Invalid Omer day ${omerDay}`);
  }
}
function getWeeks(omerDay) {
  const weekNum = Math.floor((omerDay - 1) / 7) + 1;
  const daysWithinWeeks = omerDay % 7 || 7;
  return [weekNum, daysWithinWeeks];
}
function omerTodayIsEn(omerDay) {
  const [weekNumber, daysWithinWeeks] = getWeeks(omerDay);
  const totalDaysStr = omerDay === 1 ? "day" : "days";
  let str = `Today is ${omerDay} ${totalDaysStr}`;
  if (weekNumber > 1 || omerDay === 7) {
    const day7 = daysWithinWeeks === 7;
    const numWeeks = day7 ? weekNumber : weekNumber - 1;
    const weeksStr = numWeeks === 1 ? "week" : "weeks";
    str += `, which is ${numWeeks} ${weeksStr}`;
    if (!day7) {
      const daysStr = daysWithinWeeks === 1 ? "day" : "days";
      str += ` and ${daysWithinWeeks} ${daysStr}`;
    }
  }
  return str + " of the Omer";
}
var tens = ["", "עֲשָׂרָה", "עֶשְׂרִים", "שְׁלוֹשִׁים", "אַרְבָּעִים"];
var ones = [
  "",
  "אֶחָד",
  "שְׁנַיִם",
  "שְׁלוֹשָׁה",
  "אַרְבָּעָה",
  "חֲמִשָּׁה",
  "שִׁשָּׁה",
  "שִׁבְעָה",
  "שְׁמוֹנָה",
  "תִּשְׁעָה"
];
var shnei = "שְׁנֵי";
var yamim = "יָמִים";
var shneiYamim = shnei + " " + yamim;
var shavuot = "שָׁבוּעוֹת";
var yom = "יוֹם";
var yomEchad = yom + " " + ones[1];
var asar = "עָשָׂר";
function omerTodayIsHe(omerDay) {
  const ten = Math.floor(omerDay / 10);
  const one = omerDay % 10;
  let str = "הַיּוֹם ";
  if (omerDay === 11) {
    str += "אַחַד " + asar;
  } else if (omerDay === 12) {
    str += "שְׁנֵים " + asar;
  } else if (12 < omerDay && omerDay < 20) {
    str += ones[one] + " " + asar;
  } else if (omerDay > 9) {
    str += ones[one];
    if (one) {
      str += " ";
      str += ten === 3 ? "וּ" : "וְ";
    }
  }
  if (omerDay > 2) {
    if (omerDay > 20 || omerDay === 10 || omerDay === 20) {
      str += tens[ten];
    }
    if (omerDay < 11) {
      str += ones[one] + " " + yamim + " ";
    } else {
      str += " " + yom + " ";
    }
  } else if (omerDay === 1) {
    str += yomEchad + " ";
  } else {
    str += shneiYamim + " ";
  }
  if (omerDay > 6) {
    str = str.trim();
    str += ", שֶׁהֵם ";
    const weeks = Math.floor(omerDay / 7);
    const days = omerDay % 7;
    if (weeks > 2) {
      str += ones[weeks] + " " + shavuot + " ";
    } else if (weeks === 1) {
      str += "שָׁבֽוּעַ " + ones[1] + " ";
    } else {
      str += shnei + " " + shavuot + " ";
    }
    if (days) {
      if (days === 2 || days === 3) {
        str += "וּ";
      } else if (days === 5) {
        str += "וַ";
      } else {
        str += "וְ";
      }
      if (days > 2) {
        str += ones[days] + " " + yamim + " ";
      } else if (days === 1) {
        str += yomEchad + " ";
      } else {
        str += shneiYamim + " ";
      }
    }
  }
  str += "לָעֽוֹמֶר";
  return str.normalize();
}
var OmerEvent = class extends Event {
  /**
   * @param date
   * @param omerDay
   */
  constructor(date, omerDay) {
    super(date, `Omer ${omerDay}`, flags.OMER_COUNT);
    checkDay(omerDay);
    this.weekNumber = Math.floor((omerDay - 1) / 7) + 1;
    this.daysWithinWeeks = omerDay % 7 || 7;
    this.omer = omerDay;
  }
  /**
   * Returns the sefira. For example, on day 8:
   *  * חֶֽסֶד שֶׁבִּגְבוּרָה
   *  * Chesed shebiGevurah
   *  * Lovingkindness within Might
   * @param lang `en` (English), `he` (Hebrew with nikud), or `translit` (Hebrew in Sephardic transliteration)
   * @returns a string such as `Lovingkindness within Might` or `חֶֽסֶד שֶׁבִּגְבוּרָה`
   */
  sefira(lang = "en") {
    if (lang !== "he" && lang !== "translit") {
      lang = "en";
    }
    const [weekNum, daysWithinWeeks] = getWeeks(this.omer);
    const config = sefirot[lang];
    const pfxWords = config.pfxWords;
    const words = config.words;
    const week = pfxWords ? pfxWords[weekNum] : words[weekNum];
    const dayWithinWeek = words[daysWithinWeeks];
    const infix = pfxWords ? "" : weekNum === 2 || weekNum === 6 ? config.infix26 : config.infix;
    return (dayWithinWeek + " " + infix + week).normalize();
  }
  /**
   * @param [locale] Optional locale name (defaults to active locale).
   */
  render(locale) {
    locale = locale !== null && locale !== void 0 ? locale : Locale.getLocaleName();
    if (typeof locale === "string") {
      locale = locale.toLowerCase();
    }
    const isHebrewLocale = locale === "he" || locale === "he-x-nonikud" || locale === "h";
    const omer = this.omer;
    const nth = isHebrewLocale ? gematriya(omer) : Locale.ordinal(omer, locale);
    return nth + " " + Locale.gettext("day of the Omer", locale);
  }
  /**
   * Returns translation of "Omer day 22" without ordinal numbers.
   * @param [locale] Optional locale name (defaults to active locale).
   */
  renderBrief(locale) {
    return Locale.gettext("Omer", locale) + " " + Locale.gettext("day", locale) + " " + this.omer;
  }
  /**
   * Returns an emoji number symbol with a circle, for example `㊲`
   *  from the “Enclosed CJK Letters and Months” block of the Unicode standard
   * @returns a single Unicode character from `①` through `㊾`
   */
  getEmoji() {
    if (typeof this.emoji === "string")
      return this.emoji;
    let codePoint;
    const omerDay = this.omer;
    if (omerDay <= 20) {
      codePoint = 9312 + omerDay - 1;
    } else if (omerDay <= 35) {
      codePoint = 12881 + omerDay - 21;
    } else {
      codePoint = 12977 + omerDay - 36;
    }
    return String.fromCodePoint(codePoint);
  }
  getWeeks() {
    const day7 = this.daysWithinWeeks === 7;
    return day7 ? this.weekNumber : this.weekNumber - 1;
  }
  getDaysWithinWeeks() {
    return this.daysWithinWeeks;
  }
  /**
   * Returns a sentence with that evening's omer count
   * @returns a string such as `Today is 10 days, which is 1 week and 3 days of the Omer`
   *  or `הַיוֹם עֲשָׂרָה יָמִים, שְׁהֵם שָׁבוּעַ אֶחָד וְשְׁלוֹשָׁה יָמִים לָעוֹמֶר`
   */
  getTodayIs(locale) {
    locale = locale !== null && locale !== void 0 ? locale : Locale.getLocaleName();
    if (typeof locale === "string") {
      locale = locale.toLowerCase();
    }
    const isHebrew = locale === "he" || locale === "he-x-nonikud";
    const str = isHebrew ? omerTodayIsHe(this.omer) : omerTodayIsEn(this.omer);
    if (locale === "he-x-nonikud") {
      return Locale.hebrewStripNikkud(str);
    }
    return str;
  }
  url() {
    return `https://www.hebcal.com/omer/${this.getDate().getFullYear()}/${this.omer}`;
  }
};

// node_modules/@hebcal/core/dist/esm/ParshaEvent.js
var ParshaEvent = class extends Event {
  /**
   * @param parsha - untranslated name of single or double parsha,
   *   such as ['Bereshit'] or ['Achrei Mot', 'Kedoshim']
   */
  constructor(date, parsha, il = false, num = -1) {
    if (!Array.isArray(parsha) || parsha.length === 0 || parsha.length > 2) {
      throw new TypeError("Bad parsha argument");
    }
    const desc = "Parashat " + parsha.join("-");
    super(date, desc, flags.PARSHA_HASHAVUA);
    this.parsha = parsha;
    this.il = Boolean(il);
    this.num = num || -1;
  }
  /**
   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.
   */
  render(locale) {
    return renderParshaName(this.parsha, locale);
  }
  basename() {
    return this.parsha.join("-");
  }
  url() {
    const year = this.getDate().greg().getFullYear();
    if (year < 100) {
      return void 0;
    }
    const dt2 = this.urlDateSuffix();
    const url = "https://www.hebcal.com/sedrot/" + this.basename().toLowerCase().replace(/'/g, "").replace(/ /g, "-") + "-" + dt2;
    return this.il ? url + "?i=on" : url;
  }
  urlDateSuffix() {
    const isoDate = isoDateString(this.getDate().greg());
    return isoDate.replace(/-/g, "");
  }
};

// node_modules/@hebcal/core/dist/esm/parshaYear.js
function parshaYear(year, il) {
  const sedra = getSedra(year, il);
  const startAbs = sedra.getFirstSaturday();
  const endAbs = HDate.hebrew2abs(year, months.ELUL, 29);
  const events = [];
  for (let absDt = startAbs; absDt <= endAbs; absDt += 7) {
    const parsha = sedra.lookup(absDt);
    if (!parsha.chag) {
      const ev = new ParshaEvent(parsha.hdate, parsha.parsha, il, parsha.num);
      events.push(ev);
    }
  }
  return events;
}

// node_modules/@hebcal/core/dist/esm/MevarchimChodeshEvent.js
var mevarchimChodeshStr = "Shabbat Mevarchim Chodesh";
var MevarchimChodeshEvent = class extends Event {
  /**
   * Constructs Mevarchim haChodesh event
   * @param date Hebrew date event occurs
   * @param monthName Hebrew month name (not translated)
   * @param [memo]
   * @param locale Optional locale name
   */
  constructor(date, monthName, memo, locale) {
    super(date, `${mevarchimChodeshStr} ${monthName}`, flags.SHABBAT_MEVARCHIM);
    this.monthName = Locale.gettext(monthName, locale);
    if (memo) {
      this.memo = memo;
    } else {
      const hyear = date.getFullYear();
      const hmonth = date.getMonth();
      const monNext = hmonth === HDate.monthsInYear(hyear) ? months.NISAN : hmonth + 1;
      const molad2 = new Molad(hyear, monNext);
      this.memo = molad2.render("en", { hour12: false });
    }
  }
  basename() {
    return this.getDesc();
  }
  /**
   * Returns (translated) description of this event
   * @param [locale] Optional locale name (defaults to active locale).
   */
  render(locale) {
    const monthName0 = Locale.gettext(this.monthName, locale);
    const monthName = monthName0.replace(/'/g, "’");
    return Locale.gettext(mevarchimChodeshStr, locale) + " " + monthName;
  }
  /**
   * Returns (translated) description of this event
   * @param [locale] Optional locale name (defaults to active locale).
   */
  renderBrief(locale) {
    const str = this.render(locale);
    const space = str.indexOf(" ");
    return str.substring(space + 1);
  }
};

// node_modules/@hebcal/core/dist/esm/DailyLearning.js
var cals = /* @__PURE__ */ new Map();
var DailyLearning = class {
  /**
   * Register a new learning calendar.
   * @param name case insensitive
   * @param calendar a function that returns an `Event` or `null`
   * @param startDate the first date for which this calendar is valid
   */
  static addCalendar(name, calendar2, startDate) {
    if (typeof calendar2 !== "function") {
      throw new TypeError(`Invalid calendar function: ${calendar2}`);
    }
    cals.set(name.toLowerCase(), {
      fn: calendar2,
      startDate
    });
  }
  /**
   * Returns an event from daily calendar for a given date. Returns `null` if there
   * is no learning from this calendar on this date.
   * @param name case insensitive
   * @param hd Hebrew Date
   * @param il true for Israel, false for Diaspora
   */
  static lookup(name, hd, il) {
    const cal = cals.get(name.toLowerCase());
    if (typeof cal === "object") {
      return cal.fn(hd, il);
    }
    return null;
  }
  static getStartDate(name) {
    const cal = cals.get(name.toLowerCase());
    if (typeof cal === "object") {
      return cal.startDate;
    }
    return void 0;
  }
  /**
   * Tests to see if learning calendar has been registered
   * @param name case insensitive
   */
  static has(name) {
    return cals.has(name.toLowerCase());
  }
  /** Returns the names of all calendars registered */
  static getCalendars() {
    return Array.from(cals.keys());
  }
};

// node_modules/@hebcal/core/dist/esm/hallel.js
var NONE = 0;
var HALF = 1;
var WHOLE = 2;
function hallel_(events, hdate) {
  const whole = events.filter((ev) => {
    const desc = ev.getDesc();
    const hd = ev.getDate();
    const month = hd.getMonth();
    const mday = hd.getDate();
    return desc.startsWith("Chanukah") || desc.startsWith("Shavuot") || desc.startsWith("Sukkot") || month === months.NISAN && (mday === 15 || mday === 16) && ev.getFlags() & flags.CHAG || // Pesach
    desc === "Yom HaAtzma'ut" || desc === "Yom Yerushalayim";
  }).map((ev) => {
    return ev.getDate().abs();
  });
  const abs = hdate.abs();
  if (whole.includes(abs)) {
    return WHOLE;
  }
  const half = events.filter((ev) => {
    const desc = ev.getDesc();
    return ev.getFlags() & flags.ROSH_CHODESH || desc.startsWith("Pesach") && desc !== "Pesach I" && desc !== "Pesach II";
  }).map((ev) => {
    return ev.getDate().abs();
  });
  if (half.includes(abs)) {
    return HALF;
  }
  return NONE;
}

// node_modules/@hebcal/core/dist/esm/tachanun.js
function range2(start, end) {
  const arr = [];
  for (let i2 = start; i2 <= end; i2++) {
    arr.push(i2);
  }
  return arr;
}
var NONE2 = {
  shacharit: false,
  mincha: false,
  allCongs: false
};
function tachanun(hdate, il) {
  return tachanun0(hdate, il, true);
}
function tachanun0(hdate, il, checkNext) {
  const year = hdate.yy;
  const dates = tachanunYear(year, il);
  const abs = hdate.abs();
  if (dates.none.indexOf(abs) > -1) {
    return NONE2;
  }
  const dow = hdate.getDay();
  const ret = {
    shacharit: false,
    mincha: false,
    allCongs: false
  };
  if (dates.some.indexOf(abs) === -1) {
    ret.allCongs = true;
  }
  if (dow !== 6) {
    ret.shacharit = true;
  }
  const tomorrow = abs + 1;
  if (checkNext && dates.yesPrev.indexOf(tomorrow) === -1) {
    const tmp = tachanun0(new HDate(tomorrow), il, false);
    ret.mincha = tmp.shacharit;
  } else {
    ret.mincha = dow !== 5;
  }
  if (ret.allCongs && !ret.mincha && !ret.shacharit) {
    return NONE2;
  }
  return ret;
}
function tachanunYear(year, il) {
  const leap = HDate.isLeapYear(year);
  const monthsInYear2 = HDate.monthsInYear(year);
  let av9dt = new HDate(9, months.AV, year);
  if (av9dt.getDay() === 6) {
    av9dt = av9dt.next();
  }
  let shushPurim = new HDate(15, months.ADAR_II, year);
  if (shushPurim.getDay() === 6) {
    shushPurim = shushPurim.next();
  }
  const none = [
    new HDate(2, months.TISHREI, year)
    // Rosh Hashana II
  ].concat(
    // Rosh Chodesh - 1st of every month. Also includes RH day 1 (1 Tishrei)
    range2(1, monthsInYear2).map((month) => new HDate(1, month, year)),
    // Rosh Chodesh - 30th of months that have one
    range2(1, monthsInYear2).filter((month) => HDate.daysInMonth(month, year) === 30).map((month) => new HDate(30, month, year)),
    // entire month of Nisan
    range2(1, HDate.daysInMonth(months.NISAN, year)).map((mday) => new HDate(mday, months.NISAN, year)),
    new HDate(18, months.IYYAR, year),
    // Lag BaOmer
    // Rosh Chodesh Sivan thru Isru Chag
    range2(1, 8 - (il ? 1 : 0)).map((mday) => new HDate(mday, months.SIVAN, year)),
    av9dt,
    // Tisha B'Av
    new HDate(15, months.AV, year),
    // Tu B'Av
    new HDate(29, months.ELUL, year),
    // Erev Rosh Hashanah
    // Erev Yom Kippur thru Isru Chag
    range2(9, 24 - (il ? 1 : 0)).map((mday) => new HDate(mday, months.TISHREI, year)),
    // Chanukah
    range2(25, 33).map((mday) => new HDate(mday, months.KISLEV, year)),
    new HDate(15, months.SHVAT, year),
    // Tu BiShvat
    new HDate(14, months.ADAR_II, year),
    // Purim
    shushPurim,
    leap ? new HDate(14, months.ADAR_I, year) : []
    // Purim Katan
  );
  const some = [
    new HDate(14, months.IYYAR, year)
    // Pesach Sheini
  ].concat(
    // Until 14 Sivan
    range2(1, 13).map((mday) => new HDate(mday, months.SIVAN, year)),
    // Until after Rosh Chodesh Cheshvan
    range2(20, 31).map((mday) => new HDate(mday, months.TISHREI, year)),
    // Yom HaAtzma'ut, which changes based on day of week
    year >= 5708 ? dateYomHaZikaron(year).next() : [],
    // Yom Yerushalayim
    year >= 5727 ? new HDate(28, months.IYYAR, year) : []
  );
  const yesPrev = [
    new HDate(29, months.ELUL, year - 1),
    // Erev Rosh Hashanah
    new HDate(9, months.TISHREI, year),
    // Erev Yom Kippur
    new HDate(14, months.IYYAR, year)
    // Pesach Sheini
  ];
  return {
    none: none.map((hd) => hd.abs()).sort((a2, b2) => a2 - b2),
    some: some.map((hd) => hd.abs()).sort((a2, b2) => a2 - b2),
    yesPrev: yesPrev.map((hd) => hd.abs()).sort((a2, b2) => a2 - b2)
  };
}

// node_modules/@hebcal/core/dist/esm/getStartAndEnd.js
var TISHREI3 = months.TISHREI;
function getAbs(d2) {
  if (typeof d2 === "number")
    return d2;
  if (isDate(d2))
    return greg2abs(d2);
  if (HDate.isHDate(d2))
    return d2.abs();
  throw new TypeError(`Invalid date type: ${d2}`);
}
function getYear(options) {
  if (typeof options.year !== "undefined") {
    return Number(options.year);
  }
  return options.isHebrewYear ? new HDate().getFullYear() : (/* @__PURE__ */ new Date()).getFullYear();
}
function getStartAndEnd(options) {
  if (options.start && !options.end || options.end && !options.start) {
    throw new TypeError("Both options.start and options.end are required");
  } else if (options.start && options.end) {
    return [getAbs(options.start), getAbs(options.end)];
  }
  const isHebrewYear = Boolean(options.isHebrewYear);
  const theYear = getYear(options);
  if (isNaN(theYear)) {
    throw new RangeError(`Invalid year ${options.year}`);
  } else if (isHebrewYear && theYear < 1) {
    throw new RangeError(`Invalid Hebrew year ${theYear}`);
  }
  const theMonth = getMonth(options);
  const numYears = Number(options.numYears) || 1;
  if (isHebrewYear) {
    return startEndHebrew(theMonth, theYear, numYears);
  } else {
    return startEndGregorian(theMonth, theYear, numYears);
  }
}
function getMonth(options) {
  if (options.month) {
    if (options.isHebrewYear) {
      return HDate.monthNum(options.month);
    } else if (typeof options.month === "number") {
      return options.month;
    }
  }
  return NaN;
}
function startEndGregorian(theMonth, theYear, numYears) {
  const gregMonth = theMonth ? theMonth - 1 : 0;
  const startGreg = new Date(theYear, gregMonth, 1);
  if (theYear < 100) {
    startGreg.setFullYear(theYear);
  }
  const startAbs = greg2abs(startGreg);
  let endAbs;
  if (theMonth) {
    endAbs = startAbs + daysInGregMonth(theMonth, theYear) - 1;
  } else {
    const endYear = theYear + numYears;
    const endGreg = new Date(endYear, 0, 1);
    if (endYear < 100) {
      endGreg.setFullYear(endYear);
    }
    endAbs = greg2abs(endGreg) - 1;
  }
  return [startAbs, endAbs];
}
function startEndHebrew(theMonth, theYear, numYears) {
  const startDate = new HDate(1, theMonth || TISHREI3, theYear);
  let startAbs = startDate.abs();
  const endAbs = theMonth ? startAbs + startDate.daysInMonth() : new HDate(1, TISHREI3, theYear + numYears).abs() - 1;
  if (!theMonth && theYear > 1) {
    startAbs--;
  }
  return [startAbs, endAbs];
}

// node_modules/@hebcal/core/dist/esm/calendar.js
function calendar(options = {}) {
  options = Object.assign({}, options);
  checkCandleOptions(options);
  const location = options.location = options.location || defaultLocation;
  const il = options.il = options.il || location.getIsrael() || false;
  const hasUserMask = typeof options.mask === "number";
  options.mask = getMaskFromOptions(options);
  if (options.ashkenazi || options.locale) {
    if (options.locale && typeof options.locale !== "string") {
      throw new TypeError(`Invalid options.locale: ${options.locale}`);
    }
    const locale = options.ashkenazi ? "ashkenazi" : options.locale;
    const translationObj = Locale.useLocale(locale);
    if (!translationObj) {
      throw new TypeError(`Locale '${locale}' not found; did you forget to import @hebcal/locales?`);
    }
  } else {
    Locale.useLocale("en");
  }
  const evts = [];
  let sedra;
  let holidaysYear;
  let beginOmer = -1;
  let endOmer = -1;
  let currentYear = -1;
  const startAndEnd = getStartAndEnd(options);
  warnUnrecognizedOptions(options);
  const startAbs = startAndEnd[0];
  const endAbs = startAndEnd[1];
  const startGreg = abs2greg(startAbs);
  if (startGreg.getFullYear() < 100) {
    options.candlelighting = false;
  }
  for (let abs = startAbs; abs <= endAbs; abs++) {
    const hd = new HDate(abs);
    const hyear = hd.getFullYear();
    if (hyear !== currentYear) {
      currentYear = hyear;
      holidaysYear = getHolidaysForYear_(currentYear);
      if (options.sedrot) {
        sedra = getSedra(currentYear, il);
      }
      if (options.omer) {
        beginOmer = HDate.hebrew2abs(currentYear, NISAN5, 16);
        endOmer = HDate.hebrew2abs(currentYear, SIVAN2, 5);
      }
    }
    const prevEventsLength = evts.length;
    const dow = hd.getDay();
    const isFriday = dow === FRI3;
    const isSaturday = dow === SAT3;
    let candlesEv;
    const holidays = holidaysYear.get(hd.toString()) || [];
    for (const ev of holidays) {
      candlesEv = appendHolidayAndRelated(candlesEv, evts, ev, options, isFriday, isSaturday, hasUserMask);
    }
    if (options.sedrot && isSaturday) {
      const parsha0 = sedra.lookup(abs);
      if (!parsha0.chag) {
        evts.push(new ParshaEvent(hd, parsha0.parsha, il, parsha0.num));
      }
    }
    if (options.yizkor) {
      const mm = hd.getMonth();
      const dd = hd.getDate();
      if (mm === months.TISHREI && (dd === 10 || dd === 22) || mm === NISAN5 && dd === (il ? 21 : 22) || mm === SIVAN2 && dd === (il ? 6 : 7)) {
        const linkedEvent = holidays.filter((ev2) => ev2.observedIn(il))[0];
        const ev = new Event(hd, "Yizkor", flags.YIZKOR, {
          emoji: "🕯️",
          linkedEvent
        });
        evts.push(ev);
      }
    }
    const dailyLearning = options.dailyLearning;
    let numDailyLearning = 0;
    if (typeof dailyLearning === "object") {
      const events = makeDailyLearning(hd, dailyLearning, il);
      numDailyLearning = events.length;
      if (numDailyLearning) {
        evts.push(...events);
      }
    }
    if (options.omer && abs >= beginOmer && abs <= endOmer) {
      const omer = abs - beginOmer + 1;
      const omerEv = makeOmerEvent(hd, omer, options);
      evts.push(omerEv);
    }
    if (isSaturday && (options.molad || options.shabbatMevarchim)) {
      const events = makeMoladAndMevarchimChodesh(hd, options);
      evts.push(...events);
    }
    if (!candlesEv && options.candlelighting && (isFriday || isSaturday)) {
      candlesEv = makeCandleEvent(void 0, hd, options, isFriday, isSaturday);
      if (isFriday && candlesEv && sedra) {
        const parsha = sedra.lookup(abs);
        const pe2 = new ParshaEvent(hd.next(), parsha.parsha, il, parsha.num);
        candlesEv.memo = pe2.render(options.locale);
      }
    }
    if (candlesEv instanceof HavdalahEvent && (options.havdalahMins === 0 || options.havdalahDeg === 0)) {
      candlesEv = void 0;
    }
    if (candlesEv) {
      evts.push(candlesEv);
    }
    if (options.addHebrewDates || options.addHebrewDatesForEvents && prevEventsLength !== evts.length - numDailyLearning) {
      const e2 = new HebrewDateEvent(hd);
      if (prevEventsLength === evts.length) {
        evts.push(e2);
      } else {
        evts.splice(prevEventsLength, 0, e2);
      }
    }
  }
  return evts;
}
var FRI3 = 5;
var SAT3 = 6;
var NISAN5 = months.NISAN;
var SIVAN2 = months.SIVAN;
var ELUL2 = months.ELUL;
var LIGHT_CANDLES4 = flags.LIGHT_CANDLES;
var YOM_TOV_ENDS2 = flags.YOM_TOV_ENDS;
var CHUL_ONLY2 = flags.CHUL_ONLY;
var IL_ONLY3 = flags.IL_ONLY;
var LIGHT_CANDLES_TZEIS4 = flags.LIGHT_CANDLES_TZEIS;
var CHANUKAH_CANDLES3 = flags.CHANUKAH_CANDLES;
var MINOR_FAST2 = flags.MINOR_FAST;
var SPECIAL_SHABBAT2 = flags.SPECIAL_SHABBAT;
var MODERN_HOLIDAY2 = flags.MODERN_HOLIDAY;
var MAJOR_FAST3 = flags.MAJOR_FAST;
var ROSH_CHODESH = flags.ROSH_CHODESH;
var PARSHA_HASHAVUA = flags.PARSHA_HASHAVUA;
var DAF_YOMI = flags.DAF_YOMI;
var MISHNA_YOMI = flags.MISHNA_YOMI;
var NACH_YOMI = flags.NACH_YOMI;
var YERUSHALMI_YOMI = flags.YERUSHALMI_YOMI;
var OMER_COUNT = flags.OMER_COUNT;
var SHABBAT_MEVARCHIM = flags.SHABBAT_MEVARCHIM;
var MINOR_HOLIDAY3 = flags.MINOR_HOLIDAY;
var EREV3 = flags.EREV;
var CHOL_HAMOED2 = flags.CHOL_HAMOED;
var YOM_KIPPUR_KATAN = flags.YOM_KIPPUR_KATAN;
var YIZKOR = flags.YIZKOR;
var unrecognizedAlreadyWarned = /* @__PURE__ */ new Set();
var RECOGNIZED_OPTIONS = {
  location: 1,
  year: 1,
  isHebrewYear: 1,
  month: 1,
  numYears: 1,
  start: 1,
  end: 1,
  candlelighting: 1,
  candleLightingMins: 1,
  havdalahMins: 1,
  havdalahDeg: 1,
  fastEndDeg: 1,
  sedrot: 1,
  il: 1,
  noMinorFast: 1,
  noModern: 1,
  shabbatMevarchim: 1,
  noRoshChodesh: 1,
  noSpecialShabbat: 1,
  noHolidays: 1,
  omer: 1,
  molad: 1,
  ashkenazi: 1,
  locale: 1,
  addHebrewDates: 1,
  addHebrewDatesForEvents: 1,
  mask: 1,
  yomKippurKatan: 1,
  hour12: 1,
  dailyLearning: 1,
  useElevation: 1,
  yizkor: 1
};
function warnUnrecognizedOptions(options) {
  for (const k2 of Object.keys(options)) {
    if (typeof RECOGNIZED_OPTIONS[k2] === "undefined" && !unrecognizedAlreadyWarned.has(k2)) {
      console.warn(`Ignoring unrecognized HebrewCalendar option: ${k2}`);
      unrecognizedAlreadyWarned.add(k2);
    }
  }
  if (options.dailyLearning) {
    for (const k2 of Object.keys(options.dailyLearning)) {
      if (!unrecognizedAlreadyWarned.has(k2) && !DailyLearning.has(k2)) {
        console.warn(`Ignoring unrecognized DailyLearning calendar: ${k2}`);
        unrecognizedAlreadyWarned.add(k2);
      }
    }
  }
}
var israelCityOffset = {
  Jerusalem: 40,
  Haifa: 30,
  "Zikhron Ya'aqov": 30,
  "Zikhron Ya'akov": 30,
  "Zikhron Yaakov": 30,
  "Zichron Ya'akov": 30,
  "Zichron Yaakov": 30
};
var geoIdCandleOffset = {
  "281184": 40,
  // Jerusalem
  "294801": 30,
  // Haifa
  "293067": 30
  // Zikhron Yaakov
};
var TZEIT_3SMALL_STARS = 8.5;
var TZEIT_3MEDIUM_STARS = 7.0833333;
function checkCandleOptions(options) {
  if (!options.candlelighting) {
    return;
  }
  const location = options.location;
  if (typeof location === "undefined" || !(location instanceof Location)) {
    throw new TypeError("options.candlelighting requires valid options.location");
  }
  if (typeof options.havdalahMins === "number" && typeof options.havdalahDeg === "number") {
    throw new TypeError("options.havdalahMins and options.havdalahDeg are mutually exclusive");
  }
  const min0 = options.candleLightingMins;
  let min = typeof min0 === "number" && !isNaN(min0) ? Math.trunc(min0) : 18;
  if (location.getIsrael() && Math.abs(min) === 18) {
    min = overrideIsraelCandleMins(location, min);
  }
  options.candleLightingMins = -1 * Math.abs(min);
  if (typeof options.havdalahMins === "number") {
    options.havdalahMins = Math.trunc(Math.abs(options.havdalahMins));
  } else if (typeof options.havdalahDeg === "number") {
    options.havdalahDeg = Math.abs(options.havdalahDeg);
  } else {
    options.havdalahDeg = TZEIT_3SMALL_STARS;
  }
  if (typeof options.fastEndDeg !== "number") {
    options.fastEndDeg = TZEIT_3MEDIUM_STARS;
  }
}
function overrideIsraelCandleMins(location, min) {
  const geoid = location.getGeoId();
  if (geoid) {
    const offset = geoIdCandleOffset[geoid];
    if (typeof offset === "number") {
      return offset;
    }
  }
  const shortName = location.getShortName();
  if (shortName) {
    const offset = israelCityOffset[shortName];
    if (typeof offset === "number") {
      return offset;
    }
  }
  return min;
}
function getMaskFromOptions(options) {
  var _a;
  if (typeof options.mask === "number") {
    return setOptionsFromMask(options);
  }
  const il = options.il || ((_a = options.location) === null || _a === void 0 ? void 0 : _a.getIsrael()) || false;
  let mask = 0;
  if (!options.noHolidays) {
    mask |= ROSH_CHODESH | YOM_TOV_ENDS2 | MINOR_FAST2 | SPECIAL_SHABBAT2 | MODERN_HOLIDAY2 | MAJOR_FAST3 | MINOR_HOLIDAY3 | EREV3 | CHOL_HAMOED2 | LIGHT_CANDLES4 | LIGHT_CANDLES_TZEIS4 | CHANUKAH_CANDLES3;
  }
  if (options.candlelighting) {
    mask |= LIGHT_CANDLES4 | LIGHT_CANDLES_TZEIS4 | YOM_TOV_ENDS2;
  }
  if (options.noRoshChodesh) {
    mask &= ~ROSH_CHODESH;
  }
  if (options.noModern) {
    mask &= ~MODERN_HOLIDAY2;
  }
  if (options.noMinorFast) {
    mask &= ~MINOR_FAST2;
  }
  if (options.noSpecialShabbat) {
    mask &= ~SPECIAL_SHABBAT2;
    mask &= ~SHABBAT_MEVARCHIM;
  }
  if (il) {
    mask |= IL_ONLY3;
  } else {
    mask |= CHUL_ONLY2;
  }
  if (options.sedrot) {
    mask |= PARSHA_HASHAVUA;
  }
  if (options.omer) {
    mask |= OMER_COUNT;
  }
  if (options.shabbatMevarchim) {
    mask |= SHABBAT_MEVARCHIM;
  }
  if (options.yomKippurKatan) {
    mask |= YOM_KIPPUR_KATAN;
  }
  if (options.yizkor) {
    mask |= YIZKOR;
  }
  if (options.dailyLearning) {
    const dailyLearning = options.dailyLearning;
    if (dailyLearning.dafYomi) {
      mask |= DAF_YOMI;
    }
    if (dailyLearning.mishnaYomi) {
      mask |= MISHNA_YOMI;
    }
    if (dailyLearning.nachYomi) {
      mask |= NACH_YOMI;
    }
    if (dailyLearning.yerushalmi) {
      mask |= YERUSHALMI_YOMI;
    }
  }
  return mask;
}
var MASK_LIGHT_CANDLES = LIGHT_CANDLES4 | LIGHT_CANDLES_TZEIS4 | CHANUKAH_CANDLES3 | YOM_TOV_ENDS2;
var defaultLocation = new Location(0, 0, false, "UTC");
function setOptionsFromMask(options) {
  const m2 = options.mask || 0;
  if (m2 & ROSH_CHODESH)
    delete options.noRoshChodesh;
  if (m2 & MODERN_HOLIDAY2)
    delete options.noModern;
  if (m2 & MINOR_FAST2)
    delete options.noMinorFast;
  if (m2 & SPECIAL_SHABBAT2)
    delete options.noSpecialShabbat;
  if (m2 & PARSHA_HASHAVUA)
    options.sedrot = true;
  if (m2 & (DAF_YOMI | MISHNA_YOMI | NACH_YOMI | YERUSHALMI_YOMI)) {
    options.dailyLearning = options.dailyLearning || {};
    if (m2 & DAF_YOMI) {
      options.dailyLearning.dafYomi = true;
    }
    if (m2 & MISHNA_YOMI) {
      options.dailyLearning.mishnaYomi = true;
    }
    if (m2 & NACH_YOMI) {
      options.dailyLearning.nachYomi = true;
    }
    if (m2 & YERUSHALMI_YOMI) {
      options.dailyLearning.yerushalmi = 1;
    }
  }
  if (m2 & OMER_COUNT)
    options.omer = true;
  if (m2 & SHABBAT_MEVARCHIM)
    options.shabbatMevarchim = true;
  if (m2 & YOM_KIPPUR_KATAN)
    options.yomKippurKatan = true;
  if (m2 & YIZKOR)
    options.yizkor = true;
  return m2;
}
function appendHolidayAndRelated(candlesEv, events, ev, options, isFriday, isSaturday, hasUserMask) {
  const il = options.il || false;
  if (!ev.observedIn(il)) {
    return candlesEv;
  }
  const eFlags = ev.getFlags();
  if (!options.yomKippurKatan && eFlags & YOM_KIPPUR_KATAN || options.noModern && eFlags & MODERN_HOLIDAY2) {
    return candlesEv;
  }
  const isMajorFast = Boolean(eFlags & MAJOR_FAST3);
  const isMinorFast = Boolean(eFlags & MINOR_FAST2);
  let fastEv;
  if (options.candlelighting && (isMajorFast || isMinorFast) && ev.getDesc() !== "Yom Kippur") {
    ev = fastEv = makeFastStartEnd(ev, options);
    if (fastEv.startEvent && (isMajorFast || isMinorFast && !options.noMinorFast)) {
      events.push(fastEv.startEvent);
    }
  }
  if (eFlags & Number(options.mask) || !eFlags && !hasUserMask) {
    if (options.candlelighting && eFlags & MASK_LIGHT_CANDLES) {
      const hd = ev.getDate();
      candlesEv = makeCandleEvent(ev, hd, options, isFriday, isSaturday);
      if (eFlags & CHANUKAH_CANDLES3 && candlesEv && !options.noHolidays) {
        const chanukahEv = makeWeekdayChanukahCandleLighting(ev, hd, options);
        if (chanukahEv) {
          if (isFriday || isSaturday) {
            chanukahEv.eventTime = candlesEv.eventTime;
            chanukahEv.eventTimeStr = candlesEv.eventTimeStr;
          }
          ev = chanukahEv;
        }
        candlesEv = void 0;
      }
    }
    if (!options.noHolidays || options.yomKippurKatan && eFlags & YOM_KIPPUR_KATAN) {
      events.push(ev);
    }
  }
  if ((isMajorFast || isMinorFast && !options.noMinorFast) && fastEv && fastEv.endEvent) {
    events.push(fastEv.endEvent);
  }
  return candlesEv;
}
function makeMoladAndMevarchimChodesh(hd, options) {
  const evts = [];
  const hmonth = hd.getMonth();
  const hdate = hd.getDate();
  if (hmonth !== ELUL2 && hdate >= 23 && hdate <= 29) {
    const hyear = hd.getFullYear();
    const monNext = hmonth === HDate.monthsInYear(hyear) ? NISAN5 : hmonth + 1;
    if (options.molad) {
      evts.push(new MoladEvent(hd, hyear, monNext, options));
    }
    if (options.shabbatMevarchim) {
      const nextMonthName = HDate.getMonthName(monNext, hyear);
      const molad2 = new Molad(hyear, monNext);
      const memo = molad2.render(options.locale || "en", options);
      evts.push(new MevarchimChodeshEvent(hd, nextMonthName, memo, options.locale));
    }
  }
  return evts;
}
function dailyLearningName(key, val) {
  if (key === "yerushalmi") {
    return val === 2 ? "yerushalmi-schottenstein" : "yerushalmi-vilna";
  }
  return key;
}
function makeDailyLearning(hd, dailyLearning, il) {
  const evts = [];
  for (const [key, val] of Object.entries(dailyLearning)) {
    if (val) {
      const name = dailyLearningName(key, val);
      const learningEv = DailyLearning.lookup(name, hd, il);
      if (learningEv) {
        evts.push(learningEv);
      }
    }
  }
  return evts;
}
function makeOmerEvent(hd, omerDay, options) {
  const omerEv = new OmerEvent(hd, omerDay);
  if (options.candlelighting) {
    const location = options.location;
    const zmanim = new Zmanim(location, hd.prev(), false);
    const tzeit = zmanim.tzeit(7.0833);
    if (!isNaN(tzeit.getTime())) {
      omerEv.alarm = tzeit;
    }
  }
  return omerEv;
}

// node_modules/@hebcal/core/dist/esm/hebcal.js
var HebrewCalendar = class {
  constructor() {
  }
  /**
   * Calculates holidays and other Hebrew calendar events based on {@link CalOptions}.
   *
   * Each holiday is represented by an {@link Event} object which includes a date,
   * a description, flags and optional attributes.
   * If given no options, returns holidays for the Diaspora for the current Gregorian year.
   *
   * The date range returned by this function can be controlled by:
   * * `options.year` - Gregorian (e.g. 1993) or Hebrew year (e.g. 5749)
   * * `options.isHebrewYear` - to interpret `year` as Hebrew year
   * * `options.numYears` - generate calendar for multiple years (default 1)
   * * `options.month` - Gregorian or Hebrew month (to filter results to a single month)
   *
   * Alternatively, specify start and end days with `Date` or {@link HDate} instances:
   * * `options.start` - use specific start date (requires `end` date)
   * * `options.end` - use specific end date (requires `start` date)
   *
   * Unless `options.noHolidays == true`, default holidays include:
   * * Major holidays - Rosh Hashana, Yom Kippur, Pesach, Sukkot, etc.
   * * Minor holidays - Purim, Chanukah, Tu BiShvat, Lag BaOmer, etc.
   * * Minor fasts - Ta'anit Esther, Tzom Gedaliah, etc. (unless `options.noMinorFast`)
   * * Special Shabbatot - Shabbat Shekalim, Zachor, etc. (unless `options.noSpecialShabbat`)
   * * Modern Holidays - Yom HaShoah, Yom HaAtzma'ut, etc. (unless `options.noModern`)
   * * Rosh Chodesh (unless `options.noRoshChodesh`)
   *
   * Holiday and Torah reading schedules differ between Israel and the Disapora.
   * Set `options.il=true` to use the Israeli schedule.
   *
   * Additional non-default event types can be specified:
   * * Parashat HaShavua - weekly Torah Reading on Saturdays (`options.sedrot`)
   * * Counting of the Omer (`options.omer`)
   * * Shabbat Mevarchim HaChodesh on Saturday before Rosh Chodesh (`options.shabbatMevarchim`)
   * * Molad announcement on Saturday before Rosh Chodesh (`options.molad`)
   * * Yom Kippur Katan (`options.yomKippurKatan`)
   * * Yizkor (`options.yizkor`)
   *
   * Daily Study of texts are supported by the
   * {@link https://github.com/hebcal/hebcal-learning @hebcal/learning} package,
   * for example:
   * * Babylonian Talmud Daf Yomi (`options.dailyLearning.dafYomi`)
   * * Jerusalem Talmud (Yerushalmi) Yomi (`options.dailyLearning.yerushalmi`)
   * * Mishna Yomi (`options.dailyLearning.mishnaYomi`)
   * * Nach Yomi (`options.dailyLearning.nachYomi`)
   *
   * Candle-lighting and Havdalah times are approximated using latitude and longitude
   * specified by the {@link Location} class. The `Location` class contains a small
   * database of cities with their associated geographic information and time-zone information.
   * If you ever have any doubts about Hebcal's times, consult your local halachic authority.
   * If you enter geographic coordinates above the arctic circle or antarctic circle,
   * the times are guaranteed to be wrong.
   *
   * To add candle-lighting options, set `options.candlelighting=true` and set
   * `options.location` to an instance of `Location`. By default, candle lighting
   * time is 18 minutes before sundown (40 minutes for Jerusalem,
   * 30 minutes for Haifa and Zikhron Ya'akov) and Havdalah is
   * calculated according to Tzeit Hakochavim - Nightfall (the point when 3 small stars
   * are observable in the night time sky with the naked eye). The default Havdalah
   * option (Tzeit Hakochavim) is calculated when the sun is 8.5° below the horizon.
   * These defaults can be changed using these options:
   * * `options.candleLightingMins` - minutes before sundown to light candles
   * * `options.havdalahMins` - minutes after sundown for Havdalah (typical values are 42, 50, or 72).
   *    Havdalah times are suppressed when `options.havdalahMins=0`.
   * * `options.havdalahDeg` - degrees for solar depression for Havdalah.
   *    Default is 8.5 degrees for 3 small stars. Use 7.083 degrees for 3 medium-sized stars.
   *    Havdalah times are suppressed when `options.havdalahDeg=0`.
   *
   * If both `options.candlelighting=true` and `options.location` is specified,
   * Chanukah candle-lighting times and minor fast start/end times will also be generated.
   * Chanukah candle-lighting is at Bein HaShmashos (13.5 minutes before
   * the sun is 7.083° below the horizon in the evening)
   * on weekdays, at regular candle-lighting time on Fridays, and at regular Havdalah time on
   * Saturday night (see above).
   *
   * Minor fasts begin at Alot HaShachar (sun is 16.1° below the horizon in the morning) and
   * end when 3 medium-sized stars are observable in the night sky (sun is 7.083° below the horizon
   * in the evening).
   *
   * Two options also exist for generating an Event with the Hebrew date:
   * * `options.addHebrewDates` - print the Hebrew date for the entire date range
   * * `options.addHebrewDatesForEvents` - print the Hebrew date for dates with some events
   *
   * Lastly, translation and transliteration of event titles is controlled by
   * `options.locale` and the {@link Locale} API.
   * `@hebcal/core` supports three locales by default:
   * * `en` - default, Sephardic transliterations (e.g. "Shabbat")
   * * `ashkenazi` - Ashkenazi transliterations (e.g. "Shabbos")
   * * `he` - Hebrew (e.g. "שַׁבָּת")
   *
   * Additional locales (such as `ru` or `fr`) are supported by the
   * {@link https://github.com/hebcal/hebcal-locales @hebcal/locales} package
   *
   * @example
   * import {HebrewCalendar, HDate, Location, Event} from '@hebcal/core';
   * const options: CalOptions = {
   *   year: 1981,
   *   isHebrewYear: false,
   *   candlelighting: true,
   *   location: Location.lookup('San Francisco'),
   *   sedrot: true,
   *   omer: true,
   * };
   * const events = HebrewCalendar.calendar(options);
   * for (const ev of events) {
   *   const hd = ev.getDate();
   *   const date = hd.greg();
   *   console.log(date.toLocaleDateString(), ev.render('en'), hd.toString());
   * }
   */
  static calendar(options = {}) {
    return calendar(options);
  }
  /**
   * Calculates a birthday or anniversary (non-yahrzeit).
   * `hyear` must be after original `gdate` of anniversary.
   * Returns `undefined` when requested year preceeds or is same as original year.
   *
   * Hebcal uses the algorithm defined in "Calendrical Calculations"
   * by Edward M. Reingold and Nachum Dershowitz.
   *
   * The birthday of someone born in Adar of an ordinary year or Adar II of
   * a leap year is also always in the last month of the year, be that Adar
   * or Adar II. The birthday in an ordinary year of someone born during the
   * first 29 days of Adar I in a leap year is on the corresponding day of Adar;
   * in a leap year, the birthday occurs in Adar I, as expected.
   *
   * Someone born on the thirtieth day of Marcheshvan, Kislev, or Adar I
   * has his birthday postponed until the first of the following month in
   * years where that day does not occur. [Calendrical Calculations p. 111]
   * @example
   * import {HebrewCalendar} from '@hebcal/core';
   * const dt = new Date(2014, 2, 2); // '2014-03-02' == '30 Adar I 5774'
   * const hd = HebrewCalendar.getBirthdayOrAnniversary(5780, dt); // '1 Nisan 5780'
   * console.log(hd.greg().toLocaleDateString('en-US')); // '3/26/2020'
   * @param hyear Hebrew year
   * @param gdate Gregorian or Hebrew date of event
   * @returns anniversary occurring in `hyear`
   */
  static getBirthdayOrAnniversary(hyear, gdate) {
    const dt2 = getBirthdayHD(hyear, gdate);
    if (typeof dt2 === "undefined") {
      return dt2;
    }
    return new HDate(dt2);
  }
  /**
   * Calculates yahrzeit.
   * `hyear` must be after original `gdate` of death.
   * Returns `undefined` when requested year preceeds or is same as original year.
   *
   * Hebcal uses the algorithm defined in "Calendrical Calculations"
   * by Edward M. Reingold and Nachum Dershowitz.
   *
   * The customary anniversary date of a death is more complicated and depends
   * also on the character of the year in which the first anniversary occurs.
   * There are several cases:
   *
   * * If the date of death is Marcheshvan 30, the anniversary in general depends
   *   on the first anniversary; if that first anniversary was not Marcheshvan 30,
   *   use the day before Kislev 1.
   * * If the date of death is Kislev 30, the anniversary in general again depends
   *   on the first anniversary — if that was not Kislev 30, use the day before
   *   Tevet 1.
   * * If the date of death is Adar II, the anniversary is the same day in the
   *   last month of the Hebrew year (Adar or Adar II).
   * * If the date of death is Adar I 30, the anniversary in a Hebrew year that
   *   is not a leap year (in which Adar only has 29 days) is the last day in
   *   Shevat.
   * * In all other cases, use the normal (that is, same month number) anniversary
   *   of the date of death. [Calendrical Calculations p. 113]
   * @example
   * import {HebrewCalendar} from '@hebcal/core';
   * const dt = new Date(2014, 2, 2); // '2014-03-02' == '30 Adar I 5774'
   * const hd = HebrewCalendar.getYahrzeit(5780, dt); // '30 Sh\'vat 5780'
   * console.log(hd.greg().toLocaleDateString('en-US')); // '2/25/2020'
   * @param hyear Hebrew year
   * @param gdate Gregorian or Hebrew date of death
   * @returns anniversary occurring in hyear
   */
  static getYahrzeit(hyear, gdate) {
    const dt2 = getYahrzeitHD(hyear, gdate);
    if (typeof dt2 === "undefined") {
      return dt2;
    }
    return new HDate(dt2);
  }
  /**
   * Lower-level holidays interface, which returns a `Map` of `Event`s indexed by
   * `HDate.toString()`. These events must filtered especially for `flags.IL_ONLY`
   * or `flags.CHUL_ONLY` depending on Israel vs. Diaspora holiday scheme.
   * @param year Hebrew year
   */
  static getHolidaysForYear(year) {
    return getHolidaysForYear_(year);
  }
  /**
   * Returns an array of holidays for the year
   * @param year Hebrew year
   * @param il use the Israeli schedule for holidays
   */
  static getHolidaysForYearArray(year, il) {
    return getHolidaysForYearArray(year, il);
  }
  /**
   * Returns an array of Events on this date (or `undefined` if no events)
   * @param date Hebrew Date, Gregorian date, or absolute R.D. day number
   * @param [il] use the Israeli schedule for holidays
   */
  static getHolidaysOnDate(date, il) {
    return getHolidaysOnDate(date, il);
  }
  /**
   * Eruv Tavshilin
   */
  static eruvTavshilin(date, il) {
    if (date.getDay() < 3 || date.getDay() > 4) {
      return false;
    }
    const today = new HDate(date);
    const friday = today.after(5);
    const tomorrow = today.next();
    if (!isChag(friday, il) || isChag(today, il) || !isChag(tomorrow, il)) {
      return false;
    }
    return true;
  }
  /**
   * Helper function to format a 23-hour (00:00-23:59) time in US format ("8:13pm") or
   * keep as "20:13" for any other locale/country. Uses {@link CalOptions} to determine
   * locale.
   * If `options.hour12` is `false`, locale is ignored and always returns 24-hour time.
   * If `options.hour12` is `true`, locale is ignored and always returns 12-hour time.
   * @param timeStr - original time like "20:30"
   * @param suffix - "p" or "pm" or " P.M.". Add leading space if you want it
   * @param options
   */
  static reformatTimeStr(timeStr, suffix, options) {
    return reformatTimeStr(timeStr, suffix, options);
  }
  static version() {
    return version;
  }
  /**
   * Convenience function to create an instance of `Sedra` or reuse a previously
   * created and cached instance.
   */
  static getSedra(hyear, il) {
    return getSedra(hyear, il);
  }
  /**
   * Return a number containing information on what Hallel is said on that day.
   *
   * Whole Hallel is said on Chanukah, the first Yom Tov of Pesach, Shavuot, Sukkot,
   * Yom Ha'atzmaut, and Yom Yerushalayim.
   *
   * Half Hallel is said on Rosh Chodesh (not Rosh Hashanah), and the last 6 days of Pesach.
   *
   * The number is one of the following values:
   *
   * 0 - No Hallel
   * 1 - Half Hallel
   * 2 - Whole Hallel
   */
  static hallel(hdate, il) {
    const events = getHolidaysForYearArray(hdate.getFullYear(), il);
    return hallel_(events, hdate);
  }
  /**
   * Return details on what Tachanun (or Tzidchatcha on Shabbat) is said on `hdate`.
   *
   * Tachanun is not said on Rosh Chodesh, the month of Nisan, Lag Baomer,
   * Rosh Chodesh Sivan until Isru Chag, Tisha B'av, 15 Av, Erev Rosh Hashanah,
   * Rosh Hashanah, Erev Yom Kippur until after Simchat Torah, Chanukah,
   * Tu B'shvat, Purim and Shushan Purim, and Purim and Shushan Purim Katan.
   *
   * In some congregations Tachanun is not said until from Rosh Chodesh Sivan
   * until 14th Sivan, Sukkot until after Rosh Chodesh Cheshvan, Pesach Sheini,
   * Yom Ha'atzmaut, and Yom Yerushalayim.
   *
   * Tachanun is not said at Mincha on days before it is not said at Shacharit.
   *
   * Tachanun is not said at Shacharit on Shabbat, but is at Mincha, usually.
   */
  static tachanun(hdate, il) {
    return tachanun(hdate, il);
  }
};
function isChag(date, il) {
  const events = getHolidaysOnDate(date, il) || [];
  const chag = events.filter((ev) => ev.getFlags() & flags.CHAG);
  return chag.length !== 0;
}
export {
  AsaraBTevetEvent,
  CandleLightingEvent,
  ChanukahEvent,
  DailyLearning,
  Event,
  FastDayEvent,
  GeoLocation,
  HDate,
  HavdalahEvent,
  HebrewCalendar,
  HebrewDateEvent,
  HolidayEvent,
  Locale,
  Location,
  MevarchimChodeshEvent,
  Molad,
  MoladEvent,
  NOAACalculator,
  OmerEvent,
  ParshaEvent,
  RoshChodeshEvent,
  RoshHashanaEvent,
  Sedra,
  TimedChanukahEvent,
  TimedEvent,
  YomKippurKatanEvent,
  Zmanim,
  flags,
  gematriya,
  gematriyaStrToNum,
  getHolidaysOnDate,
  getSedra,
  greg,
  holidayDesc,
  isAssurBemlacha,
  months,
  parshaYear,
  parshiot,
  version
};
/*! Bundled license information:

@hebcal/core/dist/esm/pkgVersion.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/greg.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/gregNamespace.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/hebrewStripNikkud.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/hdateBase.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/anniversary.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/gematriya.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/molad.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/pad.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/dateFormat.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/ashkenazi.po.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/he.po.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/locale.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/hdate.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/hdate/dist/esm/index.js:
  (*! @hebcal/hdate v0.14.4, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/ashkenazi.po.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/he.po.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/he-x-NoNikud.po.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/locale.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/event.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/HebrewDateEvent.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/location.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/zmanim.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/modern.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/parshaName.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/sedra.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/staticHolidays.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/HolidayEvent.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/YomKippurKatanEvent.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/holidays.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/isAssurBemlacha.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/reformatTimeStr.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/TimedEvent.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/candles.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/molad.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/omer.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/ParshaEvent.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/parshaYear.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/MevarchimChodeshEvent.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/DailyLearning.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/hallel.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/tachanun.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/getStartAndEnd.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/calendar.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/hebcal.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)

@hebcal/core/dist/esm/index.js:
  (*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt *)
*/
//# sourceMappingURL=@hebcal_core.js.map
