/*! @hebcal/core v5.10.1, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt */
import { months } from '@hebcal/hdate';
import { flags } from './event.js';
import { HolidayEvent, ChanukahEvent } from './HolidayEvent.js';
import { Zmanim } from './zmanim.js';
import { HavdalahEvent, CandleLightingEvent, TimedEvent } from './TimedEvent.js';

/* eslint-disable max-len */
const LIGHT_CANDLES = flags.LIGHT_CANDLES;
const LIGHT_CANDLES_TZEIS = flags.LIGHT_CANDLES_TZEIS;
/**
 * @private
 */
function makeCandleEvent(ev, hd, options, isFriday, isSaturday) {
    let havdalahTitle = false;
    let useHavdalahOffset = isSaturday;
    let mask = ev ? ev.getFlags() : LIGHT_CANDLES;
    if (typeof ev !== 'undefined') {
        // if linked event && dow == FRI, use Candle lighting time & title
        if (!isFriday) {
            if (mask & (LIGHT_CANDLES_TZEIS | flags.CHANUKAH_CANDLES)) {
                useHavdalahOffset = true;
            }
            else if (mask & flags.YOM_TOV_ENDS) {
                havdalahTitle = true;
                useHavdalahOffset = true;
            }
        }
    }
    else if (isSaturday) {
        havdalahTitle = true;
        mask = LIGHT_CANDLES_TZEIS;
    }
    // if Havdalah offset is 0 or undefined, we'll use tzeit time
    const offset = useHavdalahOffset
        ? Number(options.havdalahMins)
        : Number(options.candleLightingMins);
    const location = options.location;
    const useElevation = Boolean(options.useElevation);
    const zmanim = new Zmanim(location, hd, useElevation);
    const time = useHavdalahOffset && !offset
        ? zmanim.tzeit(options.havdalahDeg)
        : zmanim.sunsetOffset(offset, true);
    if (isNaN(time.getTime())) {
        return undefined; // no sunset
    }
    if (havdalahTitle) {
        return new HavdalahEvent(hd, mask, time, location, options.havdalahMins, ev, options);
    }
    else {
        mask |= LIGHT_CANDLES;
        return new CandleLightingEvent(hd, mask, time, location, ev, options);
    }
}
const FAST_BEGINS = 'Fast begins';
const FAST_ENDS = 'Fast ends';
/** A fast day also contains a start and end time */
class FastDayEvent extends HolidayEvent {
    constructor(linkedEvent, startEvent, endEvent) {
        super(linkedEvent.getDate(), linkedEvent.getDesc(), linkedEvent.getFlags());
        this.linkedEvent = linkedEvent;
        this.startEvent = startEvent;
        this.endEvent = endEvent;
    }
    render(locale) {
        return this.linkedEvent.render(locale);
    }
    renderBrief(locale) {
        return this.linkedEvent.renderBrief(locale);
    }
    urlDateSuffix() {
        return this.linkedEvent.urlDateSuffix();
    }
    url() {
        return this.linkedEvent.url();
    }
    getEmoji() {
        return this.linkedEvent.getEmoji();
    }
    getCategories() {
        return this.linkedEvent.getCategories();
    }
}
/**
 * Makes a pair of events representing fast start and end times
 * @private
 */
function makeFastStartEnd(ev, options) {
    const desc = ev.getDesc();
    if (desc === 'Yom Kippur') {
        throw new RangeError('YK does not require this function');
    }
    const hd = ev.getDate();
    const dt = hd.greg();
    const location = options.location;
    const fastEndDeg = options.fastEndDeg;
    const useElevation = Boolean(options.useElevation);
    const zmanim = new Zmanim(location, dt, useElevation);
    let startEvent;
    let endEvent;
    if (desc === "Erev Tish'a B'Av") {
        const sunset = zmanim.sunset();
        if (!isNaN(sunset.getTime())) {
            startEvent = makeTimedEvent(ev, sunset, FAST_BEGINS, options);
        }
    }
    else if (desc.startsWith("Tish'a B'Av")) {
        const tzeit = zmanim.tzeit(fastEndDeg);
        if (!isNaN(tzeit.getTime())) {
            endEvent = makeTimedEvent(ev, tzeit, FAST_ENDS, options);
        }
    }
    else {
        const dawn = zmanim.alotHaShachar();
        if (!isNaN(dawn.getTime())) {
            startEvent = makeTimedEvent(ev, dawn, FAST_BEGINS, options);
        }
        if (dt.getDay() !== 5 &&
            !(hd.getDate() === 14 && hd.getMonth() === months.NISAN)) {
            const tzeit = zmanim.tzeit(fastEndDeg);
            if (!isNaN(tzeit.getTime())) {
                endEvent = makeTimedEvent(ev, tzeit, FAST_ENDS, options);
            }
        }
    }
    const ev2 = new FastDayEvent(ev, startEvent, endEvent);
    // copy properties such as memo or emoji
    Object.assign(ev2, ev);
    return ev2;
}
/**
 * @private
 */
function makeTimedEvent(ev, time, desc, options) {
    const location = options.location;
    const hd = ev.getDate();
    return new TimedEvent(hd, desc, ev.getFlags(), time, location, ev, options);
}
class TimedChanukahEvent extends ChanukahEvent {
    constructor(date, desc, mask, eventTime, location) {
        super(date, desc, mask);
        this.eventTime = Zmanim.roundTime(eventTime);
        const timeFormat = location.getTimeFormatter();
        this.eventTimeStr = Zmanim.formatTime(this.eventTime, timeFormat);
        this.location = location;
    }
}
/**
 * Makes a candle-lighting event for Chankah (not on Friday/Saturday).
 * At one point this used civil dusk (6 degrees below horizon).
 * Another source suggests 4.6667 degrees below horizon.
 * @private
 */
function makeWeekdayChanukahCandleLighting(ev, hd, options) {
    const location = options.location;
    const useElevation = Boolean(options.useElevation);
    const zmanim = new Zmanim(location, hd.greg(), useElevation);
    const candleLightingTime = zmanim.beinHaShmashos();
    if (isNaN(candleLightingTime.getTime())) {
        return null;
    }
    const ev2 = new TimedChanukahEvent(hd, ev.getDesc(), ev.getFlags(), candleLightingTime, location);
    ev2.emoji = ev.emoji;
    ev2.chanukahDay = ev.chanukahDay;
    return ev2;
}

export { FastDayEvent, TimedChanukahEvent, makeCandleEvent, makeFastStartEnd, makeWeekdayChanukahCandleLighting };
//# sourceMappingURL=candles.js.map
